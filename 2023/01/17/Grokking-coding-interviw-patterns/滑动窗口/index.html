<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>滑动窗口 | 毛毛雨的博客</title><meta name="author" content="毛毛雨"><meta name="copyright" content="毛毛雨"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="滑动窗口双指针变体，允许我们处理分段数据而不是整体list.（如需要找数组中三个连续整数的最大和window size可以设置成三）time complexity 从O(kn)降低到O(n) 什么样的情况下问题符合滑动窗口使用条件两种条件都满足的情况下符合使用条件：  问题需要对一组连续数据元素（子数组子字符串）进行重复计算。窗口大小是固定的或者是变量（取决于问题的要求）。重复计算可以直接解决问题">
<meta property="og:type" content="article">
<meta property="og:title" content="滑动窗口">
<meta property="og:url" content="https://yuuuweng.github.io/2023/01/17/Grokking-coding-interviw-patterns/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/index.html">
<meta property="og:site_name" content="毛毛雨的博客">
<meta property="og:description" content="滑动窗口双指针变体，允许我们处理分段数据而不是整体list.（如需要找数组中三个连续整数的最大和window size可以设置成三）time complexity 从O(kn)降低到O(n) 什么样的情况下问题符合滑动窗口使用条件两种条件都满足的情况下符合使用条件：  问题需要对一组连续数据元素（子数组子字符串）进行重复计算。窗口大小是固定的或者是变量（取决于问题的要求）。重复计算可以直接解决问题">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.linkpicture.com/q/3f878fc75ad84405bffa29a309238655.jpg">
<meta property="article:published_time" content="2023-01-16T14:47:03.000Z">
<meta property="article:modified_time" content="2023-01-17T14:53:36.197Z">
<meta property="article:author" content="毛毛雨">
<meta property="article:tag" content="Coding Patterns">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.linkpicture.com/q/3f878fc75ad84405bffa29a309238655.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yuuuweng.github.io/2023/01/17/Grokking-coding-interviw-patterns/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '滑动窗口',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2023-01-17 22:53:36'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://www.linkpicture.com/q/3f878fc75ad84405bffa29a309238655.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">毛毛雨的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">滑动窗口</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-16T14:47:03.000Z" title="发表于 2023-01-16 22:47:03">2023-01-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-17T14:53:36.197Z" title="更新于 2023-01-17 22:53:36">2023-01-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Coding-Patterns/">Coding Patterns</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Coding-Patterns/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/">滑动窗口</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">2.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>13分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>双指针变体，允许我们处理分段数据而不是整体list.（如需要找数组中三个连续整数的最大和window size可以设置成三）<br>time complexity 从O(kn)降低到O(n)</p>
<h3 id="什么样的情况下问题符合滑动窗口使用条件"><a href="#什么样的情况下问题符合滑动窗口使用条件" class="headerlink" title="什么样的情况下问题符合滑动窗口使用条件"></a>什么样的情况下问题符合滑动窗口使用条件</h3><p><strong>两种条件都满足的情况下符合使用条件</strong>：</p>
<ol>
<li>问题需要对一组连续数据元素（子数组子字符串）进行重复计算。窗口大小是固定的或者是变量（取决于问题的要求）。重复计算可以直接解决问题或者是作为解决问题的中间步骤</li>
<li>每次窗口移动的时间消耗是O(1)或者缓慢增长函数，如log,或者小变量满足k &lt;&lt; n</li>
</ol>
<p><strong>两种条件满足其一就不符合</strong></p>
<ol>
<li>输入数据结构不支持随机访问</li>
<li>必须在不分段的情况下处理整个数据</li>
</ol>
<p><strong>实际应用场景</strong></p>
<p>Telecommunications: 在每个k-毫秒滑动数组中找到连接到网络基站的最大的用户数量<br>video streaming: 给予一个数字流代表着一个用户session的缓冲事件的数量。计算缓冲事件在每个一分钟间隔内的中位数。</p>
<hr>
<h2 id="Find-Maximum-in-Sliding-Window（滑动窗口最大值）"><a href="#Find-Maximum-in-Sliding-Window（滑动窗口最大值）" class="headerlink" title="Find Maximum in Sliding Window（滑动窗口最大值）"></a>Find Maximum in Sliding Window（滑动窗口最大值）</h2><p>Given an integer array and a window of size w, find the current maximum value in the window as it slides through the entire array.</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/">Leetcode链接</a></p>
<h3 id="朴素想法"><a href="#朴素想法" class="headerlink" title="朴素想法"></a>朴素想法</h3><ul>
<li>获取所有可能的window然后计算每个window的最大值。</li>
<li>对于array size n 和 window size w.一共有 n - w + 1个window.</li>
<li>遍历每个window需要花费O(w)取获取最大值<br><strong>所以总共的时间复杂度是O(n*w)</strong><br><strong>空间复杂度O(1)</strong></li>
</ul>
<h3 id="滑动窗口-1"><a href="#滑动窗口-1" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p><strong>利用单调队列</strong><br>deque来实现寻找window中的最大值是因为pop()和push()都是O(1)的。</p>
<ul>
<li>利用deque存储index,</li>
<li>遍历第一个window,同时每次遍历的元素和deque全部元素比较。保证deque头元素最大。</li>
<li>其他同样，但是要保证window size要在给定区间内(所以dq需要存index来记录区间范围)。</li>
</ul>
<p><strong>Time complexity</strong> O(n)<br><strong>Space complexity</strong> O(w) deque存数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_max_sliding_window</span>(<span class="params">nums, window_size</span>):</span><br><span class="line">    <span class="comment"># your code will replace this placeholder return statement</span></span><br><span class="line">    dq = deque()</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">if</span> window_size &gt;= <span class="built_in">len</span>(nums):</span><br><span class="line">        window_size = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(window_size):</span><br><span class="line">        <span class="keyword">while</span> dq <span class="keyword">and</span> nums[i] &gt;= nums[dq[-<span class="number">1</span>]]:</span><br><span class="line">            dq.pop()</span><br><span class="line">        dq.append(i)</span><br><span class="line">    result.append(nums[dq[<span class="number">0</span>]])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(window_size,<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">while</span> dq <span class="keyword">and</span> nums[i] &gt;= nums[dq[-<span class="number">1</span>]]:</span><br><span class="line">            dq.pop()</span><br><span class="line">        <span class="keyword">if</span> dq <span class="keyword">and</span> i - window_size &gt;= dq[<span class="number">0</span>]:</span><br><span class="line">            dq.popleft()</span><br><span class="line">        dq.append(i)</span><br><span class="line">        result.append(nums[dq[<span class="number">0</span>]])</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Minimum-Window-Subsequence"><a href="#Minimum-Window-Subsequence" class="headerlink" title="Minimum Window Subsequence"></a>Minimum Window Subsequence</h2><p>Given strings str1 and str2, find the minimum (contiguous) substring sub_str of str1, such that every character of str2 appears in sub_str in the same order as it is present in str2.</p>
<ul>
<li>If there is no window in str1 that covers all characters in str2, return an empty string.</li>
<li>If there are multiple minimum-length windows, return the one with the leftmost starting index.</li>
</ul>
<h3 id="朴素想法-1"><a href="#朴素想法-1" class="headerlink" title="朴素想法"></a>朴素想法</h3><p>三个for loop<br>time complexity O(n<sup>3</sup>)<br>space complexity O(1)</p>
<h3 id="滑动窗口-2"><a href="#滑动窗口-2" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>因为要找长度最小的substring.</p>
<p>向前滑动窗口:进行单个character匹配<br>向后滑动窗口：进行长度计算（利用start &#x3D; string1_index和end&#x3D;string1_index + 1）<br>不断向后滑动计算长度。</p>
<p><strong>Time complexity</strong> O(m*n)m是str2的长度。n是str1的长度<br><strong>Space complexity</strong> O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">min_window</span>(<span class="params">str1, str2</span>):</span><br><span class="line">    <span class="comment"># Save the size of str1 and str2</span></span><br><span class="line">    size_str1, size_str2 = <span class="built_in">len</span>(str1), <span class="built_in">len</span>(str2)</span><br><span class="line">    <span class="comment"># Initialize length to a very large number (infinity)</span></span><br><span class="line">    length = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    <span class="comment"># Initialize pointers to zero and the min_subsequence to an empty string</span></span><br><span class="line">    index_s1, index_s2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    min_subsequence = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Process every character of str1</span></span><br><span class="line">    <span class="keyword">while</span> index_s1 &lt; size_str1:</span><br><span class="line">        <span class="comment"># Check if the character pointed by index_s1 in str1</span></span><br><span class="line">        <span class="comment"># is the same as the character pointed by index_s2 in str2</span></span><br><span class="line">        <span class="keyword">if</span> str1[index_s1] == str2[index_s2]:</span><br><span class="line">            <span class="comment"># If the pointed character is the same</span></span><br><span class="line">            <span class="comment"># in both strings increment index_s2</span></span><br><span class="line">            index_s2 += <span class="number">1</span></span><br><span class="line">            <span class="comment"># Check if index_s2 has reached the end of str2</span></span><br><span class="line">            <span class="keyword">if</span> index_s2 == size_str2:</span><br><span class="line">                <span class="comment"># At this point the str1 contains all characters of str2</span></span><br><span class="line">                start, end = index_s1, index_s1+<span class="number">1</span></span><br><span class="line">                <span class="comment"># Initialize start to the index where all characters of</span></span><br><span class="line">                <span class="comment"># str2 were present in str1</span></span><br><span class="line">                index_s2 -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># Decrement pointer index_s2 and start a reverse loop</span></span><br><span class="line">                <span class="keyword">while</span> index_s2 &gt;= <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># Decrement pointer index_s2 until all characters of</span></span><br><span class="line">                    <span class="comment">#  str2 are found in str1</span></span><br><span class="line">                    <span class="keyword">if</span> str1[start] == str2[index_s2]:</span><br><span class="line">                        index_s2 -= <span class="number">1</span></span><br><span class="line">                    <span class="comment"># Decrement start pointer everytime to find the</span></span><br><span class="line">                    <span class="comment"># starting point of the required subsequence</span></span><br><span class="line">                    start -= <span class="number">1</span></span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">                <span class="comment"># Check if length of sub sequence pointed</span></span><br><span class="line">                <span class="comment"># by start and end pointers is less than current min length</span></span><br><span class="line">                <span class="keyword">if</span> end - start &lt; length:</span><br><span class="line">                    <span class="comment"># Update length if current sub sequence is shorter</span></span><br><span class="line">                    length = end - start</span><br><span class="line">                    <span class="comment"># Update minimum subsequence string</span></span><br><span class="line">                    <span class="comment"># to this new shorter string</span></span><br><span class="line">                    min_subsequence = str1[start:end]</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Set index_s1 to start to continue checking in str1</span></span><br><span class="line">                <span class="comment"># after this discovered subsequence</span></span><br><span class="line">                index_s1 = start</span><br><span class="line">                index_s2 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Increment pointer index_s1 to check next character in str1</span></span><br><span class="line">        index_s1 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> min_subsequence</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Driver code</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    str1 = [<span class="string">&quot;abcdebdde&quot;</span>, <span class="string">&quot;fgrqsqsnodwmxzkzxwqegkndaa&quot;</span>,</span><br><span class="line">            <span class="string">&quot;qwewerrty&quot;</span>, <span class="string">&quot;aaabbcbq&quot;</span>, <span class="string">&quot;zxcvnhss&quot;</span>, <span class="string">&quot;alpha&quot;</span>,</span><br><span class="line">            <span class="string">&quot;beta&quot;</span>, <span class="string">&quot;asd&quot;</span>, <span class="string">&quot;abcd&quot;</span>]</span><br><span class="line">    str2 = [<span class="string">&quot;bde&quot;</span>, <span class="string">&quot;kzed&quot;</span>, <span class="string">&quot;werty&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;css&quot;</span>, <span class="string">&quot;la&quot;</span>, <span class="string">&quot;ab&quot;</span>, <span class="string">&quot;as&quot;</span>, <span class="string">&quot;pp&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(str1)):</span><br><span class="line">        <span class="built_in">print</span>(i+<span class="number">1</span>, <span class="string">&quot;. \tInput string: (&quot;</span> + str1[i]+<span class="string">&quot;, &quot;</span> + str2[i]+<span class="string">&quot;)&quot;</span>, sep=<span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\tSubsequence string: &quot;</span>, min_window(str1[i], str2[i]))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#无注释版</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">min_window</span>(<span class="params">str1, str2</span>):</span><br><span class="line">    <span class="comment"># write your code here</span></span><br><span class="line">    s1 = <span class="number">0</span></span><br><span class="line">    s2 = <span class="number">0</span></span><br><span class="line">    min_length = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    min_str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> s1 &lt; <span class="built_in">len</span>(str1):</span><br><span class="line">        <span class="keyword">if</span> str1[s1] == str2[s2]:</span><br><span class="line">            s2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s2 == <span class="built_in">len</span>(str2):</span><br><span class="line">                start = s1</span><br><span class="line">                end = s1 + <span class="number">1</span></span><br><span class="line">                s2 -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> s2 &gt;= <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> str2[s2] == str1[start]:</span><br><span class="line">                        s2 -= <span class="number">1</span></span><br><span class="line">                    start -= <span class="number">1</span></span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> end - start &lt; min_length:</span><br><span class="line">                    min_length = end - start</span><br><span class="line">                    min_str = str1[start:end]</span><br><span class="line">                s1 = start</span><br><span class="line">                s2 = <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">        s1 += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> min_str</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Repeated-DNA-Sequences"><a href="#Repeated-DNA-Sequences" class="headerlink" title="Repeated DNA Sequences"></a>Repeated DNA Sequences</h2><p>Given a string s that represents a DNA sequence, and a number k, return all the contiguous sequences (substrings) of length k that occur more than once in the string. The order of the returned subsequences does not matter. If no repeated subsequence is found, the function should return an empty set.</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/repeated-dna-sequences/">Leetcode链接</a></p>
<h3 id="朴素想法-2"><a href="#朴素想法-2" class="headerlink" title="朴素想法"></a>朴素想法</h3><p>找到第一个长度为k的string,check rest O(n*k)<br>找其他长度为k的string,重复check.</p>
<p><strong>Time complexity</strong> O(n<em>k</em>n)<br><strong>Space complexity</strong> O(1)</p>
<p>另一个想法：哈希表计数加滑动窗口遇到重复的就加1，最后的组合是哈希数组里面大于1的substring.</p>
<h3 id="滑动窗口-滚动哈希计算"><a href="#滑动窗口-滚动哈希计算" class="headerlink" title="滑动窗口+滚动哈希计算"></a>滑动窗口+滚动哈希计算</h3><p><code>H = c1 * a^(k-1) + c2 * a^(k-2) + ...+ck * a^0</code><br>c1，c2是对应的四个字母的hash。a是固定值在这里面是4因为只有四个(A,C,G,T)<code>&#123;A:1,C:2,G:3,T:4&#125;</code></p>
<p>如<code>H(ACG)=H(A)+H(C)+H(G)=1×4^2+2×4^1+3×4^0</code><br>移动到下一位时计算方式是<br><code>H(CGT)=((H(ACG)−H(A))×4)+H(T) =(((1×4^2+2×4^1+3×4^0)−(1×4^2))×4)+4×4^0</code></p>
<ul>
<li>建立对应的mapping以后的数字数组</li>
<li>对于start等于0的时候遍历长度计算hashing.</li>
<li>对于不等于0的时候更新hashing.</li>
<li>如果发现hashing在建立的substring_hash里面出现过就放入到result里面</li>
</ul>
<p><strong>Time complexity</strong> O(n)<br><strong>Space complexity</strong> 额外存放hash的数组大小为O(n-k),转化以后成对应的hashing number的数组大小为O(n).所以total是O(2n-k)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_repeated_sequences</span>(<span class="params">s, k</span>):</span><br><span class="line">    window_size = k</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= window_size:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># parameters of rolling hash</span></span><br><span class="line">    base = <span class="number">4</span>        <span class="comment"># &#x27;a&#x27;, the hash parameter</span></span><br><span class="line">    hi_place_value = <span class="built_in">pow</span>(base, window_size) <span class="comment"># a^k, the highest place value</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># mapping of a character into an integer</span></span><br><span class="line">    mapping = &#123;<span class="string">&#x27;A&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;G&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;T&#x27;</span>: <span class="number">4</span>&#125;</span><br><span class="line">    numbers = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        numbers.append(mapping.get(s[i]))</span><br><span class="line"></span><br><span class="line">    hashing = <span class="number">0</span></span><br><span class="line">    substring_hashes, output = <span class="built_in">set</span>(), <span class="built_in">set</span>()</span><br><span class="line">    <span class="comment"># iterate over all window-sized substrings</span></span><br><span class="line">    <span class="keyword">for</span> start <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s) - window_size + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># hash function of current subsequence</span></span><br><span class="line">        <span class="keyword">if</span> start != <span class="number">0</span>:</span><br><span class="line">            hashing = hashing * base - \</span><br><span class="line">                numbers[start - <span class="number">1</span>] * hi_place_value + \</span><br><span class="line">                numbers[start + window_size - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(window_size):</span><br><span class="line">                hashing = hashing * base + numbers[end]</span><br><span class="line">        <span class="comment"># subsequence and output sets</span></span><br><span class="line">        <span class="keyword">if</span> hashing <span class="keyword">in</span> substring_hashes:</span><br><span class="line">            output.add(s[start:start + window_size])</span><br><span class="line">        substring_hashes.add(hashing)</span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    inputs_string = [<span class="string">&quot;ACGT&quot;</span>, <span class="string">&quot;AGACCTAGAC&quot;</span>, <span class="string">&quot;AAAAACCCCCAAAAACCCCCC&quot;</span>, <span class="string">&quot;GGGGGGGGGGGGGGGGGGGGGGGGG&quot;</span>,</span><br><span class="line">                     <span class="string">&quot;TTTTTCCCCCCCTTTTTTCCCCCCCTTTTTTT&quot;</span>, <span class="string">&quot;TTTTTGGGTTTTCCA&quot;</span>,</span><br><span class="line">                     <span class="string">&quot;AAAAAACCCCCCCAAAAAAAACCCCCCCTG&quot;</span>, <span class="string">&quot;ATATATATATATATAT&quot;</span>]</span><br><span class="line">    inputs_k = [<span class="number">3</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">10</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(inputs_k)):</span><br><span class="line">        <span class="built_in">print</span>(i+<span class="number">1</span>, <span class="string">&quot;.\tInput Sequence: \&#x27;&quot;</span>, inputs_string[i], <span class="string">&quot;\&#x27;&quot;</span>, sep=<span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\tk: &quot;</span>, inputs_k[i], sep=<span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\tRepeated Subsequence: &quot;</span>,</span><br><span class="line">              find_repeated_sequences(inputs_string[i], inputs_k[i]))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_repeated_sequences</span>(<span class="params">s, k</span>):</span><br><span class="line">    base = <span class="number">4</span></span><br><span class="line">    highest_pow = <span class="built_in">pow</span>(base,k)</span><br><span class="line">    dict_list = []</span><br><span class="line">    mapping = &#123;<span class="string">&#x27;A&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;C&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;G&#x27;</span>:<span class="number">3</span>,<span class="string">&#x27;T&#x27;</span>:<span class="number">4</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">        dict_list.append(mapping.get(i))</span><br><span class="line">    substring_hash = <span class="built_in">set</span>()</span><br><span class="line">    output = <span class="built_in">set</span>()</span><br><span class="line">    hashing = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> start <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s) - k + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> start != <span class="number">0</span>:</span><br><span class="line">            hashing = hashing * base</span><br><span class="line">            hashing -= dict_list[start-<span class="number">1</span>] * highest_pow</span><br><span class="line">            hashing += dict_list[start-<span class="number">1</span> + k]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">                hashing = hashing * base + dict_list[end]</span><br><span class="line">        <span class="keyword">if</span> hashing <span class="keyword">in</span> substring_hash:</span><br><span class="line">            output.add(s[start:start + k])</span><br><span class="line">        substring_hash.add(hashing)</span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Minimum-Window-Substring"><a href="#Minimum-Window-Substring" class="headerlink" title="Minimum Window Substring"></a>Minimum Window Substring</h2><p>Given two strings—s and t, find the smallest window substring of t. The smallest window substring is the shortest sequence of characters in s that includes all of the characters present in t. The frequency of each character in this sequence should be greater than or equal to the frequency of each character in t. The order of the characters doesn’t matter here.</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-window-substring/">Leetcode链接</a></p>
<h3 id="朴素想法-3"><a href="#朴素想法-3" class="headerlink" title="朴素想法"></a>朴素想法</h3><p>对于 CC in ABCDEFC.<br>从A开始遍历，遍历到第二个C记录然后从B继续遍历。<br>时间复杂度：O(n<sup>2</sup>)</p>
<h3 id="滑动数组"><a href="#滑动数组" class="headerlink" title="滑动数组"></a>滑动数组</h3><ul>
<li>两个字典一个记录substring,一个记录滑动窗口里字母出现的次数</li>
<li>两个变量，一个变量是记录substring字典的长度，一个是记录当前window里面的字母在substring里出现的次数</li>
<li>两个额外变量 result &#x3D; [left,right] res_length记录长度</li>
</ul>
<p>滑动right指针添加元素，滑动left指针缩小元素</p>
<p><strong>Time complexity</strong> O(n + m)遍历一次substring一次string<br><strong>Space complexity</strong> O(n+m)两个对应的hashmap</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">min_window</span>(<span class="params">s, t</span>):</span><br><span class="line">    <span class="comment"># Empty string scenario</span></span><br><span class="line">    <span class="keyword">if</span> t == <span class="string">&quot;&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Creating the two hash maps</span></span><br><span class="line">    r_count = &#123;&#125;</span><br><span class="line">    window = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Populating r_count hash map</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> t:</span><br><span class="line">        r_count[c] = <span class="number">1</span> + r_count.get(c, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Setting up the conditional variables</span></span><br><span class="line">    current, required = <span class="number">0</span>, <span class="built_in">len</span>(r_count)</span><br><span class="line">    <span class="comment"># Setting up a variable containing the result&#x27;s starting and ending point</span></span><br><span class="line">    <span class="comment"># with default values and a length variable</span></span><br><span class="line">    res, res_len = [-<span class="number">1</span>, -<span class="number">1</span>], <span class="built_in">float</span>(<span class="string">&quot;infinity&quot;</span>)</span><br><span class="line">    <span class="comment"># Setting up the sliding window pointers</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        c = s[right]</span><br><span class="line">        window[c] = <span class="number">1</span> + window.get(c, <span class="number">0</span>)  <span class="comment"># Populating the window hash map</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Updating the current variable</span></span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> r_count <span class="keyword">and</span> window[c] == r_count[c]:</span><br><span class="line">            current += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> current == required:  <span class="comment"># Adjusting the sliding window</span></span><br><span class="line">            <span class="comment"># update our result</span></span><br><span class="line">            <span class="keyword">if</span> (right - left + <span class="number">1</span>) &lt; res_len:</span><br><span class="line">                res = [left, right]</span><br><span class="line">                res_len = (right - left + <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># pop from the left of our window</span></span><br><span class="line">            window[s[left]] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s[left] <span class="keyword">in</span> r_count <span class="keyword">and</span> window[s[left]] &lt; r_count[s[left]]:</span><br><span class="line">                current -= <span class="number">1</span>  <span class="comment"># if the popped character was among the required characters and removing it has reduced its frequency below its frequency in t, decrement current</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">    left, right = res</span><br><span class="line">    <span class="keyword">return</span> s[left:right+<span class="number">1</span>] <span class="keyword">if</span> res_len != <span class="built_in">float</span>(<span class="string">&quot;infinity&quot;</span>) <span class="keyword">else</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Driver Code</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line"></span><br><span class="line">    s = [<span class="string">&quot;PATTERN&quot;</span>, <span class="string">&quot;LIFE&quot;</span>, <span class="string">&quot;ABRACADABRA&quot;</span>, <span class="string">&quot;STRIKER&quot;</span>, <span class="string">&quot;DFFDFDFVD&quot;</span>]</span><br><span class="line">    t = [<span class="string">&quot;TN&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;ABC&quot;</span>, <span class="string">&quot;RK&quot;</span>, <span class="string">&quot;VDD&quot;</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="built_in">print</span>(i + <span class="number">1</span>, <span class="string">&quot;.\ts: &quot;</span>, s[i], <span class="string">&quot;\n\tt: &quot;</span>, t[i], <span class="string">&quot;\n\tThe minimum substring containing &quot;</span>, \</span><br><span class="line">              t[i], <span class="string">&quot; is: &quot;</span>, min_window(s[i], t[i]), sep=<span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">98</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#无注释版</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">min_window</span>(<span class="params">s, t</span>):</span><br><span class="line">    <span class="keyword">if</span> t == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    t_count = &#123;&#125;</span><br><span class="line">    window = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> t:</span><br><span class="line">        t_count[i] = t_count.get(i,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    valid = <span class="built_in">len</span>(t_count)</span><br><span class="line">    cur = <span class="number">0</span></span><br><span class="line">    result = [-<span class="number">1</span>,-<span class="number">1</span>]</span><br><span class="line">    res_length = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        window[s[right]] = window.get(s[right],<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> s[right] <span class="keyword">in</span> t_count <span class="keyword">and</span> window[s[right]] == t_count[s[right]]:</span><br><span class="line">            cur += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> cur == valid:</span><br><span class="line">            <span class="comment">#update result</span></span><br><span class="line">            <span class="keyword">if</span> right - left + <span class="number">1</span> &lt; res_length:</span><br><span class="line">                res_length = right - left + <span class="number">1</span></span><br><span class="line">                result = [left,right]</span><br><span class="line">            <span class="comment"># pop left</span></span><br><span class="line">            window[s[left]] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s[left] <span class="keyword">in</span> t_count <span class="keyword">and</span> window[s[left]] &lt; t_count[s[left]]:</span><br><span class="line">                cur -= <span class="number">1</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">    left, right = result</span><br><span class="line">    <span class="keyword">return</span> s[left:right+<span class="number">1</span>] <span class="keyword">if</span> res_length != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Longest-Substring-without-Repeating-Characters"><a href="#Longest-Substring-without-Repeating-Characters" class="headerlink" title="Longest Substring without Repeating Characters"></a>Longest Substring without Repeating Characters</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">Leetcode链接</a></p>
<h3 id="朴素想法-4"><a href="#朴素想法-4" class="headerlink" title="朴素想法"></a>朴素想法</h3><p>获取所有可能的substring的复杂度是O(n<sup>2</sup>)对于每个substring检测是否unique是</p>
<h3 id="滑动数组-1"><a href="#滑动数组-1" class="headerlink" title="滑动数组"></a>滑动数组</h3><p>用set记录遍历的字符，如果出现重复，移动左指针缩小窗口<br>用r-l+1记录最长的substring<br><strong>Time complexity</strong> O(n）<br><strong>Space complexity</strong> O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_longest_substring</span>(<span class="params">input_string</span>):</span><br><span class="line">   l = <span class="number">0</span></span><br><span class="line">   set_ = <span class="built_in">set</span>()</span><br><span class="line">   res = <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(input_string)):</span><br><span class="line">      <span class="keyword">while</span> input_string[i] <span class="keyword">in</span> set_:</span><br><span class="line">         set_.remove(input_string[l])</span><br><span class="line">         l += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">      set_.add(input_string[i])</span><br><span class="line">      res = <span class="built_in">max</span>(i - l+<span class="number">1</span>,res)</span><br><span class="line">   <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://yuuuweng.github.io">毛毛雨</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yuuuweng.github.io/2023/01/17/Grokking-coding-interviw-patterns/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/">https://yuuuweng.github.io/2023/01/17/Grokking-coding-interviw-patterns/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yuuuweng.github.io" target="_blank">毛毛雨的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Coding-Patterns/">Coding Patterns</a></div><div class="post_share"><div class="social-share" data-image="https://www.linkpicture.com/q/3f878fc75ad84405bffa29a309238655.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/01/15/Grokking-coding-interviw-patterns/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"><img class="next-cover" src="https://www.linkpicture.com/q/3f878fc75ad84405bffa29a309238655.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">快慢指针</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/01/15/Grokking-coding-interviw-patterns/%E5%8F%8C%E6%8C%87%E9%92%88/" title="双指针"><img class="cover" src="https://www.linkpicture.com/q/3f878fc75ad84405bffa29a309238655.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-14</div><div class="title">双指针</div></div></a></div><div><a href="/2023/01/15/Grokking-coding-interviw-patterns/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/" title="快慢指针"><img class="cover" src="https://www.linkpicture.com/q/3f878fc75ad84405bffa29a309238655.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-15</div><div class="title">快慢指针</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">毛毛雨</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/YuuuWeng/"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/YuuuWeng" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2363512498@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">1.</span> <span class="toc-text">滑动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E9%97%AE%E9%A2%98%E7%AC%A6%E5%90%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.1.</span> <span class="toc-text">什么样的情况下问题符合滑动窗口使用条件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Find-Maximum-in-Sliding-Window%EF%BC%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">Find Maximum in Sliding Window（滑动窗口最大值）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%B4%E7%B4%A0%E6%83%B3%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">朴素想法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-1"><span class="toc-number">2.2.</span> <span class="toc-text">滑动窗口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Minimum-Window-Subsequence"><span class="toc-number">3.</span> <span class="toc-text">Minimum Window Subsequence</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%B4%E7%B4%A0%E6%83%B3%E6%B3%95-1"><span class="toc-number">3.1.</span> <span class="toc-text">朴素想法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-2"><span class="toc-number">3.2.</span> <span class="toc-text">滑动窗口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Repeated-DNA-Sequences"><span class="toc-number">4.</span> <span class="toc-text">Repeated DNA Sequences</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%B4%E7%B4%A0%E6%83%B3%E6%B3%95-2"><span class="toc-number">4.1.</span> <span class="toc-text">朴素想法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%E6%BB%9A%E5%8A%A8%E5%93%88%E5%B8%8C%E8%AE%A1%E7%AE%97"><span class="toc-number">4.2.</span> <span class="toc-text">滑动窗口+滚动哈希计算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Minimum-Window-Substring"><span class="toc-number">5.</span> <span class="toc-text">Minimum Window Substring</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%B4%E7%B4%A0%E6%83%B3%E6%B3%95-3"><span class="toc-number">5.1.</span> <span class="toc-text">朴素想法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E6%95%B0%E7%BB%84"><span class="toc-number">5.2.</span> <span class="toc-text">滑动数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Longest-Substring-without-Repeating-Characters"><span class="toc-number">6.</span> <span class="toc-text">Longest Substring without Repeating Characters</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%B4%E7%B4%A0%E6%83%B3%E6%B3%95-4"><span class="toc-number">6.1.</span> <span class="toc-text">朴素想法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E6%95%B0%E7%BB%84-1"><span class="toc-number">6.2.</span> <span class="toc-text">滑动数组</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/01/17/Grokking-coding-interviw-patterns/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" title="滑动窗口"><img src="https://www.linkpicture.com/q/3f878fc75ad84405bffa29a309238655.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="滑动窗口"/></a><div class="content"><a class="title" href="/2023/01/17/Grokking-coding-interviw-patterns/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" title="滑动窗口">滑动窗口</a><time datetime="2023-01-16T14:47:03.000Z" title="发表于 2023-01-16 22:47:03">2023-01-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/15/Grokking-coding-interviw-patterns/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/" title="快慢指针"><img src="https://www.linkpicture.com/q/3f878fc75ad84405bffa29a309238655.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="快慢指针"/></a><div class="content"><a class="title" href="/2023/01/15/Grokking-coding-interviw-patterns/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/" title="快慢指针">快慢指针</a><time datetime="2023-01-14T19:17:53.000Z" title="发表于 2023-01-15 03:17:53">2023-01-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/15/Grokking-coding-interviw-patterns/%E5%8F%8C%E6%8C%87%E9%92%88/" title="双指针"><img src="https://www.linkpicture.com/q/3f878fc75ad84405bffa29a309238655.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="双指针"/></a><div class="content"><a class="title" href="/2023/01/15/Grokking-coding-interviw-patterns/%E5%8F%8C%E6%8C%87%E9%92%88/" title="双指针">双指针</a><time datetime="2023-01-14T13:05:41.000Z" title="发表于 2023-01-14 21:05:41">2023-01-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/13/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E8%B4%AA%E5%BF%83%E4%B8%93%E9%A2%983/" title="贪心专题3"><img src="https://www.linkpicture.com/q/3f878fc75ad84405bffa29a309238655.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="贪心专题3"/></a><div class="content"><a class="title" href="/2023/01/13/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E8%B4%AA%E5%BF%83%E4%B8%93%E9%A2%983/" title="贪心专题3">贪心专题3</a><time datetime="2023-01-13T02:24:47.000Z" title="发表于 2023-01-13 10:24:47">2023-01-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/12/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E8%B4%AA%E5%BF%83%E4%B8%93%E9%A2%982/" title="贪心专题2"><img src="https://www.linkpicture.com/q/3f878fc75ad84405bffa29a309238655.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="贪心专题2"/></a><div class="content"><a class="title" href="/2023/01/12/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E8%B4%AA%E5%BF%83%E4%B8%93%E9%A2%982/" title="贪心专题2">贪心专题2</a><time datetime="2023-01-11T13:52:36.000Z" title="发表于 2023-01-11 21:52:36">2023-01-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By 毛毛雨</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div></div></body></html>