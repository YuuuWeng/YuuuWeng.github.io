<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>回溯专题4</title>
      <link href="/2023/01/08/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%9B%9E%E6%BA%AF%E4%B8%93%E9%A2%984/"/>
      <url>/2023/01/08/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%9B%9E%E6%BA%AF%E4%B8%93%E9%A2%984/</url>
      
        <content type="html"><![CDATA[<h2 id="93-复原-IP-地址"><a href="#93-复原-IP-地址" class="headerlink" title="93. 复原 IP 地址"></a>93. 复原 IP 地址</h2><p><a href="https://leetcode.cn/problems/restore-ip-addresses/">leetcode链接</a></p><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p><strong>对于分割问题最好写一个helper函数，来判断分割的部分字符串（最好传入字符串和对应的左右边界。右开或者闭。本题是闭）是否是合法的（这个时候需要思考好i和startindex的区别）对于闭区间字符串一定是[startindex,i].因为同层遍历的时候startindex是不变的i在变。</strong></p><ul><li>回溯函数传入变量和返回值：number of points用来记录已经往字符串里面加了几个节点了。startindex用来记录字符串从哪里开始遍历。</li><li>回溯终止条件：当记录的point数量到达三个时终止。同时要判断当前的startindex到字符串末尾是否为合法字符串</li><li>单层搜索逻辑：获取子字符串<code>[startindex,i]</code>闭区间.如果合法的话在当前i的位置加上。然后对于记录的point number 加1</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">restoreIpAddresses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        ret = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">s,startindex,point</span>):</span><br><span class="line">            <span class="keyword">if</span> point == <span class="number">3</span>:</span><br><span class="line">                <span class="comment">#判断第四块字符串是否合法</span></span><br><span class="line">                <span class="keyword">if</span> self.isValid(s,startindex,<span class="built_in">len</span>(s) - <span class="number">1</span>):</span><br><span class="line">                    ret.append(s)</span><br><span class="line">                <span class="comment">#startindex 代表遍历分割线</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startindex,<span class="built_in">len</span>(s)):</span><br><span class="line">                <span class="comment"># startindex 到 i</span></span><br><span class="line">                <span class="keyword">if</span> self.isValid(s,startindex,i):</span><br><span class="line">                    <span class="comment"># i一直控制的是子问题</span></span><br><span class="line">                    <span class="comment"># python左开右闭必须i+1</span></span><br><span class="line">                    s = s[:i+<span class="number">1</span>] + <span class="string">&#x27;.&#x27;</span> + s[i+<span class="number">1</span>:]</span><br><span class="line">                    point += <span class="number">1</span></span><br><span class="line">                    <span class="comment">#加完以后跳过点，要i+2</span></span><br><span class="line">                    backtracking(s,i + <span class="number">2</span>,point)</span><br><span class="line">                    point -= <span class="number">1</span></span><br><span class="line">                    s = s[:i+<span class="number">1</span>] + s[i+<span class="number">2</span>:]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        backtracking(s,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self,s,start,end</span>):</span><br><span class="line">        <span class="comment"># 段位有0开头</span></span><br><span class="line">        <span class="comment"># 有非正整数字符</span></span><br><span class="line">        <span class="comment"># 段位大于255</span></span><br><span class="line">        <span class="keyword">if</span> start &gt; end:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> s[start] == <span class="string">&#x27;0&#x27;</span> <span class="keyword">and</span> start != end:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start,end + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 字符串可以比较大小</span></span><br><span class="line">            <span class="keyword">if</span> s[i] &gt; <span class="string">&#x27;9&#x27;</span> <span class="keyword">or</span> s[i] &lt;<span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># python字符串不能直接减</span></span><br><span class="line">            <span class="comment"># num = num * 10 + s[start] - &#x27;0&#x27;</span></span><br><span class="line">            num = num * <span class="number">10</span> + <span class="built_in">ord</span>(s[i]) - <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> num &gt; <span class="number">255</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;1111&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a>78. 子集</h2><p><a href="https://leetcode.cn/problems/subsets/">Leetcode链接</a></p><h3 id="回溯-1"><a href="#回溯-1" class="headerlink" title="回溯"></a>回溯</h3><p><strong>无序，且取过的元素不会重复取，for就要从startIndex开始，而不是从0开始！</strong></p><ul><li>递归函数参数：path(sublist)收集元素，startindex(因为不会重复取)</li><li>递归终止条件：可以加可以不加。当<code>startindex &gt; len(nums)</code>直接终止。for循环也会自动终止</li><li>单层逻辑，加入结点,递归子问题，pop结点</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        ret = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">startindex,sublist</span>):</span><br><span class="line">            ret.append(sublist[:])</span><br><span class="line">            <span class="comment"># 判断条件可以不加，因为会自动return</span></span><br><span class="line">            <span class="keyword">if</span> startindex &gt; <span class="built_in">len</span>(nums):</span><br><span class="line">                <span class="keyword">return</span>   </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startindex,<span class="built_in">len</span>(nums)):</span><br><span class="line">                sublist.append(nums[i])</span><br><span class="line">                backtracking(i+<span class="number">1</span>,sublist)</span><br><span class="line">                sublist.pop()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        backtracking(<span class="number">0</span>,[])</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a>90. 子集 II</h2><p>(Leeetcode链接)[<a href="https://leetcode.cn/problems/subsets-ii/]">https://leetcode.cn/problems/subsets-ii/]</a></p><p><strong>区别是数组里有重复元素但是还要求解集不能有重复组合</strong></p><p><strong>提供的数组中有重复元素首先需要对提供的数组sort</strong></p><h3 id="回溯-2"><a href="#回溯-2" class="headerlink" title="回溯"></a>回溯</h3><ul><li>递归函数参数:startindex因为元素无法重复使用，path用来添加路径</li><li>终止条件(对于深度来说)：startindex 大于等于len(nums)可以不写因为for loop也会终止</li><li>单层逻辑：重点在于对树层去重。<code>if i &gt; startindex and nums[i] == nums[i - 1]</code>保证对同层去重。比如122.对于同层i遍历到第二个2的时候直接continue</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsetsWithDup</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        ret = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">path,startindex</span>):</span><br><span class="line">            ret.append(path[:])</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startindex,<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="comment"># 树层去重</span></span><br><span class="line">                <span class="comment">#必须 i &gt; startindex</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; startindex <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                backtracking(path,i + <span class="number">1</span>)</span><br><span class="line">                path.pop()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        backtracking([],<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
          <category> 回溯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯专题3</title>
      <link href="/2023/01/07/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%9B%9E%E6%BA%AF%E4%B8%93%E9%A2%983/"/>
      <url>/2023/01/07/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%9B%9E%E6%BA%AF%E4%B8%93%E9%A2%983/</url>
      
        <content type="html"><![CDATA[<h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h2><p><a href="https://leetcode.cn/problems/combination-sum/">Leetcode链接</a></p><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><ul><li>这题是可以全部重复选取的所以需要思考子问题的for循环。对于同一个沿着枝杈的遍历无序需缩小子问题。</li><li>但是对于同层遍历需要缩小子问题</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum</span>(<span class="params">self, candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">pos,sublist,sum_</span>):</span><br><span class="line">            <span class="keyword">if</span> sum_ == <span class="number">0</span>:</span><br><span class="line">                result.append(sublist[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment">#达到剪枝效果</span></span><br><span class="line">            <span class="keyword">if</span> sum_ &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment">#同层缩小子问题</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pos,<span class="built_in">len</span>(candidates)):</span><br><span class="line">                sum_ -= candidates[i]</span><br><span class="line">                sublist.append(candidates[i])</span><br><span class="line">                <span class="comment">#无需缩小子问题</span></span><br><span class="line">                backtracking(i,sublist,sum_)</span><br><span class="line">                sum_ += candidates[i]</span><br><span class="line">                sublist.pop()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        backtracking(<span class="number">0</span>,[],target)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="40-组合总和II"><a href="#40-组合总和II" class="headerlink" title="40.组合总和II"></a>40.组合总和II</h2><p><a href="https://leetcode.cn/problems/combination-sum-ii/">Leetcode链接</a></p><p><strong>区别是数组里有重复元素但是还要求解集不能有重复组合</strong></p><h3 id="回溯-1"><a href="#回溯-1" class="headerlink" title="回溯"></a>回溯</h3><ul><li>需要保证同层去重。对树杈不需要去重。</li><li>同层去重可以用if条件判断前一个元素和这个元素是否相同。坑：必须要保证i &gt; 当前pos.</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum2</span>(<span class="params">self, candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">sum_,pos,sublist</span>):</span><br><span class="line">            <span class="keyword">if</span> sum_ == target:</span><br><span class="line">                result.append(sublist[:])</span><br><span class="line">            <span class="keyword">if</span> sum_ &gt; target:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pos,<span class="built_in">len</span>(candidates)):</span><br><span class="line">                <span class="comment">#这样子写可以保证同层去重</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; pos <span class="keyword">and</span> candidates[i] == candidates[i - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment">#不能这么写，这样子写的话会对同一枝杈去重。</span></span><br><span class="line">                <span class="comment"># if i &lt; len(candidates)-1 and candidates[i] == candidates[i + 1]:</span></span><br><span class="line">                <span class="comment">#     continue</span></span><br><span class="line">                sum_ += candidates[i]</span><br><span class="line">                sublist.append(candidates[i])</span><br><span class="line">                backtracking(sum_,i+<span class="number">1</span>,sublist)</span><br><span class="line">                sum_ -= candidates[i]</span><br><span class="line">                sublist.pop()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        backtracking(<span class="number">0</span>,<span class="number">0</span>,[])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a>131. 分割回文串</h2><p><a href="https://leetcode.cn/problems/palindrome-partitioning/">Leetcode链接</a></p><h3 id="回溯-2"><a href="#回溯-2" class="headerlink" title="回溯"></a>回溯</h3><ul><li>很难的一道题</li><li>终止条件：当pos向下递归的指针等于s的长度的时候就添加数组到result集合里</li><li>回溯函数参数：最重要的就是pos记录当前遍历的字符串位置（深度遍历向下搜索。i + 1而不是pos+1）</li><li>单层逻辑：判断是不是回文串，如果是进行回溯。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span><br><span class="line">        <span class="comment">#回文串判断</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">palindrome</span>(<span class="params">s,left,right</span>):</span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                <span class="keyword">if</span> s[left] != s[right]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">pos,sublist</span>):</span><br><span class="line">            <span class="keyword">if</span> pos == <span class="built_in">len</span>(s):</span><br><span class="line">                result.append(sublist[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pos,<span class="built_in">len</span>(s)):</span><br><span class="line">                <span class="comment">#左边是pos右边是i</span></span><br><span class="line">                <span class="keyword">if</span> palindrome(s,pos,i):</span><br><span class="line">                    <span class="comment">#重点：理解回溯以后i会向后遍历变成i+1。但是pos还是处于当前i的位置。所以一定是pos到i+1</span></span><br><span class="line">                    char = s[pos:i+<span class="number">1</span>]</span><br><span class="line">                    sublist.append(char)</span><br><span class="line">                    <span class="comment">#向下遍历，不能是pos加1因为到第二个树枝的时候i要向后移动。形成&#x27;aa&#x27;而不是第一个树枝的&#x27;a&#x27;</span></span><br><span class="line">                    backtracking(i + <span class="number">1</span>,sublist)</span><br><span class="line">                    sublist.pop()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        backtracking(<span class="number">0</span>,[])</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
          <category> 回溯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯专题2</title>
      <link href="/2023/01/06/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%9B%9E%E6%BA%AF%E4%B8%93%E9%A2%982/"/>
      <url>/2023/01/06/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%9B%9E%E6%BA%AF%E4%B8%93%E9%A2%982/</url>
      
        <content type="html"><![CDATA[<h2 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a>216. 组合总和 III</h2><p><a href="https://leetcode.cn/problems/combination-sum-iii/">Leetcode链接</a></p><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><ul><li>和前面的组合一样。只是终止条件苛刻了一些。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum3</span>(<span class="params">self, k: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        ret = []</span><br><span class="line">        sublist = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">pos</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(sublist) == k <span class="keyword">and</span> <span class="built_in">sum</span>(sublist) == n:</span><br><span class="line">                ret.append(sublist[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(sublist) &gt; k <span class="keyword">or</span> <span class="built_in">sum</span>(sublist) &gt; n:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pos,<span class="number">10</span>):</span><br><span class="line">                sublist.append(i)</span><br><span class="line">                backtracking(i + <span class="number">1</span>)</span><br><span class="line">                sublist.pop()</span><br><span class="line">        backtracking(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum3</span>(<span class="params">self, k: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        ret = []</span><br><span class="line">        sublist = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">pos,sum_</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(sublist) == k <span class="keyword">and</span> sum_ == n:</span><br><span class="line">                ret.append(sublist[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment">#这里可以不加这个条件因为for循环已经保证了不会一致递归下去。(这个是减枝操作如果长度大于k或者总和大于n就没必要继续递归下去)</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(sublist) &gt; k <span class="keyword">or</span> sum_ &gt; n:</span><br><span class="line">            <span class="comment">#     return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pos,<span class="number">10</span>):</span><br><span class="line">                sublist.append(i)</span><br><span class="line">                sum_ += i</span><br><span class="line">                backtracking(i + <span class="number">1</span>,sum_)</span><br><span class="line">                sublist.pop()</span><br><span class="line">                sum_ -= i</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        backtracking(<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><h2 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a>17. 电话号码的字母组合</h2><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">Leetcode链接</a></p><h3 id="回溯-1"><a href="#回溯-1" class="headerlink" title="回溯"></a>回溯</h3><ul><li>重点在于for循环的运用。如果有两个数的时候。第一层for循环就是遍历第一个数对应的string。第二层for循环就是在遍历第二个数对应的string.</li><li>另外得用list不能用string去做回溯</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">letterCombinations</span>(<span class="params">self, digits: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        dict_ = &#123;<span class="string">&#x27;2&#x27;</span>:<span class="string">&quot;abc&quot;</span>,<span class="string">&#x27;3&#x27;</span>:<span class="string">&quot;def&quot;</span>,<span class="string">&#x27;4&#x27;</span>:<span class="string">&quot;ghi&quot;</span>,<span class="string">&#x27;5&#x27;</span>:<span class="string">&quot;jkl&quot;</span>,<span class="string">&#x27;6&#x27;</span>:<span class="string">&quot;mno&quot;</span>,<span class="string">&#x27;7&#x27;</span>:<span class="string">&quot;pqrs&quot;</span>,<span class="string">&#x27;8&#x27;</span>:<span class="string">&quot;tuv&quot;</span>,<span class="string">&#x27;9&#x27;</span>:<span class="string">&quot;wxyz&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">        length = <span class="built_in">len</span>(digits)</span><br><span class="line">        ret = []</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(digits) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># pos用来记录遍历的digits.子问题就是对pos值加一。</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">pos,substring</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(substring) == length:</span><br><span class="line">                ret.append(<span class="string">&#x27;&#x27;</span>.join(substring))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            digit = digits[pos]</span><br><span class="line">            <span class="keyword">for</span> letter <span class="keyword">in</span> dict_[digit]:</span><br><span class="line">                substring.append(letter)</span><br><span class="line">                backtracking(pos + <span class="number">1</span>,substring)</span><br><span class="line">                substring.pop()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        backtracking(<span class="number">0</span>,[])</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
          <category> 回溯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯</title>
      <link href="/2023/01/05/%E5%9B%9E%E6%BA%AF/%E5%9B%9E%E6%BA%AF2/"/>
      <url>/2023/01/05/%E5%9B%9E%E6%BA%AF/%E5%9B%9E%E6%BA%AF2/</url>
      
        <content type="html"><![CDATA[<h2 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a>90. 子集 II</h2><p><a href="https://leetcode.cn/problems/subsets-ii/">Leetcode链接</a><br>给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums = [1,2,2]</span><br><span class="line">输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums = [0]</span><br><span class="line">输出：[[],[0]]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;= nums.length &lt;= 10</span><br><span class="line">-10 &lt;= nums[i] &lt;= 10</span><br></pre></td></tr></table></figure><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>和原来子集区别在于，他包含了重复的元素。<strong>要去重就需要先排序</strong></p><ul><li>终止条件：i的长度大于等于提供的数组长度</li><li>函数参数和返回值：无返回值，参数是i指针记录深度，sublist记录子集</li><li>单层搜索逻辑：对于左半边，遇到一个就append一个然后向下搜索，回溯pop出结点，对于右半边，需要在排序好的数组中比较数组元素是否相同，如果相同就一直让index动直到不一样。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsetsWithDup</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i,sublist</span>):</span><br><span class="line">            <span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(nums):</span><br><span class="line">                result.append(sublist[:])</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            sublist.append(nums[i])</span><br><span class="line">            dfs(i+<span class="number">1</span>,sublist)</span><br><span class="line">            sublist.pop()</span><br><span class="line">            <span class="comment">#跳过重复元素</span></span><br><span class="line">            <span class="keyword">while</span> i + <span class="number">1</span> &lt; <span class="built_in">len</span>(nums) <span class="keyword">and</span> nums[i] == nums[i + <span class="number">1</span>]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            dfs(i+<span class="number">1</span>,sublist)</span><br><span class="line">        dfs(<span class="number">0</span>,[])</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">            </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 回溯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯</title>
      <link href="/2023/01/05/%E5%9B%9E%E6%BA%AF/%E5%9B%9E%E6%BA%AF1/"/>
      <url>/2023/01/05/%E5%9B%9E%E6%BA%AF/%E5%9B%9E%E6%BA%AF1/</url>
      
        <content type="html"><![CDATA[<h2 id="78-子集-subsets"><a href="#78-子集-subsets" class="headerlink" title="78. 子集(subsets)"></a>78. 子集(subsets)</h2><p><a href="https://leetcode.cn/problems/subsets/">Leetcode链接</a><br>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure><h3 id="回溯思路"><a href="#回溯思路" class="headerlink" title="回溯思路"></a>回溯思路</h3><p><strong>时间复杂度分析</strong>：首先对于长度为n的数组，每一个数都有两种可能性，所以是2^n种可能性。对于每一个subset可能会到长度为n。所以最差的时间复杂度是<br>O(n*2^n).<br>-对于决策树的构建从给予的数组头部元素开始，有两种选择，<br>    1. 加进去还是不加，对于已经加进去的节点还有两种可能对于第二个元素有加和不加两种选择。<br>    2. 对于不加的节点也有两种可能性加第二个元素还是不加。<br>这样子就可以构建出树了</p><ul><li>回溯终止条件：<strong>用i指针记录</strong>，当遍历到数组长度的时候就加入到result里面</li><li>函数参数：传i和subset.i是用来记录遍历深度的。subset是记录子集</li><li>递归逻辑：分两种情况加入到result里面和不加入到result里面</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">i,subset</span>):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="built_in">len</span>(nums):</span><br><span class="line">                result.append(subset.copy())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># append nums[i]</span></span><br><span class="line">            subset.append(nums[i])</span><br><span class="line">            backtracking(i + <span class="number">1</span>,subset)</span><br><span class="line">            <span class="comment">#不加nums[i]</span></span><br><span class="line">            subset.pop()</span><br><span class="line">            backtracking(i+<span class="number">1</span>,subset)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        backtracking(<span class="number">0</span>,[])</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="39-组合总和-combination-sum"><a href="#39-组合总和-combination-sum" class="headerlink" title="39. 组合总和(combination sum)"></a>39. 组合总和(combination sum)</h2><p><a href="https://leetcode.cn/problems/combination-sum/">Leetcode链接</a></p><p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p><p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：candidates = [2,3,6,7], target = 7</span><br><span class="line">输出：[[2,2,3],[7]]</span><br><span class="line">解释：</span><br><span class="line">2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。</span><br><span class="line">7 也是一个候选， 7 = 7 。</span><br><span class="line">仅有这两种组合。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入: candidates = [2,3,5], target = 8</span><br><span class="line">输出: [[2,2,2,2],[2,3,3],[3,5]]</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入: candidates = [2], target = 1</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure><p><strong>这题重点是如何去重</strong><br><strong>permutations排列不去重，组合combinations去重</strong></p><h3 id="回溯思路-1"><a href="#回溯思路-1" class="headerlink" title="回溯思路"></a>回溯思路</h3><p><strong>时间复杂度分析</strong>O(2^t^)t是target value.<br>-首先同样脑中构建树。首先最容易想到的就是不去重的树，也就是每个结点都有提供的list钟选择方案。</p><ul><li>但是为了去重。脑中构建的树应该是和子集的思路类似的树。decision tree makes two decision each time.加入还是pop()<ol><li>回溯函数参数返回值:参数就是传入的index指针用来记录元素遍历结点还有个sublist用来记录结点。其实还可以传个targetsum用来记录结点和</li><li>终止条件：当遍历的指针长度大于length。当遍历的数组和大于提供的target</li><li>递归逻辑：单层加与不加，pop()出来以后只遍历i+1后序结点判断加与不加</li></ol></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum</span>(<span class="params">self, candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">i,sublist</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(sublist) == target:</span><br><span class="line">                result.append(sublist.copy())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(sublist) &gt; target <span class="keyword">or</span> i &gt;= <span class="built_in">len</span>(candidates):</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            sublist.append(candidates[i])</span><br><span class="line">            <span class="comment">#继续深入遍历因为可以支持重复元素</span></span><br><span class="line">            backtracking(i,sublist)</span><br><span class="line">            sublist.pop()</span><br><span class="line">            <span class="comment">#pop()了以后要shift1为了不重复</span></span><br><span class="line">            backtracking(i + <span class="number">1</span>,sublist)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        backtracking(<span class="number">0</span>,[])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="46-全排列（permutations）"><a href="#46-全排列（permutations）" class="headerlink" title="46. 全排列（permutations）"></a>46. 全排列（permutations）</h2><p><a href="https://leetcode.cn/problems/permutations/">Leetcode链接</a></p><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列。你可以 按任意顺序 返回答案。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums = [0,1]</span><br><span class="line">输出：[[0,1],[1,0]]</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：nums = [1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>脑中构建树图</p><ul><li>终止条件：当最小子问题是1的时候就return</li><li>参数和返回值：返回数组，参数是数组</li><li>单层逻辑：pop掉，获取子问题的返回值。遍历返回值加上pop掉的元素。然后result里面存放（permutes）再把nums加回来。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [nums[:]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            n = nums.pop(<span class="number">0</span>)</span><br><span class="line">            permautes = self.permute(nums)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> permautes:</span><br><span class="line">                i.append(n)</span><br><span class="line">            result.extend(permautes)</span><br><span class="line">            nums.append(n)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 回溯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1802. 有界数组中指定下标处的最大值</title>
      <link href="/2023/01/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1802-%E6%9C%89%E7%95%8C%E6%95%B0%E7%BB%84%E4%B8%AD%E6%8C%87%E5%AE%9A%E4%B8%8B%E6%A0%87%E5%A4%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
      <url>/2023/01/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1802-%E6%9C%89%E7%95%8C%E6%95%B0%E7%BB%84%E4%B8%AD%E6%8C%87%E5%AE%9A%E4%B8%8B%E6%A0%87%E5%A4%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="1802-有界数组中指定下标处的最大值"><a href="#1802-有界数组中指定下标处的最大值" class="headerlink" title="1802. 有界数组中指定下标处的最大值"></a>1802. 有界数组中指定下标处的最大值</h2><p><a href="https://leetcode.cn/problems/maximum-value-at-a-given-index-in-a-bounded-array/">Leetcode链接</a></p><h3 id="贪心-二分"><a href="#贪心-二分" class="headerlink" title="贪心+二分"></a>贪心+二分</h3><p>感觉很难的一道题。<br>首先项数对于 1到 n来说有 n-1+1项。算1到n之间的长度和算差值不一样。贪心就是考虑要求的index最大其他就减一。形成等差数列。</p><ul><li>给了n作为数组长度，index作为想要的最大值的index，maxsum作为数组求和以后的最大值</li><li><strong>其中重点是等差数列的计算分为两种情况</strong>。对于你传入的mid的值，和index（看成是一个包含多少元素）<ol><li>当传入的值大于等于包含的总元素时，说明是一个标准的等差数列。求和这个数列是（首项+尾项）*项数&#x2F;2 也就是mid + (mid-总元素 + 1) * 总元素 &#x2F; 2</li><li>当传入值小于包含的总元素时，会有额外的1产出所以计算是 （mid + 1）* mid &#x2F; 2 +额外的一也就是（总元素 - mid）</li></ol></li><li>接着利用二分法求出符合对应面积约束中（<code>sum_array &lt;= maxSum:</code>）最大的值。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxValue</span>(<span class="params">self, n: <span class="built_in">int</span>, index: <span class="built_in">int</span>, maxSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left = <span class="number">1</span></span><br><span class="line">        right = maxSum</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">            sum_array = self.sum_total(mid-<span class="number">1</span>,index) + self.sum_total(mid,n - index)</span><br><span class="line">            <span class="keyword">if</span> sum_array &lt;= maxSum:</span><br><span class="line">                left = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sum_total</span>(<span class="params">self,value,total_elements</span>):</span><br><span class="line">        <span class="keyword">if</span> value &gt;= total_elements:</span><br><span class="line">            <span class="keyword">return</span> (value + value - total_elements + <span class="number">1</span>) * total_elements // <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (value + <span class="number">1</span>) * value // <span class="number">2</span>+ total_elements - value</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯专题1</title>
      <link href="/2023/01/03/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%9B%9E%E6%BA%AF%E4%B8%93%E9%A2%981/"/>
      <url>/2023/01/03/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%9B%9E%E6%BA%AF%E4%B8%93%E9%A2%981/</url>
      
        <content type="html"><![CDATA[<h2 id="回溯理论基础"><a href="#回溯理论基础" class="headerlink" title="回溯理论基础"></a>回溯理论基础</h2><ul><li>回溯函数就是指递归函数。</li><li>回溯的本质就是枚举</li><li><strong>组合无序排列有序</strong></li><li>回溯法主要解决的问题是在集合中递归寻找子集的问题可被抽象成树结构</li><li>集合的大小构成了树的宽度，递归的深度构成了树的深度</li><li>抽象为N叉树</li></ul><h3 id="相关模板伪代码"><a href="#相关模板伪代码" class="headerlink" title="相关模板伪代码"></a>相关模板伪代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(参数)</span></span></span><br><span class="line"><span class="function"><span class="comment">//终止条件伪代码</span></span></span><br><span class="line"><span class="function"><span class="title">if</span> <span class="params">(终止条件)</span> </span>&#123;</span><br><span class="line">    存放结果;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//回溯函数遍历过程</span></span><br><span class="line"><span class="comment">// for 循环横向遍历，backtracking纵向遍历（深度）</span></span><br><span class="line"><span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">    处理节点;</span><br><span class="line">    <span class="built_in">backtracking</span>(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">    回溯，撤销处理结果</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a>77. 组合</h2><p><a href="https://leetcode.cn/problems/combinations/">Leetcode链接</a></p><ul><li>脑海中构建树形图</li><li>思考终止条件：当comb的长度等于题中给的长度的时候就加入到二维result里面去（需要shallow copy）要不然回溯会修改comb的长度</li><li>for loop遍历横向，然后处理节点</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">start,comb</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(comb) == k:</span><br><span class="line">                result.append(comb.copy())</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start,n + <span class="number">1</span>):</span><br><span class="line">                comb.append(i)</span><br><span class="line">                backtracking(i+<span class="number">1</span>,comb)</span><br><span class="line">                comb.pop()</span><br><span class="line">        backtracking(<span class="number">1</span>,[])</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">        </span><br></pre></td></tr></table></figure><p>二刷</p><ul><li>还是需要脑中构建树。</li><li>每次递归都是缩小横向搜索范围。同时控制了树的纵向遍历。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        ret = []</span><br><span class="line">        path = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">pos</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == k:</span><br><span class="line">                ret.append(path[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pos,n+<span class="number">1</span>):</span><br><span class="line">                path.append(i)</span><br><span class="line">                <span class="comment"># 是i+1不是pos+1这里很重要</span></span><br><span class="line">                backtracking(i + <span class="number">1</span>)</span><br><span class="line">                path.pop()</span><br><span class="line">        backtracking(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
          <category> 回溯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2042. 检查句子中的数字是否递增</title>
      <link href="/2023/01/03/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/2042-%E6%A3%80%E6%9F%A5%E5%8F%A5%E5%AD%90%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E6%98%AF%E5%90%A6%E9%80%92%E5%A2%9E/"/>
      <url>/2023/01/03/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/2042-%E6%A3%80%E6%9F%A5%E5%8F%A5%E5%AD%90%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E6%98%AF%E5%90%A6%E9%80%92%E5%A2%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="2042-检查句子中的数字是否递增"><a href="#2042-检查句子中的数字是否递增" class="headerlink" title="2042. 检查句子中的数字是否递增"></a>2042. 检查句子中的数字是否递增</h2><p><a href="https://leetcode.cn/problems/check-if-numbers-are-ascending-in-a-sentence/">Leetcode链接</a></p><h3 id="直接遍历"><a href="#直接遍历" class="headerlink" title="直接遍历"></a>直接遍历</h3><ul><li>先split成token</li><li>然后就判断首字母是不是数字</li><li>如果是的话就加入到result里面</li><li>然后遍历result数组进行判断</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">areNumbersAscending</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        token = s.split()</span><br><span class="line">        digital_result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> token:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">ord</span>(i[<span class="number">0</span>]) - <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>) &gt;= <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">ord</span>(i[<span class="number">0</span>]) - <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>) &lt;= <span class="number">9</span>:</span><br><span class="line">                digital_result.append(<span class="built_in">int</span>(i))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(digital_result)):</span><br><span class="line">            <span class="keyword">if</span> digital_result[i - <span class="number">1</span>] &gt;= digital_result[i]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>遍历一遍</li><li>首先看遍历的是不是数字，不是的话直接continue<ol><li>是字符的话，得再来个while循环来接受全部数字字符。用<code>cur = cur*10 + int(s[i])</code></li><li>遍历完成以后如果当前的字符数字小于等于前面的字符数字就直接<code>return False</code> pre数字最开始initial成0（因为题目中每个数字都是小于100的正整数且不包含前导0）</li><li>如果大于说明符合题意，直接把<code>pre = cur</code></li></ol></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">areNumbersAscending</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        pre = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">if</span> s[i].isdigit():</span><br><span class="line">                cur = <span class="number">0</span></span><br><span class="line">                <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[i].isdigit():</span><br><span class="line">                    cur = cur * <span class="number">10</span> + <span class="built_in">int</span>(s[i])</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> cur &lt;= pre:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                     pre = cur</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 暴力 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1801. 积压订单中的订单总数</title>
      <link href="/2023/01/02/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1801-%E7%A7%AF%E5%8E%8B%E8%AE%A2%E5%8D%95%E4%B8%AD%E7%9A%84%E8%AE%A2%E5%8D%95%E6%80%BB%E6%95%B0/"/>
      <url>/2023/01/02/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1801-%E7%A7%AF%E5%8E%8B%E8%AE%A2%E5%8D%95%E4%B8%AD%E7%9A%84%E8%AE%A2%E5%8D%95%E6%80%BB%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1801-积压订单中的订单总数"><a href="#1801-积压订单中的订单总数" class="headerlink" title="1801. 积压订单中的订单总数"></a>1801. 积压订单中的订单总数</h2><p><a href="https://leetcode.cn/problems/number-of-orders-in-the-backlog/">Leetcode链接</a></p><p>给你一个二维整数数组 orders ，其中每个 orders[i] &#x3D; [pricei, amounti, orderTypei] 表示有 amounti 笔类型为 orderTypei 、价格为 pricei 的订单。</p><p>订单类型 orderTypei 可以分为两种：</p><p>0 表示这是一批采购订单 buy<br>1 表示这是一批销售订单 sell<br>注意，orders[i] 表示一批共计 amounti 笔的独立订单，这些订单的价格和类型相同。对于所有有效的 i ，由 orders[i] 表示的所有订单提交时间均早于 orders[i+1] 表示的所有订单。</p><p>存在由未执行订单组成的 积压订单 。积压订单最初是空的。提交订单时，会发生以下情况：</p><p>如果该订单是一笔采购订单 buy ，则可以查看积压订单中价格 最低 的销售订单 sell 。如果该销售订单 sell 的价格 低于或等于 当前采购订单 buy 的价格，则匹配并执行这两笔订单，并将销售订单 sell 从积压订单中删除。否则，采购订单 buy 将会添加到积压订单中。<br>反之亦然，如果该订单是一笔销售订单 sell ，则可以查看积压订单中价格 最高 的采购订单 buy 。如果该采购订单 buy 的价格 高于或等于 当前销售订单 sell 的价格，则匹配并执行这两笔订单，并将采购订单 buy 从积压订单中删除。否则，销售订单 sell 将会添加到积压订单中。<br>输入所有订单后，返回积压订单中的 订单总数 。由于数字可能很大，所以需要返回对 109 + 7 取余的结果。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">输入：orders = [[10,5,0],[15,2,1],[25,1,1],[30,4,0]]</span><br><span class="line">输出：6</span><br><span class="line">解释：输入订单后会发生下述情况：</span><br><span class="line">- 提交 5 笔采购订单，价格为 10 。没有销售订单，所以这 5 笔订单添加到积压订单中。</span><br><span class="line">- 提交 2 笔销售订单，价格为 15 。没有采购订单的价格大于或等于 15 ，所以这 2 笔订单添加到积压订单中。</span><br><span class="line">- 提交 1 笔销售订单，价格为 25 。没有采购订单的价格大于或等于 25 ，所以这 1 笔订单添加到积压订单中。</span><br><span class="line">- 提交 4 笔采购订单，价格为 30 。前 2 笔采购订单与价格最低（价格为 15）的 2 笔销售订单匹配，从积压订单中删除这 2 笔销售订单。第 3 笔采购订单与价格最低的 1 笔销售订单匹配，销售订单价格为 25 ，从积压订单中删除这 1 笔销售订单。积压订单中不存在更多销售订单，所以第 4 笔采购订单需要添加到积压订单中。</span><br><span class="line">最终，积压订单中有 5 笔价格为 10 的采购订单，和 1 笔价格为 30 的采购订单。所以积压订单中的订单总数为 6 。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="优先队列（大小根堆）"><a href="#优先队列（大小根堆）" class="headerlink" title="优先队列（大小根堆）"></a>优先队列（大小根堆）</h3><p>读题很难（要明确buy和sell)。总的来说要用最大的价钱buy最便宜的sell.<br>所以buy的订单需要用大根堆，sell的订单需要用小根堆来存。存的东西是一个tuple二元组（price,amount）。因为python提供的heapq是小根堆。所以对于大根堆来说要<code>heappush(-price,amount)</code></p><ul><li>首先遍历订单。如果订单是0也就是采购订单的话，要去购买订单中查找最头元素。</li><li>这个时候要确定采购订单数量大于0，并且对于的sell订单不是空并且根据题意需要保证sell订单里面堆顶的price要低于或者等于采购订单的price<ol><li>对于采购订单的数量来说，如果当前pop出来的对应的sell订单的数量小于buy订单的数量就减去对应的sell订单数量</li><li>如果pop出来的sell订单数量大于buy的数量的时候就可以把当前buy订单全部清0然后再把sell的剩下的订单数量和价格push回去</li></ol></li><li>这个时候如果sell的堆空了但是buy的订单amount还有剩余,就把对应buy大根堆堆push进去。<code>（-price,amount）</code></li></ul><p>对于遍历到sell订单的逻辑也是同理</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getNumberOfBacklogOrders</span>(<span class="params">self, orders: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        mod_number = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        buy = []</span><br><span class="line">        sell = []</span><br><span class="line">        <span class="keyword">for</span> price,amount,ordertype <span class="keyword">in</span> orders:</span><br><span class="line">            <span class="keyword">if</span> ordertype == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">while</span> amount <span class="keyword">and</span> sell <span class="keyword">and</span> sell[<span class="number">0</span>][<span class="number">0</span>] &lt;= price:</span><br><span class="line">                    price_sell,amount_sell = heapq.heappop(sell)</span><br><span class="line">                    <span class="keyword">if</span> amount &gt;= amount_sell:</span><br><span class="line">                        amount -= amount_sell</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        heapq.heappush(sell,(price_sell,amount_sell-amount))</span><br><span class="line">                        amount = <span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> amount:</span><br><span class="line">                    heapq.heappush(buy,(-price,amount))</span><br><span class="line">            <span class="keyword">if</span> ordertype == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">while</span> amount <span class="keyword">and</span> buy <span class="keyword">and</span> -buy[<span class="number">0</span>][<span class="number">0</span>] &gt;= price:</span><br><span class="line">                    price_buy,amount_buy = heapq.heappop(buy)</span><br><span class="line">                    <span class="keyword">if</span> amount_buy &gt; amount:</span><br><span class="line">                        heapq.heappush(buy,(price_buy,amount_buy - amount))</span><br><span class="line">                        amount = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        amount -= amount_buy</span><br><span class="line">                <span class="keyword">if</span> amount:</span><br><span class="line">                    heapq.heappush(sell,(price,amount))</span><br><span class="line">        buy_total = <span class="number">0</span></span><br><span class="line">        sell_total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> buy:</span><br><span class="line">            buy_total += i[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> sell:</span><br><span class="line">            sell_total += i[<span class="number">1</span>]</span><br><span class="line">        result = (buy_total + sell_total) % mod_number</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 优先队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树专题9</title>
      <link href="/2023/01/01/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%989/"/>
      <url>/2023/01/01/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%989/</url>
      
        <content type="html"><![CDATA[<h2 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669. 修剪二叉搜索树"></a>669. 修剪二叉搜索树</h2><p><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/">Leetcode链接</a><br>给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。</p><p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">输入：root = [1,0,2], low = 1, high = 2</span><br><span class="line">输出：[1,null,2]</span><br><span class="line">输入：root = [1,0,2], low = 1, high = 2</span><br><span class="line">输出：[1,null,2]</span><br></pre></td></tr></table></figure><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul><li>递归函数参数返回值：就是原本参数root low 和 high bound 返回 cur指针</li><li>递归终止条件：如果遍历到none就return none</li><li>重复子问题：<ol><li>如果root value小于lower bound就向右去递归并且返回右子树符合的头节点</li><li>如果root value 大于 higher bound就向左去递归遍历并且返回左子树符合的头节点</li><li>如果在区间内，则root被保留，用root.left和root.right去接住返回上来的被修剪的结点</li></ol></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trimBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], low: <span class="built_in">int</span>, high: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> root.val &lt; low:</span><br><span class="line">            <span class="keyword">return</span> self.trimBST(root.right,low,high)</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; high:</span><br><span class="line">            <span class="keyword">return</span> self.trimBST(root.left,low,high)</span><br><span class="line">        <span class="keyword">if</span>  low &lt;= root.val &lt;= high:</span><br><span class="line">            root.left = self.trimBST(root.left,low,high)</span><br><span class="line">            root.right = self.trimBST(root.right,low,high)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h2 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a>108. 将有序数组转换为二叉搜索树</h2><p><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">Leetcode链接</a></p><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</p><p>高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">输入：nums = [-10,-3,0,5,9]</span><br><span class="line">输出：[0,-3,9,-10,null,5]</span><br><span class="line">解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：</span><br></pre></td></tr></table></figure><h3 id="递归（和最大二叉树类似）"><a href="#递归（和最大二叉树类似）" class="headerlink" title="递归（和最大二叉树类似）"></a>递归（和最大二叉树类似）</h3><ul><li>递归函数参数和返回值：参数就是数组，左边界右边界，返回值创建好的节点</li><li>终止条件：当left 大于 right就返回none</li><li>本层递归逻辑： (左闭右闭)<ul><li>选择mid的左边节点创建node,创建为root</li><li>root.left 接住[left,mid - 1]区间内返回的节点</li><li>root.right 接住[mid + 1,right]区间内返回节点</li></ul></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedArrayToBST</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">return</span> self.helper(nums,<span class="number">0</span>,<span class="built_in">len</span>(nums) - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">self,nums,left,right</span>):</span><br><span class="line">        <span class="comment">#左闭右闭</span></span><br><span class="line">        <span class="keyword">if</span> left &gt; right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        mid = (left + right) //<span class="number">2</span></span><br><span class="line">        root = TreeNode(nums[mid])</span><br><span class="line">        root.left = self.helper(nums,left,mid-<span class="number">1</span>)</span><br><span class="line">        root.right = self.helper(nums,mid + <span class="number">1</span>, right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a>538. 把二叉搜索树转换为累加树</h2><p><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">Leetcode链接</a></p><h3 id="递归（右中左）"><a href="#递归（右中左）" class="headerlink" title="递归（右中左）"></a>递归（右中左）</h3><ul><li>递归函数参数返回值：不需要返回值，直接在遍历的时候修改指针val即可。参数就是当前指针</li><li>终止条件：遍历到None就停止</li><li>单层逻辑：右中左遍历。对于中就用两个指针来记录，一个pre初始化为0，一个cur。通过cur来改当前树的节点的value.通过<code>pre = cur</code>来记录之前的节点的加和。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">convertBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        pre = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> pre</span><br><span class="line">            <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            dfs(root.right)</span><br><span class="line">            root.val += pre</span><br><span class="line">            pre = root.val</span><br><span class="line">            dfs(root.left)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2351. 第一个出现两次的字母</title>
      <link href="/2023/01/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/2351-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%87%BA%E7%8E%B0%E4%B8%A4%E6%AC%A1%E7%9A%84%E5%AD%97%E6%AF%8D/"/>
      <url>/2023/01/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/2351-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%87%BA%E7%8E%B0%E4%B8%A4%E6%AC%A1%E7%9A%84%E5%AD%97%E6%AF%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="2351-第一个出现两次的字母"><a href="#2351-第一个出现两次的字母" class="headerlink" title="2351. 第一个出现两次的字母"></a>2351. 第一个出现两次的字母</h2><p><a href="https://leetcode.cn/problems/first-letter-to-appear-twice/">Leetcode链接</a></p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><ul><li>使用哈希表进行遍历，如果没遇见就加入进去，遇见了重复的就直接返回当前字符。如果遍历一圈都没有就返回空字符</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">repeatedCharacter</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        total = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> total:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                total.add(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 哈希表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树专题8</title>
      <link href="/2022/12/30/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%988/"/>
      <url>/2022/12/30/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%988/</url>
      
        <content type="html"><![CDATA[<h2 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a>235. 二叉搜索树的最近公共祖先</h2><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">Leetcode链接</a></p><h3 id="递归（利用二叉树搜索树性质）"><a href="#递归（利用二叉树搜索树性质）" class="headerlink" title="递归（利用二叉树搜索树性质）"></a>递归（利用二叉树搜索树性质）</h3><ul><li><strong>递归函数参数和返回值</strong>：参数就是cur node，左边节点p和右边节点q</li><li><strong>终止条件</strong>：因为题目保证p和q一定存在所以root遍历到空的情况不会出现一定会有公共祖先</li><li><strong>单层递归逻辑</strong>： <ol><li>如果当前cur节点的值大于p和q的值那么就向左进行遍历</li><li>如果当前cur节点的值小于p和q的值那么向右进行遍历</li><li>否则就找到了公共祖先返回当前cur节点</li></ol></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="comment">#终止条件可以不写，因为题中明确说明p、q 为不同节点且均存在于给定的二叉搜索树中。而root一定在他们的上方</span></span><br><span class="line">        <span class="keyword">if</span> root.val &gt; p.val <span class="keyword">and</span> root.val &gt; q.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.left,p,q)</span><br><span class="line">        <span class="keyword">if</span> root.val &lt; p.val <span class="keyword">and</span> root.val &lt; q.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.right,p,q)</span><br><span class="line">        <span class="comment">#从上往下遍历如果发现在中间则一定是最近的公共祖先(不可能是次近的)</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h2 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a>701. 二叉搜索树中的插入操作</h2><p><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">Leetcode链接</a></p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul><li>递归终止条件：当root是空的时候就返回创建的新的node</li><li>递归函数返回值和参数： 返回值是TreeNode,参数就是cur指针和要插入的值</li><li>单层递归逻辑：本层需要用<code>root.left</code>或者<code>root.right</code>接住返回值随后直接<code>return root</code>. 如果val大于root的value就向右进行递归。反之向左递归。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insertIntoBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="comment">#重点：插入操作完成以后返回上一层以后直接返回root</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(val)</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; val:</span><br><span class="line">            root.left = self.insertIntoBST(root.left,val)</span><br><span class="line">        <span class="keyword">if</span> root.val &lt; val:</span><br><span class="line">            root.right = self.insertIntoBST(root.right,val)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h2 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a>450. 删除二叉搜索树中的节点</h2><p><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">Leetcode链接</a></p><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><ul><li>递归函数的参数和返回值：参数就是cur node 返回值是 tree node</li><li>终止条件：<ol><li>如果root节点是None那就return None</li><li>如果root节点的val &#x3D; 要删除节点的value<ol><li>如果root左右都是空那就直接返回None</li><li>如果左子树是空右子树不是空 -&gt; 返回当前<code>root.right</code></li><li>如果右子树不是空左子树是空 -&gt; 返回当前<code>root.left</code></li><li>如果左右子树都不是空 (较难)，删除左子树的头节点（左孩子）然后放到右子树中的左子树值最小的节点下面。然后把根节点赋值给原来的根的右子树（删除根节点操作）</li></ol></li></ol></li><li>递归逻辑：二叉搜索树都是单边遍历所以逻辑很简单。root的值小于val就向右遍历同时赋值给<code>root.right</code>去接住返回值，root值大于value就向左遍历也要赋值去接住返回值</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteNode</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], key: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> root.val == key:</span><br><span class="line">            <span class="keyword">if</span> root.left == <span class="literal">None</span> <span class="keyword">and</span> root.right == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> root.left == <span class="literal">None</span> <span class="keyword">and</span> root.right != <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> root.right</span><br><span class="line">            <span class="keyword">if</span> root.right == <span class="literal">None</span> <span class="keyword">and</span> root.left != <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> root.left</span><br><span class="line">            <span class="keyword">if</span> root.left != <span class="literal">None</span> <span class="keyword">and</span> root.right != <span class="literal">None</span>:</span><br><span class="line">                <span class="comment">#遍历到右子树的左子树最小节点</span></span><br><span class="line">                cur = root.right</span><br><span class="line">                <span class="keyword">while</span> cur.left != <span class="literal">None</span>:</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                <span class="comment"># 把左孩子移动到右子树向左递归的最小节点</span></span><br><span class="line">                cur.left = root.left</span><br><span class="line">                <span class="comment">#删除root操作</span></span><br><span class="line">                root =root.right</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">        <span class="comment"># 单边遍历</span></span><br><span class="line">        <span class="keyword">if</span> root.val &lt; key:</span><br><span class="line">            root.right = self.deleteNode(root.right,key)</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; key:</span><br><span class="line">            root.left = self.deleteNode(root.left,key)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树专题7</title>
      <link href="/2022/12/29/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%987/"/>
      <url>/2022/12/29/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%987/</url>
      
        <content type="html"><![CDATA[<h2 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530. 二叉搜索树的最小绝对差"></a>530. 二叉搜索树的最小绝对差</h2><p><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">Leetcode链接</a></p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h4 id="直白想法"><a href="#直白想法" class="headerlink" title="直白想法"></a>直白想法</h4><p>首先中序遍历求出数组然后再去用得出的数组进行邻近比较选出差值最小的（可以邻近比较的原因是数组是有序的）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMinimumDifference</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        result = []</span><br><span class="line">        min_value = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(root.left)</span><br><span class="line">            result.append(root.val)</span><br><span class="line">            dfs(root.right)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(result)):</span><br><span class="line">            value = result[i] - result[i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> value &lt; min_value:</span><br><span class="line">                min_value = value</span><br><span class="line">        <span class="keyword">return</span> min_value</span><br><span class="line">            </span><br></pre></td></tr></table></figure><h4 id="双指针递归"><a href="#双指针递归" class="headerlink" title="双指针递归"></a>双指针递归</h4><ul><li>递归函数参数和返回值：无返回值，参数就是当前的root node</li><li>终止条件：终止条件就是递归到终节点</li><li>单层递归逻辑：这里出现了双指针的用法。(<strong>需要先对pre指针进行初始化为None</strong>)<ol><li>首先递归左子树</li><li>在pre指针不为空的情况下，cur减去pre(cur一定比pre大)。然后如果小于result就进行赋值操作。最后把cur的指针赋给pre</li><li>其次再进行递归右子树</li></ol></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMinimumDifference</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        result = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">cur</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> pre,result</span><br><span class="line">            <span class="keyword">if</span> cur == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(cur.left)</span><br><span class="line">            <span class="keyword">if</span> pre != <span class="literal">None</span>:</span><br><span class="line">                diff = cur.val - pre.val</span><br><span class="line">                <span class="keyword">if</span> diff &lt; result:</span><br><span class="line">                    result = diff</span><br><span class="line">            <span class="comment">##重点</span></span><br><span class="line">            pre = cur</span><br><span class="line">            dfs(cur.right)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501. 二叉搜索树中的众数"></a>501. 二叉搜索树中的众数</h2><p><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">Leetcode链接</a></p><h3 id="sort-dictionary-根据value的大小方法"><a href="#sort-dictionary-根据value的大小方法" class="headerlink" title="sort dictionary 根据value的大小方法"></a>sort dictionary 根据value的大小方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># To get the values use</span></span><br><span class="line"><span class="built_in">sorted</span>(data.values())</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;<span class="number">1</span>:<span class="number">5</span>,<span class="number">2</span>:<span class="number">3</span>,<span class="number">4</span>:<span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(a.values())</span><br><span class="line">[<span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># To get the matching keys, use a key function</span></span><br><span class="line"><span class="built_in">sorted</span>(data, key=data.get)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;<span class="number">1</span>:<span class="number">5</span>,<span class="number">2</span>:<span class="number">3</span>,<span class="number">4</span>:<span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(a, key = a.get)</span><br><span class="line">[<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(a, key = a.get,reverse =<span class="literal">True</span>)</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># To get a list of tuples ordered by value</span></span><br><span class="line"><span class="built_in">sorted</span>(data.items(), key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="暴力解法-哈希表加深度优先搜索"><a href="#暴力解法-哈希表加深度优先搜索" class="headerlink" title="暴力解法 哈希表加深度优先搜索"></a>暴力解法 哈希表加深度优先搜索</h3><ul><li>利用中序遍历获取二叉搜索树全部node</li><li>创建对应的dic计算每个node的频率</li><li>然后获取最大的node的频率。在dict中寻找对于的最大频率的node的key</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMode</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(root.left)</span><br><span class="line">            dic[root.val] = dic.get(root.val,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            dfs(root.right)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        max_value = <span class="built_in">max</span>(dic.values())</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> dic.items():</span><br><span class="line">            <span class="keyword">if</span> v == max_value:</span><br><span class="line">                result.append(k)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="递归一次遍历"><a href="#递归一次遍历" class="headerlink" title="递归一次遍历"></a>递归一次遍历</h3><p>参考代码未懂逻辑<br>左中右</p><ul><li>递归函数参数和返回值：返回空，函数参数是cur指针</li><li>终止条件遍历到空：就return</li><li>单层逻辑：</li><li>递归左</li><li>对于count来说<ol><li>如果第一个节点就赋值count为1</li><li>如果cur的值和pre的值一样 count就加1</li><li>如果不一样count就变为1</li></ol></li><li>对于max count来说<br>1.如果当前的count和max count值一样的话，就往result里面添加cur.val<ol start="2"><li>如果当前的count大于max coount的话就进行赋值，然后result清空再去添加当前值</li></ol></li><li>递归右</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.pre = TreeNode()</span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line">        self.max_count = <span class="number">0</span></span><br><span class="line">        self.result = []</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMode</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        self.search(root)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self,cur</span>):</span><br><span class="line">        <span class="keyword">if</span> cur == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        self.search(cur.left)</span><br><span class="line">        <span class="comment">#第一个节点</span></span><br><span class="line">        <span class="keyword">if</span> self.pre == <span class="literal">None</span>:</span><br><span class="line">            self.count = <span class="number">1</span></span><br><span class="line">        <span class="comment">#和前一个节点数值相同</span></span><br><span class="line">        <span class="keyword">elif</span> self.pre.val == cur.val:</span><br><span class="line">            self.count += <span class="number">1</span></span><br><span class="line">        <span class="comment">#和前一个节点数值不同</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.count = <span class="number">1</span></span><br><span class="line">        self.pre = cur</span><br><span class="line">        <span class="keyword">if</span> self.count == self.max_count:</span><br><span class="line">            self.result.append(cur.val)</span><br><span class="line">        <span class="comment">#更新max count清空result</span></span><br><span class="line">        <span class="keyword">if</span> self.count &gt; self.max_count:</span><br><span class="line">            self.max_count = self.count</span><br><span class="line">            self.result = [cur.val]</span><br><span class="line">        self.search(cur.right)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure><h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a>236. 二叉树的最近公共祖先</h2><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">Leetcode链接</a></p><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><ul><li><strong>递归终止条件</strong>：如果当前遍历节点是None就返回None,如果当前遍历节点不是None但是是q或者p就返回当前遍历节点（就终止了）</li><li><strong>递归函数参数返回值</strong>：返回的是Node参数是传入树node和两个提供的节点p和q</li><li><strong>单层递归逻辑</strong>：左右中后序遍历（自底向上查找天然的回溯），递归左子树返回值记为left,递归右子树返回值记为right,根据左右子树的返回值对“中”进行操作。分以下四种情况<ol><li>左子树返回值为空，右子树返回值为空，说明左右子树都不包含p或者q，则返回空</li><li>左子树返回值不是空，右子树是空则返回左子树</li><li>左子树返回值是空，右子树返回值不是空则返回左子树</li><li>左右子树返回值都不是空则返回当前的root节点作为公共祖先</li></ol></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> root == p <span class="keyword">or</span> root == q:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        left = self.lowestCommonAncestor(root.left,p,q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right,p,q)</span><br><span class="line">        <span class="keyword">if</span> left == <span class="literal">None</span> <span class="keyword">and</span> right != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">if</span> left != <span class="literal">None</span> <span class="keyword">and</span> right == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">if</span> left == <span class="literal">None</span> <span class="keyword">and</span> right == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树专题6</title>
      <link href="/2022/12/28/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%986/"/>
      <url>/2022/12/28/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%986/</url>
      
        <content type="html"><![CDATA[<h2 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654. 最大二叉树"></a>654. 最大二叉树</h2><p><a href="https://leetcode.cn/problems/maximum-binary-tree/">https://leetcode.cn/problems/maximum-binary-tree/</a><br>给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:</p><p>创建一个根节点，其值为 nums 中的最大值。<br>递归地在最大值 左边 的 子数组前缀上 构建左子树。<br>递归地在最大值 右边 的 子数组后缀上 构建右子树。<br>返回 nums 构建的 最大二叉树 。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,1,6,0,5]</span><br><span class="line">输出：[6,3,5,null,2,0,null,null,1]</span><br><span class="line">解释：递归调用如下所示：</span><br><span class="line">- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。</span><br><span class="line">    - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。</span><br><span class="line">        - 空数组，无子节点。</span><br><span class="line">        - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。</span><br><span class="line">            - 空数组，无子节点。</span><br><span class="line">            - 只有一个元素，所以子节点是一个值为 1 的节点。</span><br><span class="line">    - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。</span><br><span class="line">        - 只有一个元素，所以子节点是一个值为 0 的节点。</span><br><span class="line">        - 空数组，无子节点。</span><br></pre></td></tr></table></figure><h3 id="递归（前序遍历）"><a href="#递归（前序遍历）" class="headerlink" title="递归（前序遍历）"></a>递归（前序遍历）</h3><p>凡是构造二叉树的题目都用前序遍历</p><p>和前面的思路一样</p><ul><li>终止条件，当数组为空返回None</li><li>单层逻辑：<ol><li>先寻找最大值，创建root node然后记录对应最大值的index用来split数组</li><li>然后进行递归左子树递归右子树去解决小问题</li></ol></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">constructMaximumBinaryTree</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        max_value = <span class="built_in">max</span>(nums)</span><br><span class="line">        root = TreeNode(max_value)</span><br><span class="line">        index = nums.index(max_value)</span><br><span class="line"></span><br><span class="line">        nums_left = nums[:index]</span><br><span class="line">        nums_right = nums[index + <span class="number">1</span>:]</span><br><span class="line">        root.left = self.constructMaximumBinaryTree(nums_left)</span><br><span class="line">        root.right = self.constructMaximumBinaryTree(nums_right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a>617. 合并二叉树</h2><p><a href="https://leetcode.cn/problems/merge-two-binary-trees/">https://leetcode.cn/problems/merge-two-binary-trees/</a></p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul><li>返回值和参数：参数就是两个给的树，返回值：返回合并的tree</li><li>递归终止条件：当一个空了就返回另外一个</li><li>单层逻辑：中左右，就是创建个新的node值是左边加右边。然后左右递归</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTrees</span>(<span class="params">self, root1: <span class="type">Optional</span>[TreeNode], root2: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> root1 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root2</span><br><span class="line">        <span class="keyword">if</span> root2 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root1</span><br><span class="line">        merge = TreeNode(root1.val + root2.val)</span><br><span class="line">        merge.left = self.mergeTrees(root1.left,root2.left)</span><br><span class="line">        merge.right = self.mergeTrees(root1.right,root2.right)</span><br><span class="line">        <span class="keyword">return</span> merge</span><br></pre></td></tr></table></figure><h2 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a>700. 二叉搜索树中的搜索</h2><p><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">https://leetcode.cn/problems/search-in-a-binary-search-tree/</a></p><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><ul><li>参数和返回值：参数是整个树，返回值也是树</li><li>终止条件：如果是None或者值等于给定值就返回树</li><li>单层递归逻辑： 大于就递归遍历左边，小于就递归遍历右边</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> root.val &gt; val:</span><br><span class="line">            root = root.left</span><br><span class="line">        <span class="keyword">elif</span> root.val == val:</span><br><span class="line">           <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            root = root.right</span><br><span class="line">        <span class="keyword">return</span> self.searchBST(root,val)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span> <span class="keyword">or</span> root.val == val:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; val:</span><br><span class="line">            <span class="keyword">return</span> self.searchBST(root.left,val)</span><br><span class="line">        <span class="keyword">if</span> root.val &lt; val:</span><br><span class="line">            <span class="keyword">return</span> self.searchBST(root.right,val)</span><br></pre></td></tr></table></figure><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>不需要使用stack,因为二叉搜索树的特性已经决定了搜索的方向</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">while</span> root != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> root.val &gt; val:</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">elif</span> root.val &lt; val:</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">        </span><br></pre></td></tr></table></figure><h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a>98. 验证二叉搜索树</h2><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/">https://leetcode.cn/problems/validate-binary-search-tree/</a></p><h3 id="最直观想法"><a href="#最直观想法" class="headerlink" title="最直观想法"></a>最直观想法</h3><ul><li>中序遍历变成有序数组然后利用for loop去看</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        result = []</span><br><span class="line">        self.dfs(root,result)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(result)-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> result[i] &lt; result[i + <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self,root,result</span>):</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.dfs(root.left,result)</span><br><span class="line">        result.append(root.val)</span><br><span class="line">        self.dfs(root.right,result)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">           </span><br></pre></td></tr></table></figure><h3 id="python-定义最大值最小值"><a href="#python-定义最大值最小值" class="headerlink" title="python 定义最大值最小值"></a>python 定义最大值最小值</h3><p><code>max = float(&quot;inf&quot;) 无限大</code><br><code>min = float(&quot;-inf&quot;) 无限小</code></p><h3 id="标准做法（中序遍历同时比较）"><a href="#标准做法（中序遍历同时比较）" class="headerlink" title="标准做法（中序遍历同时比较）"></a>标准做法（中序遍历同时比较）</h3><ul><li>递归的同时做比较</li><li>左中右</li><li>递归参数和返回值：参数是树，返回值是boolean值</li><li>终止条件：当遍历到None返回 true</li><li>单层递归逻辑：递归左子树，遇到比最小值小的时候记录然后替换最小值，遇到比最小值大的时候直接return false 然后递归右子树</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        min_value = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> min_value</span><br><span class="line">            <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            left = dfs(root.left)</span><br><span class="line">            <span class="keyword">if</span> root.val &gt; min_value:</span><br><span class="line">                min_value = root.val</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            right = dfs(root.right)</span><br><span class="line">            <span class="keyword">return</span> left <span class="keyword">and</span> right</span><br><span class="line">        <span class="keyword">return</span> dfs(root)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树专题5</title>
      <link href="/2022/12/27/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%985/"/>
      <url>/2022/12/27/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%985/</url>
      
        <content type="html"><![CDATA[<h2 id="513-找树左下角的值（最底层最左边）"><a href="#513-找树左下角的值（最底层最左边）" class="headerlink" title="513. 找树左下角的值（最底层最左边）"></a>513. 找树左下角的值（最底层最左边）</h2><p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">https://leetcode.cn/problems/find-bottom-left-tree-value/</a></p><h3 id="迭代层序遍历"><a href="#迭代层序遍历" class="headerlink" title="迭代层序遍历"></a>迭代层序遍历</h3><ul><li>层序遍历模版，只有遇到每层的开头元素才会去赋值</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findBottomLeftValue</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="comment"># print(queue)</span></span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            total_size = <span class="built_in">len</span>(queue)</span><br><span class="line">            node = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">while</span> size:</span><br><span class="line">                <span class="keyword">if</span> total_size == <span class="built_in">len</span>(queue):</span><br><span class="line">                    node = queue.popleft()</span><br><span class="line">                    </span><br><span class="line">                    result = node.val</span><br><span class="line">                    <span class="comment"># print(result)</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    node = queue.popleft()</span><br><span class="line">                size -= <span class="number">1</span></span><br><span class="line">                <span class="comment">#这两个写在while里面，debug半天没找出来</span></span><br><span class="line">                <span class="keyword">if</span> node.left != <span class="literal">None</span>:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right != <span class="literal">None</span>:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findBottomLeftValue</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        queue = deque()</span><br><span class="line">        <span class="keyword">if</span> root: </span><br><span class="line">            queue.append(root)</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue: </span><br><span class="line">            q_len = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(q_len): </span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span>: </span><br><span class="line">                    result = queue[i].val </span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> cur.left: </span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right: </span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><a href="https://www.w3schools.com/python/ref_keyword_nonlocal.asp">https://www.w3schools.com/python/ref_keyword_nonlocal.asp</a></p><p>The <strong>nonlocal keyword</strong> is used to work with variables inside nested functions, <strong>where the variable should not belong to the inner function</strong>.</p><p>Use the keyword nonlocal to declare that the variable is not local.</p><h3 id="递归遍历（dfs）"><a href="#递归遍历（dfs）" class="headerlink" title="递归遍历（dfs）"></a>递归遍历（dfs）</h3><p>要找到左下角的值必须要找到最深处，所以需要个变量记录最大深度。只有当当前节点的深度大于最大深度的时候才会赋值给result</p><ul><li>递归函数参数：每个node的depth和每个node无返回值</li><li>递归终止条件：当node左右都子节点都为空的时候，如果当前节点的depth是大于记录的最深节点就记录成result</li><li>单层遍历逻辑： 遍历左边遍历右边。遍历的时候传depth值。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findBottomLeftValue</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root,depth</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> max_depth,result</span><br><span class="line">            <span class="keyword">if</span> root.left == <span class="literal">None</span> <span class="keyword">and</span> root.right == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> depth &gt; max_depth:</span><br><span class="line">                    max_depth = depth</span><br><span class="line">                    result = root.val</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                depth += <span class="number">1</span></span><br><span class="line">                dfs(root.left,depth)</span><br><span class="line">                <span class="comment">#回溯</span></span><br><span class="line">                depth -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                depth += <span class="number">1</span></span><br><span class="line">                dfs(root.right,depth)</span><br><span class="line">                depth -= <span class="number">1</span></span><br><span class="line">        max_depth = - <span class="built_in">float</span>(<span class="string">&quot;INF&quot;</span>)</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        dfs(root,<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a>112. 路径总和</h2><p><a href="https://leetcode.cn/problems/path-sum/">https://leetcode.cn/problems/path-sum/</a></p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>自己受到前面打印路径的启发，用了个set作为记录每条路径的数值总和。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        hashset = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root,result,hashset</span>):</span><br><span class="line">            result += root.val</span><br><span class="line">            <span class="keyword">if</span> root.left == <span class="literal">None</span> <span class="keyword">and</span> root.right == <span class="literal">None</span>:</span><br><span class="line">                hashset.add(result)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> root.left != <span class="literal">None</span>:</span><br><span class="line">                dfs(root.left,result,hashset)</span><br><span class="line">            <span class="keyword">if</span> root.right != <span class="literal">None</span>:</span><br><span class="line">                dfs(root.right,result,hashset)</span><br><span class="line">        dfs(root,result,hashset)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> targetSum <span class="keyword">in</span> hashset <span class="keyword">else</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="标准做法递归"><a href="#标准做法递归" class="headerlink" title="标准做法递归"></a>标准做法递归</h4><p>把大问题转化成小问题。<br>大问题：求根节点到叶子节点到路径sum等于value。<br>小问题：<strong>假设根节点到当前节点的路径sum是val,<br>求当前节点的子节点到叶子节点到路径和是否为sum-val</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> root.left == <span class="literal">None</span> <span class="keyword">and</span> root.right == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> targetSum == root.val</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.hasPathSum(root.left, targetSum - root.val) <span class="keyword">or</span> self.hasPathSum(root.right, targetSum - root.val) </span><br></pre></td></tr></table></figure><h4 id="递归包含回溯"><a href="#递归包含回溯" class="headerlink" title="递归包含回溯"></a>递归包含回溯</h4><ul><li>递归函数返回值和参数：node,传入的count，返回值是布尔值也就是最后这个叶子节点是true还是false</li><li>终止条件：是这个当前的传入的值被剪为0同时左右都是空</li><li>单层逻辑：终止条件是判断叶子节点，所以递归过程中不要让空节点进入递归. 然后递归处理左右节点</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">root,targetSum</span>):</span><br><span class="line">            <span class="keyword">if</span> root.left == <span class="literal">None</span> <span class="keyword">and</span> root.right == <span class="literal">None</span> <span class="keyword">and</span> targetSum ==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> root.left != <span class="literal">None</span>:</span><br><span class="line">                <span class="comment">#包含回溯</span></span><br><span class="line">                targetSum -= root.left.val</span><br><span class="line">                <span class="keyword">if</span> helper(root.left,targetSum):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                targetSum += root.left.val</span><br><span class="line">            <span class="keyword">if</span> root.right != <span class="literal">None</span>:</span><br><span class="line">                targetSum -= root.right.val</span><br><span class="line">                <span class="keyword">if</span> helper(root.right,targetSum):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">                targetSum += root.right.val</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="keyword">return</span> helper(root,targetSum-root.val)</span><br></pre></td></tr></table></figure><h2 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a>113. 路径总和 II</h2><p><a href="https://leetcode.cn/problems/path-sum-ii/">https://leetcode.cn/problems/path-sum-ii/</a></p><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><ul><li>递归函数参数和返回值：返回值是空，参数有一个count是用来递减判断路径的，有一个result是用来append合法路径的</li><li>终止条件：当两个都是空的时候终止，或者当两个都是空并且count也剪到0了就可以用result append了</li><li>单层逻辑：遍历左边遍历右边</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = <span class="built_in">list</span>()</span><br><span class="line">        path =<span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        path.append(root.val)</span><br><span class="line">        self.helper(root,targetSum-root.val,path,result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">self,root,targetSum,path,result</span>):</span><br><span class="line">        <span class="keyword">if</span> targetSum == <span class="number">0</span> <span class="keyword">and</span> root.left == <span class="literal">None</span> <span class="keyword">and</span> root.right == <span class="literal">None</span>:</span><br><span class="line">            result.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> root.left == <span class="literal">None</span> <span class="keyword">and</span> root.right == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">if</span> root.left != <span class="literal">None</span>:</span><br><span class="line">            path.append(root.left.val)</span><br><span class="line">            self.helper(root.left,targetSum -root.left.val,path,result)</span><br><span class="line">            <span class="comment"># 回溯</span></span><br><span class="line">            path.pop()</span><br><span class="line">        <span class="keyword">if</span> root.right != <span class="literal">None</span>:</span><br><span class="line">            path.append(root.right.val)</span><br><span class="line">            self.helper(root.right,targetSum -root.right.val,path,result)</span><br><span class="line">            path.pop()</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure><h2 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a>106. 从中序与后序遍历序列构造二叉树</h2><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/</a></p><h3 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h3><ol><li>如果后序数组是空说明遍历结束终止</li><li>后序遍历是左右中，所以中一定是最后的，所以索取中的index</li><li>通过index来切分中序遍历的数组</li><li>通过前面切分的数组长度来切分后序遍历的数组</li><li>递归遍历左子树然后递归遍历右子树</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, inorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> postorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#后序遍历最后一个点就是中</span></span><br><span class="line">        root_value = postorder[-<span class="number">1</span>]</span><br><span class="line">        root = TreeNode(root_value)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#找切割点</span></span><br><span class="line">        index = inorder.index(root_value)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 切割中序</span></span><br><span class="line">        inorder_left = inorder[<span class="number">0</span>:index]</span><br><span class="line">        inorder_right = inorder[index + <span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 切割后序</span></span><br><span class="line">        <span class="comment">#重点 中序数组大小和后序数组大小一定一样</span></span><br><span class="line">        postorder_left = postorder[<span class="number">0</span>:<span class="built_in">len</span>(inorder_left)]</span><br><span class="line">        postorder_right = postorder[<span class="built_in">len</span>(inorder_left):<span class="built_in">len</span>(postorder) - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        root.left = self.buildTree(inorder_left,postorder_left)</span><br><span class="line">        root.right = self.buildTree(inorder_right,postorder_right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a>105. 从前序与中序遍历序列构造二叉树</h2><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p><h3 id="递归-3"><a href="#递归-3" class="headerlink" title="递归"></a>递归</h3><p>和上面同样逻辑</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        root_value = preorder[<span class="number">0</span>]</span><br><span class="line">        root = TreeNode(root_value)</span><br><span class="line">        index = inorder.index(root_value)</span><br><span class="line"></span><br><span class="line">        inorder_left = inorder[:index]</span><br><span class="line">        inorder_right = inorder[index + <span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        preorder_left = preorder[<span class="number">1</span>:<span class="built_in">len</span>(inorder_left)+ <span class="number">1</span>]</span><br><span class="line">        preorder_right = preorder[<span class="built_in">len</span>(inorder_left) + <span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        root.left = self.buildTree(preorder_left,inorder_left)</span><br><span class="line">        root.right = self.buildTree(preorder_right,inorder_right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树专题4</title>
      <link href="/2022/12/27/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%984/"/>
      <url>/2022/12/27/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%984/</url>
      
        <content type="html"><![CDATA[<h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a>110. 平衡二叉树</h2><p><a href="https://leetcode.cn/problems/balanced-binary-tree/">https://leetcode.cn/problems/balanced-binary-tree/</a></p><p>本题中，一棵高度平衡二叉树定义为：<br>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1</p><ul><li>求高度用后序遍历</li><li>求深度用前序遍历</li></ul><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul><li>明确递归函数的参数和返回值: 参数就是当前节点,返回值就是当前节点的树的高度</li><li>终止条件: 遇到空节点就返回高度是0</li><li>单层递归的逻辑<ol><li>求左右子树的高度差值，如果高度大于1就<strong>返回-1</strong></li></ol></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isBalanced</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> self.getHeight(root) == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getHeight</span>(<span class="params">self,root</span>):</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment">#左</span></span><br><span class="line">        left_h = self.getHeight(root.left)</span><br><span class="line">        <span class="keyword">if</span> left_h == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="comment">#右</span></span><br><span class="line">        right_h = self.getHeight(root.right)</span><br><span class="line">        <span class="keyword">if</span> right_h == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="comment">#中</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(left_h - right_h) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        result = <span class="number">1</span> + <span class="built_in">max</span>(left_h,right_h)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">        </span><br></pre></td></tr></table></figure><h2 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a>257. 二叉树的所有路径</h2><p><a href="https://leetcode.cn/problems/binary-tree-paths/">https://leetcode.cn/problems/binary-tree-paths/</a></p><h3 id="递归（前序遍历）"><a href="#递归（前序遍历）" class="headerlink" title="递归（前序遍历）"></a>递归（前序遍历）</h3><ul><li>利用path记录每个path</li><li>利用result对每个path进行append</li></ul><p>递归函数的参数和返回值:参数有node,result列表，path字符串<br>终止条件：当node.left和node.right都是空的时候把path加入到结果中<br>单层逻辑：对于每层如果node.left存在就进行递归，node.right存在就进行递归</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">binaryTreePaths</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        path = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node,result,path</span>):</span><br><span class="line">            <span class="comment">#中：写在这里是为了避免叶子节点没有被加入到path里面</span></span><br><span class="line">            path += <span class="built_in">str</span>(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left == <span class="literal">None</span> <span class="keyword">and</span> node.right == <span class="literal">None</span>:</span><br><span class="line">                result.append(path)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> node.left != <span class="literal">None</span>:</span><br><span class="line">                <span class="comment">#回溯的过程其实就是删掉&quot;-&gt;&quot;</span></span><br><span class="line">                dfs(node.left,result,path + <span class="string">&#x27;-&gt;&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> node.right != <span class="literal">None</span>:</span><br><span class="line">                dfs(node.right,result,path + <span class="string">&#x27;-&gt;&#x27;</span>)</span><br><span class="line">        dfs(root,result,path)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a>404. 左叶子之和</h2><p><a href="https://leetcode.cn/problems/sum-of-left-leaves/">https://leetcode.cn/problems/sum-of-left-leaves/</a></p><h3 id="递归（后序遍历）"><a href="#递归（后序遍历）" class="headerlink" title="递归（后序遍历）"></a>递归（后序遍历）</h3><ul><li>递归函数返回值和参数：返回值类型是int，参数是node</li><li>终止条件是：节点是none 返回0</li><li>单层逻辑：遇到左叶子节点就记录数值然后递归求取左子树左叶子之和和右子树的左叶子之和<br>重点是通过节点的父节点来判断本节点的属性</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumOfLeftLeaves</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> root.left == <span class="literal">None</span> <span class="keyword">and</span> root.right == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left_val = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> root.left != <span class="literal">None</span> <span class="keyword">and</span> root.left.left == <span class="literal">None</span> <span class="keyword">and</span> root.left.right == <span class="literal">None</span>:</span><br><span class="line">            left_val = root.left.val</span><br><span class="line">        <span class="keyword">return</span> left_val + self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树专题3</title>
      <link href="/2022/12/25/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%983/"/>
      <url>/2022/12/25/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%983/</url>
      
        <content type="html"><![CDATA[<h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h2><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">https://leetcode.cn/problems/maximum-depth-of-binary-tree/</a></p><ul><li><strong>二叉树高度</strong>是指二叉树中任意一个节点到叶子节点到距离，根节点到高度是最大的（用<strong>后序</strong>从下往上去计数）</li><li><strong>二叉树深度</strong>是指任意一个节点到根节点的距离，叶子节点深度最大（用<strong>前序</strong>从上往下去计数）</li></ul><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul><li>用后序遍历求高度得出的结论就是二叉树的深度</li><li>停止条件就是遍历到none节点 return 0</li><li>每层都是求left的height然后求right的height</li><li>最后返回是 1 + max(left_height,right_height)</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.getHeight(root)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getHeight</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        lh = self.getHeight(root.left)</span><br><span class="line">        rh = self.getHeight(root.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(lh,rh)</span><br></pre></td></tr></table></figure><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><ul><li>套层序遍历模版然后一样用queue每遍历一层就加一</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> count</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="keyword">while</span> size:</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> node.left != <span class="literal">None</span>: queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right != <span class="literal">None</span>: queue.append(node.right)</span><br><span class="line">                size -= <span class="number">1</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h2 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a>111. 二叉树的最小深度</h2><p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">https://leetcode.cn/problems/minimum-depth-of-binary-tree/</a></p><h3 id="递归-后序求高度的逻辑来求的深度"><a href="#递归-后序求高度的逻辑来求的深度" class="headerlink" title="递归 (后序求高度的逻辑来求的深度)"></a>递归 (后序求高度的逻辑来求的深度)</h3><p>暂未理解</p><h3 id="层序遍历-1"><a href="#层序遍历-1" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>重点：套层序遍历模版，<strong>判断条件当node.left和node.right都是空的时候才会去return count</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            size  = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="comment"># count必须写前面</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> size:</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> node.left != <span class="literal">None</span>:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right != <span class="literal">None</span>:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> node.left == <span class="literal">None</span> <span class="keyword">and</span> node.right == <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">return</span> count</span><br><span class="line">                size -= <span class="number">1</span> </span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">        </span><br></pre></td></tr></table></figure><h2 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a>222. 完全二叉树的节点个数</h2><p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">https://leetcode.cn/problems/count-complete-tree-nodes/</a></p><h3 id="递归-后序"><a href="#递归-后序" class="headerlink" title="递归 (后序)"></a>递归 (后序)</h3><p>复杂度O(n)</p><ul><li>和求最大深度一个道理但是没有来max()</li><li>而是每遍历一次加一</li><li>终止条件就是root是None</li><li>每次递归条件就是left + right + 1</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countNodes</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.num(root)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">num</span>(<span class="params">self,root</span>):</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = self.num(root.left)</span><br><span class="line">        right = self.num(root.right)</span><br><span class="line">        <span class="keyword">return</span> left + right + <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="迭代（层序遍历）"><a href="#迭代（层序遍历）" class="headerlink" title="迭代（层序遍历）"></a>迭代（层序遍历）</h3><p>复杂度O(n)</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countNodes</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="keyword">while</span> size:</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> node.left != <span class="literal">None</span>: queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right != <span class="literal">None</span>: queue.append(node.right)</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                size -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p><a href="https://baike.baidu.com/item/%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/5622348">https://baike.baidu.com/item/%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/5622348</a></p><p>左移运算符（&lt;&lt;）规则：<br>3 &lt;&lt; 2，则是将数字3左移2位 &#x3D; 3 * 2^2 &#x3D; 12<br>在数字没有溢出的前提下，对于正数和负数，左移一位都相当于乘以2的1次方，左移n位就相当于乘以2的n次方。<br>右移运算符（&gt;&gt;）规则：<br>右移一位相当于除2，右移n位相当于除以2的n次方。</p><h3 id="完全二叉树方法"><a href="#完全二叉树方法" class="headerlink" title="完全二叉树方法"></a>完全二叉树方法</h3><p>时间复杂度：O(logn *logn)<br>空间复杂度 O(logn)</p><ul><li>终止条件：<ol><li>root是none return 0 </li><li>当计算的只遍历左边二叉树和只遍历右边二叉树的长度是一样的时候return 2**k - 1（这个k从1开始计算）</li></ol></li><li>单层遍历<ol><li>初始四个参数一个是left被赋值成root.left和left长度的count</li><li>一个是right被赋值成root.right和right的长度的count</li><li>一直遍历left和right求出长度</li><li>单层回归逻辑还是左右中，中为+1</li></ol></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countNodes</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left_len = <span class="number">1</span></span><br><span class="line">        right_len = <span class="number">1</span></span><br><span class="line">        left = root.left</span><br><span class="line">        right = root.right</span><br><span class="line">        <span class="keyword">while</span> left != <span class="literal">None</span>:<span class="comment">#求左子树深度</span></span><br><span class="line">            left_len += <span class="number">1</span></span><br><span class="line">            left = left.left</span><br><span class="line">        <span class="keyword">while</span> right != <span class="literal">None</span>:<span class="comment">#求右子树深度</span></span><br><span class="line">            right_len += <span class="number">1</span></span><br><span class="line">            right = right.right</span><br><span class="line">        <span class="keyword">if</span> left_len == right_len: <span class="keyword">return</span> <span class="number">2</span>**left_len - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.countNodes(root.left) + self.countNodes(root.right) + <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树专题2</title>
      <link href="/2022/12/25/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%982/"/>
      <url>/2022/12/25/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%982/</url>
      
        <content type="html"><![CDATA[<h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a>102. 二叉树的层序遍历</h2><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">https://leetcode.cn/problems/binary-tree-level-order-traversal/</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>利用队列</li><li>重点是要用size记录每层的queue的长度</li><li>cur指向当前pop的节点然后当cur.left不为空加入到queue当cur.right不为空加入到queue</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        queue.append(root)</span><br><span class="line">        cur = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            result = []</span><br><span class="line">            <span class="keyword">while</span> size:</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                result.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left != <span class="literal">None</span>:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right != <span class="literal">None</span>:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">                size -= <span class="number">1</span></span><br><span class="line">            res.append(result)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a>226. 翻转二叉树</h2><p><a href="https://leetcode.cn/problems/invert-binary-tree/description/">https://leetcode.cn/problems/invert-binary-tree/description/</a></p><h3 id="深度优先遍历递归（前序和后序都可以，目前只提供了前序）"><a href="#深度优先遍历递归（前序和后序都可以，目前只提供了前序）" class="headerlink" title="深度优先遍历递归（前序和后序都可以，目前只提供了前序）"></a>深度优先遍历递归（前序和后序都可以，目前只提供了前序）</h3><ul><li>前序和后序都可以做</li><li>中序遍历回产生重复交换</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root.left, root.right = root.right, root.left</span><br><span class="line">        self.invertTree(root.left)</span><br><span class="line">        self.invertTree(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h3 id="深度优先遍历迭代-（前序和后序都可以，目前只提供了前序）"><a href="#深度优先遍历迭代-（前序和后序都可以，目前只提供了前序）" class="headerlink" title="深度优先遍历迭代 （前序和后序都可以，目前只提供了前序）"></a>深度优先遍历迭代 （前序和后序都可以，目前只提供了前序）</h3><ul><li>和前序一样，当栈不是空的就从栈中pop出来就交换</li><li>如果cur.left存在就加入栈中</li><li>如果cur.right存在就加入栈中</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        stack = []</span><br><span class="line">        stack.append(root)</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            cur = stack.pop()</span><br><span class="line">            cur.left, cur.right = cur.right, cur.left</span><br><span class="line">            <span class="keyword">if</span> cur.left != <span class="literal">None</span>:</span><br><span class="line">                stack.append(cur.left)</span><br><span class="line">            <span class="keyword">if</span> cur.right != <span class="literal">None</span>:</span><br><span class="line">                stack.append(cur.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h3 id="广度优先遍历迭代"><a href="#广度优先遍历迭代" class="headerlink" title="广度优先遍历迭代"></a>广度优先遍历迭代</h3><ul><li>(queue记录)同样利用size记录每层</li><li>当queue不是空的时候，记录size，当size不是空的时候就pop出来然后交换pop出来的节点left和right</li><li>之后cur.left不是空就加入，cur.right不是空就加入</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="keyword">while</span> size:</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                cur.left, cur.right = cur.right, cur.left</span><br><span class="line">                <span class="keyword">if</span> cur.left != <span class="literal">None</span>:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right != <span class="literal">None</span>:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">                size -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h2><p><a href="https://leetcode.cn/problems/symmetric-tree/">https://leetcode.cn/problems/symmetric-tree/</a></p><h3 id="递归（可以看成是后序）"><a href="#递归（可以看成是后序）" class="headerlink" title="递归（可以看成是后序）"></a>递归（可以看成是后序）</h3><ol><li>确定函数参数和返回值：compare(left,right) 返回值是boolean</li><li>终止条件四个：需要最后判断val，因为会出现nontype问题</li></ol><ul><li>左孩子空右孩子不是空 - False</li><li>左孩子不是空右孩子是空 - False</li><li>左孩子和右孩子都是空 - True</li><li>左孩子和右孩子的val值不一样 - False</li></ul><ol start="3"><li>判断outside是compare左节点的左边后右节点的右边</li><li>判断inside compare左节点的右边和右节点的左边</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">return</span> self.compare(root.left,root.right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compare</span>(<span class="params">self,left,right</span>):</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> left == <span class="literal">None</span> <span class="keyword">and</span> right != <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> left != <span class="literal">None</span> <span class="keyword">and</span> right == <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> left == <span class="literal">None</span> <span class="keyword">and</span> right == <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> left.val != right.val: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment">#左右中或者右左中</span></span><br><span class="line">        outside = self.compare(left.left,right.right)</span><br><span class="line">        inside = self.compare(left.right,right.left)</span><br><span class="line">        <span class="keyword">return</span> outside <span class="keyword">and</span> inside</span><br></pre></td></tr></table></figure><h3 id="迭代-（使用队列）"><a href="#迭代-（使用队列）" class="headerlink" title="迭代 （使用队列）"></a>迭代 （使用队列）</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul><li>利用队列先判断根节点是不是none</li><li>queue再进行append左节点和右节点</li><li>进入while循环当queue不是空的时候停止</li><li>pop出来两个节点进行比较</li><li>如果都是none的话就continue，因为到最后queue里面存放的全都是none的节点</li><li>其他就是和上面的思路一样左右节点一个为空return false</li><li>左右节点的值不一样return false</li><li>遍历完成return true</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root.left)</span><br><span class="line">        queue.append(root.right)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            pop1 = queue.popleft()</span><br><span class="line">            pop2 = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> pop1 == <span class="literal">None</span> <span class="keyword">and</span> pop2 == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> pop1 == <span class="literal">None</span> <span class="keyword">and</span> pop2 != <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> pop1 != <span class="literal">None</span> <span class="keyword">and</span> pop2 == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> pop1.val != pop2.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            queue.append(pop1.left)</span><br><span class="line">            queue.append(pop2.right)</span><br><span class="line">            queue.append(pop1.right)</span><br><span class="line">            queue.append(pop2.left)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树专题1</title>
      <link href="/2022/12/24/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%981/"/>
      <url>/2022/12/24/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%981/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树理论基础"><a href="#二叉树理论基础" class="headerlink" title="二叉树理论基础"></a>二叉树理论基础</h2><h3 id="二叉树种类"><a href="#二叉树种类" class="headerlink" title="二叉树种类"></a>二叉树种类</h3><h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><ol><li><strong>每层的节点数都达到最大值</strong></li><li><strong>如果这有k层，那么总节点数是(2^k) - 1,那么就是满二叉树</strong></li></ol><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p><strong>简单点的定义</strong>：除了最后一层，其他每层的节点数量都是满的，并且在最后一层所有的节点都是集中在这一层的最左边的位置</p><p>假设深度有h层，除了最后一层h层以外，其他层（1-h-1）都是满节点，然后最后一层都集中在靠左的位置。</p><p><strong>优先级队列是个堆，所以就是完全二叉树</strong></p><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><ul><li>有数值并且有序</li><li>可以不是满二叉树也不是完全二叉树</li><li>当左子树不是空时，左子树子节点 &lt; 根节点</li><li>当右子树不是空时，右子树子节点 &lt; 根节点</li></ul><h4 id="平衡二叉搜索树-AVL"><a href="#平衡二叉搜索树-AVL" class="headerlink" title="平衡二叉搜索树 AVL"></a>平衡二叉搜索树 AVL</h4><p><strong>性质</strong></p><ol><li>一个空树</li><li>或者左右两个子树的高度差绝对值不超过一，并且左右两个子树都是平衡二叉树</li></ol><h3 id="二叉树储存方式"><a href="#二叉树储存方式" class="headerlink" title="二叉树储存方式"></a>二叉树储存方式</h3><h4 id="链式储存（指针）"><a href="#链式储存（指针）" class="headerlink" title="链式储存（指针）"></a>链式储存（指针）</h4><ul><li>通过指针把分布在各个地址上面的节点串联到一起</li><li>每一个节点都有三个位置，一个是存放value,一个是存放左指针，一个是存放右指针</li></ul><h4 id="顺序储存（数组）"><a href="#顺序储存（数组）" class="headerlink" title="顺序储存（数组）"></a>顺序储存（数组）</h4><ul><li>内存是连续的</li><li>从上到下从左到右的顺序是下标，根节点是0</li><li>树的节点储存的是值</li></ul><p><strong>对于遍历二叉树数组，当父节点下标是i,左孩子就是 2 * i + 1<br>右孩子就是 2 * i + 2，i从0开始</strong></p><h3 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h3><h4 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h4><ul><li>前序遍历（递归法，迭代法） 中左右（是指整个的左子树和右子树）</li><li>中序遍历（递归法，迭代法） 左中右</li><li>后序遍历（递归法，迭代法） 左右中</li></ul><p>可以利用栈使用非递归的方式来实现</p><h4 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h4><ul><li>层次遍历（迭代法）</li></ul><p>可以利用队列的先进先出来实现</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>: </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.value = value</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">      <span class="built_in">this</span>.val = val;</span><br><span class="line">      <span class="built_in">this</span>.left = left;</span><br><span class="line">      <span class="built_in">this</span>.right = right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h2><p>递归遍历的三个条件</p><ol><li>递归函数的参数和返回值</li><li>终止条件</li><li>单层递归逻辑</li></ol><p>递归逻辑：每一次调用，都会把函数的局部变量，返回地址，参数值等参数压入栈中，然后递归返回会从栈顶弹出是一次递归的所有存入参数。</p><h3 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a>144. 二叉树的前序遍历</h3><p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">https://leetcode.cn/problems/binary-tree-preorder-traversal/</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        self.pre(root,res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pre</span>(<span class="params">self,node,result</span>):</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        result.append(node.val)</span><br><span class="line">        self.pre(node.left,result)</span><br><span class="line">        self.pre(node.right, result)</span><br></pre></td></tr></table></figure><h3 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a>145. 二叉树的后序遍历</h3><p><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">https://leetcode.cn/problems/binary-tree-postorder-traversal/</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        self.post(root,res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">post</span>(<span class="params">self,node,res</span>):</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.post(node.left,res)</span><br><span class="line">        self.post(node.right,res )</span><br><span class="line">        res.append(node.val)</span><br></pre></td></tr></table></figure><h3 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a>94. 二叉树的中序遍历</h3><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">https://leetcode.cn/problems/binary-tree-inorder-traversal/</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        self.inorder(root,res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">self,node,res</span>):</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.inorder(node.left,res)</span><br><span class="line">        res.append(node.val)</span><br><span class="line">        self.inorder(node.right,res)</span><br></pre></td></tr></table></figure><h2 id="二叉树的迭代法模拟递归遍历（利用栈）"><a href="#二叉树的迭代法模拟递归遍历（利用栈）" class="headerlink" title="二叉树的迭代法模拟递归遍历（利用栈）"></a>二叉树的迭代法模拟递归遍历（利用栈）</h2><p>只有pop掉才会继续append</p><h3 id="144-二叉树的前序遍历-1"><a href="#144-二叉树的前序遍历-1" class="headerlink" title="144. 二叉树的前序遍历"></a>144. 二叉树的前序遍历</h3><p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">https://leetcode.cn/problems/binary-tree-preorder-traversal/</a></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>中左右变成了<strong>中右左</strong></li><li>所以出栈顺序变成了中左右</li></ul><ol><li>先添加root节点到stack中</li><li>当栈不是空的时候，利用指针记录pop出来的元素</li><li>然后加入到result中</li><li>判断pop出来的元素是否有右节点，如果有加到栈中</li><li>判断pop出来的元素是否有左节点，如果有加到栈中</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        stack = collections.deque()</span><br><span class="line">        stack.append(root)</span><br><span class="line">        node = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> (stack):</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">None</span>:</span><br><span class="line">                res.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.right != <span class="literal">None</span>:</span><br><span class="line">                    stack.append(node.right)</span><br><span class="line">                <span class="keyword">if</span> node.left != <span class="literal">None</span>:</span><br><span class="line">                    stack.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="145-二叉树的后序遍历-1"><a href="#145-二叉树的后序遍历-1" class="headerlink" title="145. 二叉树的后序遍历"></a>145. 二叉树的后序遍历</h3><p><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">https://leetcode.cn/problems/binary-tree-postorder-traversal/</a></p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul><li>左右中 </li><li>入栈顺序是中左右 所有出来是中右左，然后reverse是左右中</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        stack = collections.deque()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        stack.append(root)</span><br><span class="line">        node = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left != <span class="literal">None</span>:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right != <span class="literal">None</span>:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">        res.reverse()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="94-二叉树的中序遍历-1"><a href="#94-二叉树的中序遍历-1" class="headerlink" title="94. 二叉树的中序遍历"></a>94. 二叉树的中序遍历</h3><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">https://leetcode.cn/problems/binary-tree-inorder-traversal/</a></p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>左中右</p><ul><li>因为遍历的node和存储到stack的node不一样</li><li>所以引入遍历指针cur指向当前的root节点</li><li><strong>当cur指针节点不是空或者stack不是空的时候才会停止</strong></li></ul><ol><li>if 当前cur指针不是空的话就push到栈中<br>cur指针继续指向下一个left节点</li><li>if cur指针是空的话就从栈里pop出来 让cur指针回指pop出来的节点，记录当前节点的val到result里然后让指针指向cur.right</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        cur = root</span><br><span class="line">        stack = collections.deque()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span> <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> cur != <span class="literal">None</span>:</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = stack.pop()</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="二叉树的统一迭代法"><a href="#二叉树的统一迭代法" class="headerlink" title="二叉树的统一迭代法"></a>二叉树的统一迭代法</h2><p>搁置中</p>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈与队列专题3</title>
      <link href="/2022/12/22/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%93%E9%A2%983/"/>
      <url>/2022/12/22/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%93%E9%A2%983/</url>
      
        <content type="html"><![CDATA[<h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a>239. 滑动窗口最大值</h2><p><a href="https://leetcode.cn/problems/sliding-window-maximum/">https://leetcode.cn/problems/sliding-window-maximum/</a></p><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回 滑动窗口中的最大值 。</p><p> </p><p>示例 1：</p><p>输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3<br>输出：[3,3,5,5,6,7]<br>解释：<br>滑动窗口的位置           —- 最大值</p><hr><p>[1  3  -1] -3  5  3  6  7       —- 3<br> 1 [3  -1  -3] 5  3  6  7       —- 3<br> 1  3 [-1  -3  5] 3  6  7       —- 5<br> 1  3  -1 [-3  5  3] 6  7       —- 5<br> 1  3  -1  -3 [5  3  6] 7       —- 6<br> 1  3  -1  -3  5 [3  6  7]      —- 7<br>示例 2：</p><p>输入：nums &#x3D; [1], k &#x3D; 1<br>输出：[1] </p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104<br>1 &lt;&#x3D; k &lt;&#x3D; nums.length</p><h3 id="思路（单调队列用deque实现）"><a href="#思路（单调队列用deque实现）" class="headerlink" title="思路（单调队列用deque实现）"></a>思路（单调队列用deque实现）</h3><p>5 - 3 + 1 &#x3D; 3 用角标的差值查看数量 [3,4,5]</p><ul><li>滑动数组的题目最适合单调队列</li><li><strong>创建deque存角标为后面的滑动数组保证在提供的k size内<br>如果当前遍历的i - 队列最开头存放的角标 + 1 &gt; 滑动窗口内的元素数量 则popleft() 把左边的元素pop掉保证滑动窗口元素数量一致</strong></li><li>另外单调队列保证窗口头部元素永远是最大的，利用while当当前要遍历的元素大于等于队尾元素的时候pop()掉尾部元素。同时要保证这个deque不是空的</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            <span class="keyword">while</span> queue <span class="keyword">and</span> nums[i] &gt;= nums[queue[-<span class="number">1</span>]]:</span><br><span class="line">                queue.pop()</span><br><span class="line">            queue.append(i)</span><br><span class="line">        res.append(nums[queue[<span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k,<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> i - queue[<span class="number">0</span>] == k:</span><br><span class="line">                queue.popleft()</span><br><span class="line">            <span class="keyword">while</span> queue <span class="keyword">and</span> nums[i] &gt;= nums[queue[-<span class="number">1</span>]]:</span><br><span class="line">                queue.pop()</span><br><span class="line">            queue.append(i)</span><br><span class="line">            res.append(nums[queue[<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a>347. 前 K 个高频元素</h2><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/">https://leetcode.cn/problems/top-k-frequent-elements/</a></p><p>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。</p><p>示例 1:</p><p>输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2<br>输出: [1,2]<br>示例 2:</p><p>输入: nums &#x3D; [1], k &#x3D; 1<br>输出: [1]</p><p>提示：<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>k 的取值范围是 [1, 数组中不相同的元素的个数]<br>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的</p><h3 id="python-heapq-库"><a href="#python-heapq-库" class="headerlink" title="python heapq 库"></a>python heapq 库</h3><p><a href="https://www.geeksforgeeks.org/heap-queue-or-heapq-in-python/">https://www.geeksforgeeks.org/heap-queue-or-heapq-in-python/</a><br>提供了小根堆堆方法和基本操作</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">方法</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line">heapq.heapify(iterable)：把iterable换成heap结构</span><br><span class="line">heapq.heappush(heap, ele)</span><br><span class="line">heapq.heappop(heap):remove <span class="keyword">and</span> <span class="keyword">return</span> the smallest element <span class="keyword">from</span> the heap</span><br><span class="line"></span><br><span class="line">**如果push的是<span class="built_in">tuple</span>的话会根据第一个element 进行排序</span><br><span class="line">pop出来以后heappop(<span class="built_in">tuple</span>/<span class="built_in">list</span>)[<span class="number">0</span>或者<span class="number">1</span>]**</span><br><span class="line"></span><br><span class="line">heapq.nlargest(k, iterable, key = fun)</span><br><span class="line">heapq.nsmallest(k, iterable, key = fun)</span><br><span class="line"></span><br><span class="line">首先定义heap heap = []</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"> </span><br><span class="line"><span class="comment"># initializing list</span></span><br><span class="line">li = [<span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># using heapify to convert list into heap</span></span><br><span class="line">heapq.heapify(li)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># printing created heap</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The created heap is : &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(li))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># using heappush() to push elements into heap</span></span><br><span class="line"><span class="comment"># pushes 4</span></span><br><span class="line">heapq.heappush(li, <span class="number">4</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># printing modified heap</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The modified heap after push is : &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(li))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># using heappop() to pop smallest element</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The popped and smallest element is : &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(heapq.heappop(li))</span><br><span class="line">The created heap <span class="keyword">is</span> : [<span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>]</span><br><span class="line">The modified heap after push <span class="keyword">is</span> : [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br><span class="line">The popped <span class="keyword">and</span> smallest element <span class="keyword">is</span> : <span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span>(重点，pop是pop smallest的元素)</span><br><span class="line"><span class="number">7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># importing &quot;heapq&quot; to implement heap queue</span></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="comment"># initializing list</span></span><br><span class="line">li1 = [<span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># using heapify() to convert list into heap</span></span><br><span class="line">heapq.heapify(li1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># using nlargest to print 3 largest numbers</span></span><br><span class="line"><span class="comment"># prints 10, 9 and 8</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The 3 largest numbers in list are : &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(heapq.nlargest(<span class="number">3</span>, li1))</span><br><span class="line"></span><br><span class="line"><span class="comment"># using nsmallest to print 3 smallest numbers</span></span><br><span class="line"><span class="comment"># prints 1, 3 and 4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The 3 smallest numbers in list are : &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(heapq.nsmallest(<span class="number">3</span>, li1))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="思路（topk大用小根堆）"><a href="#思路（topk大用小根堆）" class="headerlink" title="思路（topk大用小根堆）"></a>思路（topk大用小根堆）</h3><p>一般我们说 topK 问题，就可以用大顶堆或小顶堆来实现，<br>最大的 K 个：小顶堆<br>最小的 K 个：大顶堆</p><p><strong>从 排序的O(nlogn)优化成 O(nlogk) k表示里面存放的元素</strong></p><p>1.先创建map生成每个key对应的频率<br>2.再利用heapq创建小根堆进行push和pop操作，维持只有k个数的小根堆<br>3.因为生成的是小根堆需要pop出来的元素也是从小到大进行pop，所以需要先创建一个赋值好的全是0 size是k的list，然后从后面往前进行遍历重新赋值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">topKFrequent</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">        dict_ = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            dict_[i] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        heap = []</span><br><span class="line">        <span class="keyword">for</span> i,j <span class="keyword">in</span> dict_.items():</span><br><span class="line">            heapq.heappush(heap,(j,i))</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(heap) &gt; k:</span><br><span class="line">                heapq.heappop(heap)</span><br><span class="line">        result = [<span class="number">0</span>] * k</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            result[i] = heapq.heappop(heap)[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
          <category> 栈与队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈与队列专题2</title>
      <link href="/2022/12/21/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%93%E9%A2%982/"/>
      <url>/2022/12/21/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%93%E9%A2%982/</url>
      
        <content type="html"><![CDATA[<h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h2><p><a href="https://leetcode.cn/problems/valid-parentheses/">https://leetcode.cn/problems/valid-parentheses/</a></p><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>每个右括号都有一个对应的相同类型的左括号。<br>示例 1：</p><p>输入：s &#x3D; “()”<br>输出：true<br>示例 2：</p><p>输入：s &#x3D; “()[]{}”<br>输出：true<br>示例 3：</p><p>输入：s &#x3D; “(]”<br>输出：false</p><h3 id="（思路）利用栈"><a href="#（思路）利用栈" class="headerlink" title="（思路）利用栈"></a>（思路）利用栈</h3><ul><li>挺难想的一道题 利用python的list当作栈使用</li><li>遇到对应左括号添加右括号 （到遍历右括号遇到相同的就pop出去）</li><li>如果左括号遍历，遍历右括号分三种情况</li></ul><ol><li>stack里面是空的说明右括号多出来</li><li>stack最后一个元素和当前的遍历的括号不一样</li><li>遍历完成的时候stack不是空的说明有左括号多出来了</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        dict_ = &#123;<span class="string">&#x27;(&#x27;</span>:<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;&#123;&#x27;</span>:<span class="string">&#x27;&#125;&#x27;</span>,<span class="string">&#x27;[&#x27;</span>:<span class="string">&#x27;]&#x27;</span>&#125;</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                stack.append(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> i == <span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">                stack.append(<span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> i == <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">                stack.append(<span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> stack <span class="keyword">or</span> i != stack[-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.pop()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047. 删除字符串中的所有相邻重复项"></a>1047. 删除字符串中的所有相邻重复项</h2><p><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/</a></p><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p><p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p><p>示例：</p><p>输入：”abbaca”<br>输出：”ca”<br>解释：<br>例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>简单题，push到栈中然后遇到和stack的顶端元素一样的就pop()</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> stack <span class="keyword">and</span> stack[-<span class="number">1</span>] == i:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(stack)</span><br></pre></td></tr></table></figure><h2 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a>150. 逆波兰表达式求值</h2><p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">https://leetcode.cn/problems/evaluate-reverse-polish-notation/</a></p><p>根据 逆波兰表示法，求表达式的值。</p><p>有效的算符包括 +、-、*、&#x2F; 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><p>注意 两个整数之间的除法只保留整数部分。</p><p>可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p><p> </p><p>示例 1：</p><p>输入：tokens &#x3D; [“2”,”1”,”+”,”3”,”*”]<br>输出：9<br>解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) &#x3D; 9<br>示例 2：</p><p>输入：tokens &#x3D; [“4”,”13”,”5”,”&#x2F;“,”+”]<br>输出：6<br>解释：该算式转化为常见的中缀算术表达式为：(4 + (13 &#x2F; 5)) &#x3D; 6<br>示例 3：</p><p>输入：tokens &#x3D; [“10”,”6”,”9”,”3”,”+”,”-11”,”<em>“,”&#x2F;“,”</em>“,”17”,”+”,”5”,”+”]<br>输出：22<br>解释：该算式转化为常见的中缀算术表达式为：<br>  ((10 * (6 &#x2F; ((9 + 3) * -11))) + 17) + 5<br>&#x3D; ((10 * (6 &#x2F; (12 * -11))) + 17) + 5<br>&#x3D; ((10 * (6 &#x2F; -132)) + 17) + 5<br>&#x3D; ((10 * 0) + 17) + 5<br>&#x3D; (0 + 17) + 5<br>&#x3D; 17 + 5<br>&#x3D; 22</p><p>逆波兰表达式：</p><p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p><p>平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。<br>该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。<br>逆波兰表达式主要有以下两个优点：</p><p>去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。<br><strong>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</strong></p><h3 id="python-x2F-x2F-x2F-round-int-的区别"><a href="#python-x2F-x2F-x2F-round-int-的区别" class="headerlink" title="python &#x2F;&#x2F; , &#x2F; , round , int()的区别"></a>python &#x2F;&#x2F; , &#x2F; , round , int()的区别</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">// 是整除的意思会向小取整</span><br><span class="line"><span class="built_in">int</span> 是向<span class="number">0</span>取整</span><br><span class="line"><span class="built_in">round</span> 四舍五入</span><br><span class="line"><span class="keyword">import</span> math </span><br><span class="line">math.ceil() 向上取整</span><br><span class="line">math.floor()向下取整</span><br><span class="line"></span><br><span class="line"><span class="number">5</span> / <span class="number">2</span>     输出： <span class="number">2.5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>(<span class="number">5</span>/<span class="number">2</span>)  输出：  <span class="number">2</span></span><br><span class="line"><span class="number">5</span> // <span class="number">2</span>    输出：  <span class="number">2</span></span><br><span class="line"></span><br><span class="line">-<span class="number">5</span> / <span class="number">2</span>    输出： -<span class="number">2.5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>(-<span class="number">5</span>/<span class="number">2</span>) 输出： -<span class="number">2</span></span><br><span class="line">-<span class="number">5</span> // <span class="number">2</span>   输出： -<span class="number">3</span> 重要！！</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="python-eval-表达式"><a href="#python-eval-表达式" class="headerlink" title="python eval 表达式"></a>python eval 表达式</h3><p><a href="https://www.programiz.com/python-programming/methods/built-in/eval">https://www.programiz.com/python-programming/methods/built-in/eval</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(expression, <span class="built_in">globals</span>=<span class="literal">None</span>, <span class="built_in">locals</span>=<span class="literal">None</span>)</span><br><span class="line">expression: A String, that will be evaluated <span class="keyword">as</span> Python code</span><br><span class="line">number = <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># eval performs the multiplication passed as argument</span></span><br><span class="line">square_number = <span class="built_in">eval</span>(<span class="string">&#x27;number * number&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(square_number)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output: 81</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&#x27;x + 1&#x27;</span>)) ---output: <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>把 加减乘除 放到set中，因为set的查询是O(1)</li><li>利用stack 遇到不是加减乘除就加进去</li><li>遇到加减乘除就pop出来倒数最后两个和符号进行操作</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">evalRPN</span>(<span class="params">self, tokens: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        c = &#123;<span class="string">&quot;+&quot;</span>, <span class="string">&quot;-&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="string">&quot;/&quot;</span>&#125;</span><br><span class="line">        stack = []</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> c:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                a = <span class="built_in">int</span>(stack.pop())</span><br><span class="line">                b = <span class="built_in">int</span>(stack.pop())</span><br><span class="line">                <span class="keyword">if</span> i == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    res = b * a</span><br><span class="line">                <span class="keyword">elif</span> i == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    res = b - a</span><br><span class="line">                <span class="keyword">elif</span> i == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    res = b + a</span><br><span class="line">                <span class="keyword">elif</span> i == <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    <span class="comment">#加int向0取整</span></span><br><span class="line">                    res = <span class="built_in">int</span>(b / a)</span><br><span class="line">                stack.append(<span class="built_in">str</span>(res))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(stack.pop())</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
          <category> 栈与队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python list操作</title>
      <link href="/2022/12/21/python%E5%9F%BA%E7%A1%80/python-list%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/12/21/python%E5%9F%BA%E7%A1%80/python-list%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="python-list-包含的方法-amp-函数"><a href="#python-list-包含的方法-amp-函数" class="headerlink" title="python list 包含的方法&amp; 函数"></a>python list 包含的方法&amp; 函数</h2><p>参考：<br><a href="https://www.runoob.com/python/python-lists.html">https://www.runoob.com/python/python-lists.html</a><br>and <a href="https://blog.csdn.net/qq_41500249/article/details/106244810">https://blog.csdn.net/qq_41500249/article/details/106244810</a> and<br><a href="https://realpython.com/python-reverse-list/">https://realpython.com/python-reverse-list/</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">---函数</span><br><span class="line"><span class="number">1.</span> <span class="built_in">list</span>()将seq转换成<span class="built_in">list</span></span><br><span class="line"><span class="number">2.</span> <span class="built_in">len</span>()</span><br><span class="line"><span class="number">3.</span> <span class="built_in">max</span>()</span><br><span class="line"><span class="number">4.</span> <span class="built_in">min</span>()</span><br><span class="line">---方法</span><br><span class="line"><span class="built_in">list</span>.append()</span><br><span class="line"><span class="built_in">list</span>.copy()</span><br><span class="line"><span class="built_in">list</span>.clear(): remove <span class="built_in">all</span> elements</span><br><span class="line"><span class="built_in">list</span>.insert(pos, elmnt)</span><br><span class="line"><span class="built_in">list</span>.count()</span><br><span class="line"><span class="built_in">list</span>.extend(seq) seq:列表元素</span><br><span class="line"><span class="built_in">list</span>.index(x[, start[, end]])</span><br><span class="line"><span class="built_in">list</span>.pop([index=-<span class="number">1</span>]) 默认index是-<span class="number">1</span></span><br><span class="line"><span class="built_in">list</span>.remove(obj) 该方法没有返回值但是会移除列表中的某个值的第一个匹配项。</span><br><span class="line"><span class="built_in">list</span>.reverse() 反向排序</span><br><span class="line">The reverse() method doesn<span class="string">&#x27;t return any value. It updates the existing list.</span></span><br><span class="line"><span class="string">reversed():If you want to create a reversed copy of an existing list in Python, then you can use reversed(). With a list as an argument, reversed() returns an iterator that yields items in reverse order:</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&gt;&gt;&gt; reversed_digits = reversed(digits)</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; reversed_digits</span></span><br><span class="line"><span class="string">&lt;list_reverseiterator object at 0x7fca9999e790&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&gt;&gt;&gt; list(reversed_digits)</span></span><br><span class="line"><span class="string">[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">list.sort(cmp=None, key=None, reverse=False)</span></span><br><span class="line"><span class="string">A list also has the sort() method which performs the same way as sorted(). The only difference is that the sort() method doesn&#x27;</span>t <span class="keyword">return</span> <span class="built_in">any</span> value <span class="keyword">and</span> changes the original <span class="built_in">list</span>.</span><br><span class="line">key代表迭代对象中的某个属性，如某个元素的下标</span><br><span class="line"><span class="keyword">lambda</span> [arg1 [,arg2,…argn]]:expression</span><br><span class="line">a = [(<span class="string">&#x27;b&#x27;</span>, <span class="number">4</span>), (<span class="string">&#x27;a&#x27;</span>, <span class="number">12</span>), (<span class="string">&#x27;d&#x27;</span>, <span class="number">7</span>), (<span class="string">&#x27;h&#x27;</span>, <span class="number">6</span>), (<span class="string">&#x27;j&#x27;</span>, <span class="number">3</span>)]</span><br><span class="line">a.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(a)&lt;br&gt;&gt;&gt;&gt;[(<span class="string">&#x27;a&#x27;</span>, <span class="number">12</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">4</span>), (<span class="string">&#x27;d&#x27;</span>, <span class="number">7</span>), (<span class="string">&#x27;h&#x27;</span>, <span class="number">6</span>), (<span class="string">&#x27;j&#x27;</span>, <span class="number">3</span>)]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈与队列专题1</title>
      <link href="/2022/12/21/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%93%E9%A2%981/"/>
      <url>/2022/12/21/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%93%E9%A2%981/</url>
      
        <content type="html"><![CDATA[<h2 id="栈与队列基础知识"><a href="#栈与队列基础知识" class="headerlink" title="栈与队列基础知识"></a>栈与队列基础知识</h2><ul><li>stack(栈)：先进后出</li><li>Queue(队列)：先进先出</li></ul><h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a>232. 用栈实现队列</h2><p><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">https://leetcode.cn/problems/implement-queue-using-stacks/</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>python way 检查一个list是不是空，如果是空意味着0,会返回false,所以 if not a: 这个就可以检查是不是空</li><li>两个栈一个进一个出，要保证进的都是空了以后才可以对出的栈进行pop操作</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.stack_in = []</span><br><span class="line">        self.stack_out = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.stack_in.append(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> self.stack_out:</span><br><span class="line">            <span class="keyword">return</span> self.stack_out.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> self.stack_in:</span><br><span class="line">                a = self.stack_in.pop()</span><br><span class="line">                self.stack_out.append(a)</span><br><span class="line">            <span class="keyword">return</span> self.stack_out.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        a = self.pop()</span><br><span class="line">        self.stack_out.append(a)</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.stack_in <span class="keyword">and</span> <span class="keyword">not</span> self.stack_out</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyQueue()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.peek()</span></span><br><span class="line"><span class="comment"># param_4 = obj.empty()</span></span><br></pre></td></tr></table></figure><h2 id="Deque的用法"><a href="#Deque的用法" class="headerlink" title="Deque的用法"></a>Deque的用法</h2><p><a href="https://www.geeksforgeeks.org/deque-in-python/">https://www.geeksforgeeks.org/deque-in-python/</a><br>deque提供O(1)的append和pop()相比较于list<br>相关操作:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">append()</span><br><span class="line">appendleft()</span><br><span class="line">pop()</span><br><span class="line">popleft()</span><br></pre></td></tr></table></figure><h2 id="225-用队列实现栈-只用一个队列"><a href="#225-用队列实现栈-只用一个队列" class="headerlink" title="225. 用队列实现栈(只用一个队列)"></a>225. 用队列实现栈(只用一个队列)</h2><p><a href="https://leetcode.cn/problems/implement-stack-using-queues/">https://leetcode.cn/problems/implement-stack-using-queues/</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>利用deque的O(1)的性质</li><li>对于pop操作留下最后一个数每次都popleft然后append到队尾</li><li>top操作直接返回deque的最后一位</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.que = collections.deque()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.que.append(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.que) - <span class="number">1</span>):</span><br><span class="line">            self.que.append(self.que.popleft())</span><br><span class="line">        <span class="keyword">return</span> self.que.popleft()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.que[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.que</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.empty()</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
          <category> 栈与队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串专题2</title>
      <link href="/2022/12/20/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%93%E9%A2%982/"/>
      <url>/2022/12/20/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%93%E9%A2%982/</url>
      
        <content type="html"><![CDATA[<h1 id="KMP算法（暂跳过）"><a href="#KMP算法（暂跳过）" class="headerlink" title="KMP算法（暂跳过）"></a>KMP算法（暂跳过）</h1><h2 id="28-找出字符串中第一个匹配项的下标"><a href="#28-找出字符串中第一个匹配项的下标" class="headerlink" title="28. 找出字符串中第一个匹配项的下标"></a>28. 找出字符串中第一个匹配项的下标</h2><p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/</a></p><h2 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459. 重复的子字符串"></a>459. 重复的子字符串</h2><p><a href="https://leetcode.cn/problems/repeated-substring-pattern/">https://leetcode.cn/problems/repeated-substring-pattern/</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串专题1</title>
      <link href="/2022/12/19/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%93%E9%A2%981/"/>
      <url>/2022/12/19/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%93%E9%A2%981/</url>
      
        <content type="html"><![CDATA[<h2 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a>344. 反转字符串</h2><p><a href="https://leetcode.cn/problems/reverse-string/">https://leetcode.cn/problems/reverse-string/</a></p><h3 id="相向双指针"><a href="#相向双指针" class="headerlink" title="相向双指针"></a>相向双指针</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseString</span>(<span class="params">self, s: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        j = n - <span class="number">1</span></span><br><span class="line">        temp = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            s[i], s[j] = s[j], s[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="541-反转字符串-II"><a href="#541-反转字符串-II" class="headerlink" title="541. 反转字符串 II"></a>541. 反转字符串 II</h2><p><a href="https://leetcode.cn/problems/reverse-string-ii/">https://leetcode.cn/problems/reverse-string-ii/</a></p><h3 id="思路（反转字符串相向双指针-条件）"><a href="#思路（反转字符串相向双指针-条件）" class="headerlink" title="思路（反转字符串相向双指针+条件）"></a>思路（反转字符串相向双指针+条件）</h3><ul><li>相当于 i 在前面 j 在后面 i + k-1，如果大于范围，就让 j 在数组的长度减一</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseStr</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        s = <span class="built_in">list</span>(s)</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="comment"># range(start,end,step)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n, <span class="number">2</span>* k):</span><br><span class="line">            j = i + k - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j &gt;= n:</span><br><span class="line">                j = n - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; j):</span><br><span class="line">                s[i], s[j] = s[j], s[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(s)</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a>剑指 Offer 05. 替换空格</h2><p><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">https://leetcode.cn/problems/ti-huan-kong-ge-lcof/</a></p><h3 id="暴力（最简单的想法）"><a href="#暴力（最简单的想法）" class="headerlink" title="暴力（最简单的想法）"></a>暴力（最简单的想法）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">replaceSpace</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        s = <span class="built_in">list</span>(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                s[i] = <span class="string">&#x27;%20&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(s)</span><br></pre></td></tr></table></figure><h3 id="extend数组（从后向前计算，同向双指针）"><a href="#extend数组（从后向前计算，同向双指针）" class="headerlink" title="extend数组（从后向前计算，同向双指针）"></a>extend数组（从后向前计算，同向双指针）</h3><ul><li>计算需要添加的格子的数量</li><li>从后向前计算：同向双指针，一个在原本的string末尾，一个在extend以后的数组的末尾</li><li>然后left指针遇到空格就对right指针进行赋值</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">replaceSpace</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">        ext_list = [<span class="number">0</span>] * <span class="number">2</span> * cnt</span><br><span class="line">        res = <span class="built_in">list</span>(s)</span><br><span class="line">        res.extend(ext_list)</span><br><span class="line">        l = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        r = <span class="built_in">len</span>(res) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> res[l] == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                res[r-<span class="number">2</span>:r+<span class="number">1</span>:<span class="number">1</span>] = <span class="string">&#x27;%20&#x27;</span></span><br><span class="line">                r -= <span class="number">3</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[r] = res[l]</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            l -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(res)</span><br></pre></td></tr></table></figure><h2 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151. 反转字符串中的单词"></a>151. 反转字符串中的单词</h2><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">https://leetcode.cn/problems/reverse-words-in-a-string/</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>很难写的一道题</li><li>在移除space的时候不额外用数组空间的话需要使用双指针</li><li>首先移除space 并且每一个单词添加一个空格 最后的的字符串就是分割的s[:slow]</li><li>其次反转整个字符串</li><li>然后反转每个单词</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">removeSpace</span>(<span class="params">s</span>):</span><br><span class="line">            s = <span class="built_in">list</span>(s)</span><br><span class="line">            slow = <span class="number">0</span></span><br><span class="line">            fast = <span class="number">0</span></span><br><span class="line">            <span class="comment"># python 用不了for loop对i 进行加减操作，只能用while</span></span><br><span class="line">            <span class="keyword">while</span> fast &lt; <span class="built_in">len</span>(s):</span><br><span class="line">                <span class="keyword">if</span> s[fast] != <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                    <span class="comment">#每隔一个单词加一个空格</span></span><br><span class="line">                    <span class="keyword">if</span> slow != <span class="number">0</span> :</span><br><span class="line">                        s[slow] = <span class="string">&#x27; &#x27;</span></span><br><span class="line">                        slow += <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 重点对于单个单词的处理</span></span><br><span class="line">                    <span class="keyword">while</span> fast &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[fast] != <span class="string">&#x27; &#x27;</span> :</span><br><span class="line">                        s[slow] = s[fast]</span><br><span class="line">                        slow += <span class="number">1</span></span><br><span class="line">                        fast += <span class="number">1</span></span><br><span class="line">                fast += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> s[:slow]</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">reverseString</span>(<span class="params">s</span>):</span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            j = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; j:</span><br><span class="line">                s[i], s[j] = s[j], s[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#&quot;  hello world  &quot;</span></span><br><span class="line">        s = removeSpace(s)</span><br><span class="line">        s = reverseString(s)</span><br><span class="line">        l =<span class="number">0</span></span><br><span class="line">        r =<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="comment"># print(&#x27;s[r]&#x27;,s[r])</span></span><br><span class="line">            <span class="keyword">while</span> r&lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[r] != <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line">            rever = r - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; rever:</span><br><span class="line">                s[l],s[rever] = s[rever], s[l]</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">                rever -= <span class="number">1</span></span><br><span class="line">            l = r + <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(s)</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-58-II-左旋转字符串"><a href="#剑指-Offer-58-II-左旋转字符串" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串"></a>剑指 Offer 58 - II. 左旋转字符串</h2><p><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/</a></p><h3 id="申请额外空间（最初想法）"><a href="#申请额外空间（最初想法）" class="headerlink" title="申请额外空间（最初想法）"></a>申请额外空间（最初想法）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseLeftWords</span>(<span class="params">self, s: <span class="built_in">str</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        l = []</span><br><span class="line">        s = <span class="built_in">list</span>(s)</span><br><span class="line">        last= s[:n]</span><br><span class="line">        first = s[n:]</span><br><span class="line">        l = first + last</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(l)</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseLeftWords</span>(<span class="params">self, s: <span class="built_in">str</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> s[n:] + s[<span class="number">0</span>:n]</span><br></pre></td></tr></table></figure><h3 id="不用额外空间"><a href="#不用额外空间" class="headerlink" title="不用额外空间"></a>不用额外空间</h3><ul><li>很难想到</li><li>先反转前n个</li><li>在反转后n个</li><li>再反转全部</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseLeftWords</span>(<span class="params">self, s: <span class="built_in">str</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">s,l,r</span>):</span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                s[l],s[r] = s[r], s[l]</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        s = <span class="built_in">list</span>(s)</span><br><span class="line">        s = reverse(s,<span class="number">0</span>,n - <span class="number">1</span>)</span><br><span class="line">        s = reverse(s,n,<span class="built_in">len</span>(s) -<span class="number">1</span>)</span><br><span class="line">        s = reverse(s,<span class="number">0</span>,<span class="built_in">len</span>(s) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(s)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希表专题2</title>
      <link href="/2022/12/18/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%93%88%E5%B8%8C%E8%A1%A8%E4%B8%93%E9%A2%982/"/>
      <url>/2022/12/18/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%93%88%E5%B8%8C%E8%A1%A8%E4%B8%93%E9%A2%982/</url>
      
        <content type="html"><![CDATA[<h2 id="454-四数相加-II"><a href="#454-四数相加-II" class="headerlink" title="454. 四数相加 II"></a>454. 四数相加 II</h2><p><a href="https://leetcode.cn/problems/4sum-ii/">https://leetcode.cn/problems/4sum-ii/</a></p><h4 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h4><p>肯定是四个for loops然后相加等于0 — 超出时间限制</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSumCount</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>], nums3: <span class="type">List</span>[<span class="built_in">int</span>], nums4: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> nums2:</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> nums3:</span><br><span class="line">                    <span class="keyword">for</span> l <span class="keyword">in</span> nums4:</span><br><span class="line">                        <span class="keyword">if</span> i + j + k + l == <span class="number">0</span>:</span><br><span class="line">                            res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="把四个for-loop变成两个for-loop-利用哈希表储存"><a href="#把四个for-loop变成两个for-loop-利用哈希表储存" class="headerlink" title="把四个for loop变成两个for loop(利用哈希表储存)"></a>把四个for loop变成两个for loop(利用哈希表储存)</h4><ul><li>先遍历前面两个数组然后利用dict储存起来，key是数组相加的值，value是值出现的次数</li><li>后面遍历两个for loop查询负的两个相加的值是否出现在前面创建的字典的key里面</li><li><strong>如果出现了就是加上之前存储字典里面出现的次数</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSumCount</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>], nums3: <span class="type">List</span>[<span class="built_in">int</span>], nums4: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dict_ =&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> nums2:</span><br><span class="line">                dict_[i + j] = dict_.get(i+j,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums3:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> nums4:</span><br><span class="line">                <span class="keyword">if</span> -(i+j) <span class="keyword">in</span> dict_.keys():</span><br><span class="line">                    res += dict_[-(i+j)]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a>383. 赎金信</h2><p><a href="https://leetcode.cn/problems/ransom-note/">https://leetcode.cn/problems/ransom-note/</a></p><h3 id="defaultdict的使用"><a href="#defaultdict的使用" class="headerlink" title="defaultdict的使用"></a>defaultdict的使用</h3><p>From: <a href="https://www.geeksforgeeks.org/defaultdict-in-python/">https://www.geeksforgeeks.org/defaultdict-in-python/</a></p><p> It provides a default value for the key that does not exists.</p><h4 id="对于函数"><a href="#对于函数" class="headerlink" title="对于函数"></a>对于函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">def_value</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Not Present&quot;</span></span><br><span class="line">      </span><br><span class="line"><span class="comment"># Defining the dict</span></span><br><span class="line">d = defaultdict(def_value)</span><br><span class="line">d[<span class="string">&quot;a&quot;</span>] = <span class="number">1</span></span><br><span class="line">d[<span class="string">&quot;b&quot;</span>] = <span class="number">2</span></span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&quot;a&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&quot;b&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&quot;c&quot;</span>])</span><br><span class="line">-------------</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">Not Present </span><br></pre></td></tr></table></figure><h4 id="利用lambda表达式"><a href="#利用lambda表达式" class="headerlink" title="利用lambda表达式"></a>利用lambda表达式</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">  </span><br><span class="line">      </span><br><span class="line"><span class="comment"># Defining the dict and passing </span></span><br><span class="line"><span class="comment"># lambda as default_factory argument</span></span><br><span class="line">d = defaultdict(<span class="keyword">lambda</span>: <span class="string">&quot;Not Present&quot;</span>)</span><br><span class="line">d[<span class="string">&quot;a&quot;</span>] = <span class="number">1</span></span><br><span class="line">d[<span class="string">&quot;b&quot;</span>] = <span class="number">2</span></span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&quot;a&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&quot;b&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&quot;c&quot;</span>])</span><br><span class="line">-------------</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">Not Present</span><br><span class="line">--------------------------------------------------</span><br><span class="line">__missing__(): function的用法</span><br><span class="line"><span class="keyword">if</span>:argument <span class="keyword">is</span> <span class="literal">None</span> 会出现a KeyError</span><br><span class="line"><span class="keyword">else</span>:  provides a default value <span class="keyword">for</span> the given key</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="comment"># Defining the dict</span></span><br><span class="line">d = defaultdict(<span class="keyword">lambda</span>: <span class="string">&quot;Not Present&quot;</span>)</span><br><span class="line">d[<span class="string">&quot;a&quot;</span>] = <span class="number">1</span></span><br><span class="line">d[<span class="string">&quot;b&quot;</span>] = <span class="number">2</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># Provides the default value </span></span><br><span class="line"><span class="comment"># for the key</span></span><br><span class="line"><span class="built_in">print</span>(d.__missing__(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(d.__missing__(<span class="string">&#x27;d&#x27;</span>))</span><br><span class="line">---------------output</span><br><span class="line">Not Present</span><br><span class="line">Not Present </span><br></pre></td></tr></table></figure><h4 id="int-和-list"><a href="#int-和-list" class="headerlink" title="int 和 list"></a>int 和 list</h4><ul><li><p>Using int as default_factory(a defaultdict is created with <strong>default value as zero</strong>)<br><code>from collections import defaultdict</code><br><code>d = defaultdict(int)</code></p></li><li><p>a defaultdict is created with the values that are list.</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    d[i].append(i)</span><br><span class="line">d = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">&#123;<span class="number">0</span>: [<span class="number">0</span>], <span class="number">1</span>: [<span class="number">1</span>], <span class="number">2</span>: [<span class="number">2</span>], <span class="number">3</span>: [<span class="number">3</span>], <span class="number">4</span>: [<span class="number">4</span>]&#125;)</span><br></pre></td></tr></table></figure><h3 id="对于counter的使用"><a href="#对于counter的使用" class="headerlink" title="对于counter的使用"></a>对于counter的使用</h3><p>From: <a href="https://pythongeeks.org/python-counter-module/">https://pythongeeks.org/python-counter-module/</a><br>语法：<br><code>obj = collections.Counter([iterable-or-mapping])</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter  <span class="comment"># collections = module name </span></span><br><span class="line">                                 <span class="comment"># Counter = class name</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">issubclass</span>(Counter, <span class="built_in">dict</span>)) <span class="comment"># issubclass() = function name</span></span><br><span class="line"><span class="comment"># print() = function name, dict = class name</span></span><br><span class="line">-----output</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> Creating a Counter Object using **Iterables** <span class="keyword">in</span> Python</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">c = Counter([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(c) </span><br><span class="line">output: Counter(&#123;<span class="number">1</span>: <span class="number">3</span>, <span class="number">3</span>: <span class="number">2</span>, <span class="number">2</span>: <span class="number">1</span>, <span class="number">4</span>: <span class="number">1</span>&#125;)</span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="number">2.</span> Creating a Counter Object using **Strings** <span class="keyword">in</span> Python</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">c = Counter(<span class="string">&quot;PythonGeeks&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">output: Counter(&#123;‘e’: <span class="number">2</span>, ‘P’: <span class="number">1</span>, ‘y’: <span class="number">1</span>, ‘t’: <span class="number">1</span>, ‘h’: <span class="number">1</span>, ‘o’: <span class="number">1</span>, ‘n’: <span class="number">1</span>, ‘G’: <span class="number">1</span>, ‘k’: <span class="number">1</span>, ‘s’: <span class="number">1</span>&#125;)</span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="number">3.</span> Creating a Counter Object using **Dictionary** <span class="keyword">in</span> Python</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">c = Counter(&#123;<span class="string">&quot;A&quot;</span>: <span class="number">2</span>, <span class="string">&quot;B&quot;</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">output: Counter(&#123;‘A’: <span class="number">2</span>, ‘B’: <span class="number">1</span>&#125;)</span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="number">4.</span> Creating a Counter Object using Keyword Arguments <span class="keyword">in</span> Python</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">c = Counter(A=<span class="number">2</span>, B=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">output: Counter(&#123;‘A’: <span class="number">2</span>, ‘B’: <span class="number">1</span>&#125;)</span><br><span class="line">----------------------------------------------</span><br><span class="line"></span><br><span class="line">获取值</span><br><span class="line">c = Counter([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(c[<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">output: <span class="number">2</span></span><br><span class="line">不像普通字典，counter会返回<span class="number">0</span>，而不会引起 KeyError, 如果传入的argument不在里面</span><br><span class="line">c = Counter([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(c[<span class="string">&#x27;d&#x27;</span>])</span><br><span class="line">output: <span class="number">0</span></span><br><span class="line">----------------------------------------------</span><br><span class="line">修改添加值</span><br><span class="line"></span><br><span class="line">c[<span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span></span><br><span class="line">c[<span class="string">&#x27;c&#x27;</span>] = <span class="number">4</span></span><br><span class="line">----------------------------------------------</span><br><span class="line">方法：</span><br><span class="line"><span class="number">1.</span>update():</span><br><span class="line">c = Counter([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">c.update([<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">output:Counter(&#123;‘a’: <span class="number">2</span>, ‘b’: <span class="number">1</span>, ‘c’: <span class="number">1</span>&#125;)Counter(&#123;‘a’: <span class="number">3</span>, ‘d’: <span class="number">2</span>, ‘b’: <span class="number">1</span>, ‘c’: <span class="number">1</span>, ‘e’: <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>elements():returns an iterator that we can use <span class="keyword">in</span> <span class="keyword">for</span>-loops to iterate over <span class="built_in">all</span> elements <span class="keyword">and</span> their counts <span class="keyword">in</span> the counter <span class="built_in">object</span>.</span><br><span class="line">c = Counter([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="keyword">for</span> ele <span class="keyword">in</span> c.elements():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;ele&#125;</span> - <span class="subst">&#123;c[ele]&#125;</span>&quot;</span>)</span><br><span class="line">output: a – 2a – <span class="number">2</span></span><br><span class="line"></span><br><span class="line">b – <span class="number">1</span></span><br><span class="line"></span><br><span class="line">c – <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>most_common([n])：sort 从最高频率到最低评率到n</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">c = Counter([<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(c.most_common(<span class="number">2</span>))</span><br><span class="line">output: [(<span class="number">1</span>, <span class="number">5</span>), (<span class="number">2</span>, <span class="number">3</span>)]</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>clear():清空所有</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>算数+，-，&amp;，｜</span><br><span class="line">+：两个<span class="built_in">dict</span>元素相加</span><br><span class="line">-：两个<span class="built_in">dict</span> 相减，比如 a-b,最后的结果只是减去b中有相同key的元素</span><br><span class="line">c1 = Counter(a=<span class="number">3</span>, b=<span class="number">1</span>, c=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(c1)</span><br><span class="line">c2 = Counter(c=<span class="number">1</span>, d=<span class="number">2</span>, e=<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(c2)</span><br><span class="line">c3 = c1 - c2</span><br><span class="line"><span class="built_in">print</span>(c3)</span><br><span class="line">output: Counter(&#123;‘a’: <span class="number">3</span>, ‘c’: <span class="number">2</span>, ‘b’: <span class="number">1</span>&#125;)Counter(&#123;‘e’: <span class="number">3</span>, ‘d’: <span class="number">2</span>, ‘c’: <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line">Counter(&#123;‘a’: <span class="number">3</span>, ‘b’: <span class="number">1</span>, ‘c’: <span class="number">1</span>&#125;)</span><br><span class="line">&amp;: 返回item在两个<span class="built_in">dict</span>里面都出现</span><br><span class="line">|: 和加法类似但是不想家数值</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">c1 = Counter(a=<span class="number">3</span>, b=<span class="number">1</span>, c=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(c1)</span><br><span class="line">c2 = Counter(c=<span class="number">1</span>, d=<span class="number">2</span>, e=<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(c2)</span><br><span class="line">c3 = c1 | c2</span><br><span class="line"><span class="built_in">print</span>(c3)</span><br><span class="line">output:Counter(&#123;‘a’: <span class="number">3</span>, ‘c’: <span class="number">2</span>, ‘b’: <span class="number">1</span>&#125;)Counter(&#123;‘e’: <span class="number">3</span>, ‘d’: <span class="number">2</span>, ‘c’: <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line">Counter(&#123;‘a’: <span class="number">3</span>, ‘e’: <span class="number">3</span>, ‘c’: <span class="number">2</span>, ‘d’: <span class="number">2</span>, ‘b’: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="利用数组当作哈希表"><a href="#利用数组当作哈希表" class="headerlink" title="利用数组当作哈希表"></a>利用数组当作哈希表</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canConstruct</span>(<span class="params">self, ransomNote: <span class="built_in">str</span>, magazine: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        list_ = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> magazine:</span><br><span class="line">            list_[<span class="built_in">ord</span>(i) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> ransomNote:</span><br><span class="line">            list_[<span class="built_in">ord</span>(j) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> list_:</span><br><span class="line">            <span class="keyword">if</span> k &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="直接哈希表"><a href="#直接哈希表" class="headerlink" title="直接哈希表"></a>直接哈希表</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canConstruct</span>(<span class="params">self, ransomNote: <span class="built_in">str</span>, magazine: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        dict_ = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> magazine:</span><br><span class="line">            dict_[i] = dict_.get(i,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> ransomNote:</span><br><span class="line">            dict_[j] = dict_.get(j,<span class="number">0</span>) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> dict_.values():</span><br><span class="line">            <span class="keyword">if</span> k &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><strong>用defaultdict</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canConstruct</span>(<span class="params">self, ransomNote: <span class="built_in">str</span>, magazine: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">        dict_ = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> magazine:</span><br><span class="line">            dict_[i] = dict_.get(i,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> ransomNote:</span><br><span class="line">            <span class="keyword">if</span> dict_[j] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dict_[j] = dict_.get(j,<span class="number">0</span>) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><strong>用Counter</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canConstruct</span>(<span class="params">self, ransomNote: <span class="built_in">str</span>, magazine: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        a = collections.Counter(magazine)</span><br><span class="line">        b = collections.Counter(ransomNote)</span><br><span class="line">        diff = b - a</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(diff) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h2><p><a href="https://leetcode.cn/problems/3sum/">https://leetcode.cn/problems/3sum/</a></p><h3 id="相向双指针"><a href="#相向双指针" class="headerlink" title="相向双指针"></a>相向双指针</h3><ul><li>自己没做出来</li><li>先排序：优化数组可以使用相向双指针</li><li>重点在于去重</li></ul><ol><li><code>nums[i] == nums[i + 1] 并且 i &gt; 0 的时候跳过 i ++</code></li><li><code>while(j &lt;k and nums[j] == nums[j + 1]) j ++</code></li><li><code>while(j &lt; k and nums[k] -- nums[k - 1]) k --</code></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        nums.sort()</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">2</span>):</span><br><span class="line">            <span class="comment">#很重要是i 和 i-1,避免跳过相同元素</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment">#剪枝操作</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment">#剪枝操作</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] + nums[-<span class="number">2</span>] + nums[-<span class="number">1</span>] &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            j = i + <span class="number">1</span></span><br><span class="line">            k = n - <span class="number">1</span></span><br><span class="line">            x = nums[i]</span><br><span class="line">            <span class="keyword">while</span> (j &lt; k):</span><br><span class="line">                <span class="keyword">if</span> x + nums[j] + nums[k] &gt; <span class="number">0</span>:</span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> x + nums[j] + nums[k] &lt; <span class="number">0</span>:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append([x,nums[j],nums[k]])</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> (nums[j] == nums[j - <span class="number">1</span>] <span class="keyword">and</span> j &lt; k):</span><br><span class="line">                        j += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span>( nums[k] == nums[k + <span class="number">1</span>] <span class="keyword">and</span> j &lt; k):</span><br><span class="line">                        k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a>18. 四数之和</h2><p><a href="https://leetcode.cn/problems/4sum/">https://leetcode.cn/problems/4sum/</a></p><h3 id="思路和三数之和一样就是多了一层for-loop"><a href="#思路和三数之和一样就是多了一层for-loop" class="headerlink" title="思路和三数之和一样就是多了一层for loop"></a>思路和三数之和一样就是多了一层for loop</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        nums.sort()</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">3</span>):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] + nums[ i + <span class="number">1</span>] + nums[i+<span class="number">2</span>] + nums[i+<span class="number">3</span>] &gt; target:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            x1 = nums[i]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,n - <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">if</span> j &gt; i + <span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                x2 = nums[j]</span><br><span class="line">                l = j + <span class="number">1</span></span><br><span class="line">                r = n - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span>(l &lt; r):</span><br><span class="line">                    sum_ = x1 + x2 + nums[l] + nums[r]</span><br><span class="line">                    <span class="keyword">if</span> sum_ &gt; target:</span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> sum_ &lt; target:</span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        res.append([x1,x2,nums[l],nums[r]])</span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l] == nums[l - <span class="number">1</span>]:</span><br><span class="line">                            l += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[r] == nums[r + <span class="number">1</span>]:</span><br><span class="line">                            r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
          <category> 哈希表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希表专题1</title>
      <link href="/2022/12/17/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%93%88%E5%B8%8C%E8%A1%A8%E4%B8%93%E9%A2%981/"/>
      <url>/2022/12/17/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%93%88%E5%B8%8C%E8%A1%A8%E4%B8%93%E9%A2%981/</url>
      
        <content type="html"><![CDATA[<h2 id="哈希表基础理论"><a href="#哈希表基础理论" class="headerlink" title="哈希表基础理论"></a>哈希表基础理论</h2><p>数组就可以被看成是一个哈希表</p><ul><li>主要用来判断看一个元素是不是在这个集合里</li><li>相比较而言数组：如需要查询一个学生姓名，数组需要遍历，而哈希表直接进行索引就可以</li><li><strong>为什么哈希表是O(1)查询呢，因为只要知道key或者对于hashset来说知道索引就可以知道所要查询的值，比如要查询这个学生在不在哈希表&#x2F;set()里面,只需要提供这个人的名字然后用哈希函数把名字转换成hashcode之后，之后用 hash 表的数组长度对 key的hashCode 求余， 余数即为 hash 表数组的下标</strong></li></ul><h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p>学生的姓名可以通过哈希函数转化为哈希表的索引</p><ul><li>在上面的场景中查询学生姓名，就是通过hashcode把名字转化为数值映射到了哈希表上面的索引数字</li><li>之后为了保证索引数值落在哈希表上面，我们还会对hashcode之后的数值进行取模运算</li></ul><h3 id="哈希碰撞"><a href="#哈希碰撞" class="headerlink" title="哈希碰撞"></a>哈希碰撞</h3><p>对于学生数量大于了创建的哈希表的大小来说<br>有两种解决办法</p><ul><li>拉链法：对于冲突的索引值比如位置<code>index0</code>，我们在0的位置创建一个链表储存冲突的学生</li><li>线性探测法：我们首先要保证hash table size要大于数据量，如果一旦发生冲突我们就在hash table寻找下一个空的位置填放</li></ul><h2 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a>242. 有效的字母异位词</h2><p><a href="https://leetcode.cn/problems/valid-anagram/">https://leetcode.cn/problems/valid-anagram/</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>范围可控用数组</li><li>范围比较大用set</li><li>key 对应有 value的话就用map</li></ol><h5 id="python-ord-和chr-方法"><a href="#python-ord-和chr-方法" class="headerlink" title="python ord()和chr()方法"></a>python <code>ord()和chr()方法</code></h5><ol><li>ord()：<code>print(ord(&#39;a&#39;)) = 97</code></li><li>chr()：<code>&gt;&gt;&gt; print(chr(97)) = a</code></li></ol><h5 id="创建default-dictionary的方法"><a href="#创建default-dictionary的方法" class="headerlink" title="创建default dictionary的方法"></a>创建default dictionary的方法</h5><ul><li>1.<code>from collections import defaultdict</code></li><li>2.创建一个default dictionary <code>import string   d1 = dict.fromkeys(string.ascii_lowercase, 0)</code> </li><li><code>dict.fromkeys(keys, value)</code>The fromkeys() method returns a dictionary with the specified keys and the specified value.</li></ul><h5 id="initialize-list的方法"><a href="#initialize-list的方法" class="headerlink" title="initialize list的方法"></a>initialize list的方法</h5><ol><li><code>data = [0] * n</code> n的值是需要的创建的数量</li></ol><h4 id="第一想法（用的哈希表）"><a href="#第一想法（用的哈希表）" class="headerlink" title="第一想法（用的哈希表）"></a>第一想法（用的哈希表）</h4><ul><li><p>自己想的用dict然后遍历一个string 遇到就+&#x3D; 1，然后遍历第二个string -&#x3D; 1，但是再次遍历这个dict<br><code>dict.get(key, default = None)</code></p></li><li><p>判断两个dict 相等直接用等于</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">import</span> string</span><br><span class="line">        d1 = <span class="built_in">dict</span>.fromkeys(string.ascii_lowercase, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            d1[i] = d1.get(i,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> t:</span><br><span class="line">            d1[i] = d1.get(i) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> d1.values():</span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="把数组当作哈希表使用"><a href="#把数组当作哈希表使用" class="headerlink" title="把数组当作哈希表使用"></a>把数组当作哈希表使用</h4><ul><li>创建一个26个长度为0的数组</li><li>其他思路和上面一样</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        l = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            l[<span class="built_in">ord</span>(i) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> t:</span><br><span class="line">            l[<span class="built_in">ord</span>(j) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> l:</span><br><span class="line">            <span class="keyword">if</span> k != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h2><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">https://leetcode.cn/problems/intersection-of-two-arrays/</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><h4 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h4><ul><li>有思路：直接两个for loop然后最后set.add()最后转换set成list</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intersection</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        intersect = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> nums2:</span><br><span class="line">                <span class="keyword">if</span> i == j:</span><br><span class="line">                    intersect.add(i)</span><br><span class="line">        <span class="comment"># set to list 直接用list()</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(intersect)</span><br></pre></td></tr></table></figure><h4 id="用hashmap当作hashset做"><a href="#用hashmap当作hashset做" class="headerlink" title="用hashmap当作hashset做"></a>用hashmap当作hashset做</h4><ul><li>分成两个for loop一个遍历一个排查</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intersection</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        hashmap = &#123;&#125;</span><br><span class="line">        result = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">            hashmap[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">in</span> hashmap.keys() <span class="keyword">and</span> hashmap[j] ==<span class="number">1</span>:</span><br><span class="line">                result.add(j)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(result)</span><br></pre></td></tr></table></figure><h2 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h2><p><a href="https://leetcode.cn/problems/happy-number/">https://leetcode.cn/problems/happy-number/</a></p><h3 id="in-关键字"><a href="#in-关键字" class="headerlink" title="in 关键字"></a>in 关键字</h3><ul><li>python 里面 的in关键字和contains是一样的</li><li>对于list:复杂度是O（n）</li><li>对于set:复杂度是O(1)因为通过hashcode可以直接知道索引下标</li></ul><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ul><li>计算器 十位数如何拆开计算</li><li>取个位数是用%取余符号</li><li>之后每次除以10</li><li>判断n &#x3D;&#x3D; 1的时候return true</li><li>如果不是等于1要判断在不在set里面，如果在说明重复了所以return false</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">happy</span>(<span class="params">n</span>):</span><br><span class="line">            sum_ = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> n:</span><br><span class="line">                sum_ += (n % <span class="number">10</span>) ** <span class="number">2</span></span><br><span class="line">                n //= <span class="number">10</span></span><br><span class="line">            <span class="keyword">return</span> sum_</span><br><span class="line">        hashset = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            n = happy(n)</span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment">#这里很重要，in关键字对于set的复杂度只有O(1)</span></span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> hashset:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashset.add(n)</span><br></pre></td></tr></table></figure><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h2><p><a href="https://leetcode.cn/problems/two-sum/">https://leetcode.cn/problems/two-sum/</a></p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><h4 id="两个单独的for-loop不是嵌套"><a href="#两个单独的for-loop不是嵌套" class="headerlink" title="两个单独的for loop不是嵌套"></a>两个单独的for loop不是嵌套</h4><ul><li>自己的思路:创建hashmap保存key 是 nums里面的数， val是nums里面的index</li><li>但是这个时候第二个for loop会出现一个问题</li><li>会出现比如target为6 nums &#x3D; [3,2,4]，会返回[0,0]这个时候用if 判断一下避免一样就好了</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        hashmap = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            hashmap[j] = i</span><br><span class="line">        <span class="keyword">for</span> i,k <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            rest = target - k</span><br><span class="line">            <span class="keyword">if</span> rest <span class="keyword">in</span> hashmap <span class="keyword">and</span> i != hashmap[rest]:</span><br><span class="line">                <span class="keyword">return</span> [i,hashmap[rest]] </span><br></pre></td></tr></table></figure><h4 id="哈希表一个for-loop"><a href="#哈希表一个for-loop" class="headerlink" title="哈希表一个for loop"></a>哈希表一个for loop</h4><ul><li>遍历的时候同时保存hashmap</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        hashmap = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            rest = target - j</span><br><span class="line">            <span class="keyword">if</span> rest <span class="keyword">not</span> <span class="keyword">in</span> hashmap.keys():</span><br><span class="line">                hashmap[j] = i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> [hashmap[rest],i]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
          <category> 哈希表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表专题2</title>
      <link href="/2022/12/14/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%982/"/>
      <url>/2022/12/14/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%982/</url>
      
        <content type="html"><![CDATA[<h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h2><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">https://leetcode.cn/problems/swap-nodes-in-pairs/</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>简单模拟题</li><li>掌握好指针移动循序先 <code>cur.next再cur.next.next再cur.next.next.next </code></li><li>核心：终止条件 <code>cur.next 和 cur.next.next都不为空是才进行</code></li><li>当节点数量为奇数时候：<code>cur.next.next</code>为空时就不需要交换了</li><li>当节点数量为偶数时候<code>cur.next</code>为空就停止</li><li>不能反过来写容易发生空指针异常</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swapPairs</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy = ListNode(<span class="built_in">next</span> = head)</span><br><span class="line">        cur = dummy</span><br><span class="line">        <span class="comment">#必须有下个和下下个不等于none才可以进行(关键)</span></span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> != <span class="literal">None</span> <span class="keyword">and</span> cur.<span class="built_in">next</span>.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            temp1 = cur.<span class="built_in">next</span></span><br><span class="line">            temp2 = cur.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span>.<span class="built_in">next</span>= temp1</span><br><span class="line">            cur.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = temp2</span><br><span class="line">            cur = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a>19. 删除链表的倒数第 N 个结点</h2><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">https://leetcode.cn/problems/remove-nth-node-from-end-of-list/</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>写了出来</li><li>一个快指针一个慢指针</li><li>快慢指针中间差n个节点</li></ul><h4 id="双指针经典应用"><a href="#双指针经典应用" class="headerlink" title="双指针经典应用"></a>双指针经典应用</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], n: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy_head = ListNode(<span class="built_in">next</span> = head)</span><br><span class="line">        pre = dummy_head</span><br><span class="line">        cur = dummy_head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            pre = pre.<span class="built_in">next</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        pre.<span class="built_in">next</span> = pre.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy_head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><h2 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h2><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/</a></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ul><li>暴力解法</li><li>求出链表A的长度再求出链表B的长度</li><li>然后让两个链表处于相同位置</li><li>之后<strong>赋值两个新的node注意不要创建Listnode地址会不同！！</strong></li><li>然后两个指针一直走知道相同返回当前值</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">if</span> headA == <span class="literal">None</span> <span class="keyword">or</span> headB == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        dummyhead1 = ListNode(<span class="built_in">next</span> = headA.<span class="built_in">next</span>)</span><br><span class="line">        dummyhead2 = ListNode(<span class="built_in">next</span> = headB.<span class="built_in">next</span>)</span><br><span class="line">        lengthA = <span class="number">0</span></span><br><span class="line">        lengthB = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(dummyhead1 != <span class="literal">None</span>):</span><br><span class="line">            dummyhead1 = dummyhead1.<span class="built_in">next</span></span><br><span class="line">            lengthA += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(dummyhead2 != <span class="literal">None</span>):</span><br><span class="line">            dummyhead2 = dummyhead2.<span class="built_in">next</span></span><br><span class="line">            lengthB += <span class="number">1</span></span><br><span class="line">        <span class="comment">#这里不要 head1 = ListNode(next = headA.next)</span></span><br><span class="line">        <span class="comment"># 地址会不同</span></span><br><span class="line">        head1 = headA</span><br><span class="line">        head2 = headB</span><br><span class="line">        <span class="keyword">if</span> lengthA &gt; lengthB:</span><br><span class="line">            <span class="keyword">while</span> (lengthA - lengthB):</span><br><span class="line">                head1 = head1.<span class="built_in">next</span></span><br><span class="line">                lengthA -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> lengthA &lt; lengthB:</span><br><span class="line">            <span class="keyword">while</span> (lengthB - lengthA):</span><br><span class="line">                head2 = head2.<span class="built_in">next</span></span><br><span class="line">                lengthB -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (head1 != <span class="literal">None</span>):</span><br><span class="line">            <span class="keyword">if</span> head1 == head2:</span><br><span class="line">                <span class="keyword">return</span> head1</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                head1 = head1.<span class="built_in">next</span></span><br><span class="line">                head2 = head2.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h2 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a>142. 环形链表 II</h2><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">https://leetcode.cn/problems/linked-list-cycle-ii/</a></p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ul><li>快慢指针</li><li>如何想到的呢就是：如果快指针是慢指针速度的两倍的话两个一定可以遇到</li><li>x,y,z </li><li>x:开始的位置到环的起点位置</li><li>y:环起点位置到相遇的位置</li><li>z:相遇的位置到环起点位置</li><li>所以对于慢指针的移动距离是：x + y</li><li>快指针一定是套了慢指针一圈的所以移动距离是：x +（y+z）+ y</li><li>2(x+y) &#x3D; x + 2y + z</li><li>z &#x3D; x</li><li>所以通过数学推导发现相遇的位置到环的起点位置和最开始的位置到环的起点位置的距离是一样的</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detectCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        fast = head</span><br><span class="line">        slow = head</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">None</span> <span class="keyword">and</span> fast.<span class="built_in">next</span> != <span class="literal">None</span>):</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> fast == slow:</span><br><span class="line">                meet_loc = fast</span><br><span class="line">                start = head</span><br><span class="line">                <span class="keyword">while</span> meet_loc != start:</span><br><span class="line">                    meet_loc = meet_loc.<span class="built_in">next</span></span><br><span class="line">                    start = start.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> start</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表专题1</title>
      <link href="/2022/12/13/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%981/"/>
      <url>/2022/12/13/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%981/</url>
      
        <content type="html"><![CDATA[<h2 id="链表理论基础"><a href="#链表理论基础" class="headerlink" title="链表理论基础"></a>链表理论基础</h2><p>链表有两个部分组成：</p><ul><li>数据域</li><li>指针域</li></ul><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><ul><li>入口是head</li><li>结尾的指针域指向空指针</li></ul><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><ul><li>每个节点有两个指针域,一个指向上一个节点一个指向下一个节点</li></ul><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><ul><li>链表首尾相连</li></ul><h3 id="链表和数组的存储方式-x2F-时间复杂度"><a href="#链表和数组的存储方式-x2F-时间复杂度" class="headerlink" title="链表和数组的存储方式&#x2F;时间复杂度"></a>链表和数组的存储方式&#x2F;时间复杂度</h3><h4 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h4><ul><li>连续存储在内存中</li><li>插入删除：O(n)</li><li>查询：O(1)</li></ul><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><ul><li>链表：在内存中可不连续存储<br>插入删除：O(1)</li><li>查询：O(n)</li></ul><h3 id="链表定义"><a href="#链表定义" class="headerlink" title="链表定义"></a>链表定义</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br></pre></td></tr></table></figure><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>删除节点就是把这个节点的指针指向要删掉的节点的下一节点的数据域</p><h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><ul><li>把要添加位置的前一节点的指针指向要添加节点的数据域</li><li>把添加节点的指针指向添加位置后的节点的数据域</li></ul><h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a>203. 移除链表元素</h2><p>题目链接：<a href="https://leetcode.cn/problems/remove-linked-list-elements/">https://leetcode.cn/problems/remove-linked-list-elements/</a></p><p>cur的作用是作为新的临时节点指针进行删除原链表元素操作</p><h3 id="原链表删除"><a href="#原链表删除" class="headerlink" title="原链表删除"></a>原链表删除</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElements</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="comment"># print(head != None)</span></span><br><span class="line">        <span class="comment">#如果头节点等于要删除的val的话就向后移</span></span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">None</span> <span class="keyword">and</span> head.val == val ):</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="comment">#对于不是头节点的进行删除</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">None</span> <span class="keyword">and</span>  cur.<span class="built_in">next</span> != <span class="literal">None</span>):</span><br><span class="line">            <span class="keyword">if</span> cur.<span class="built_in">next</span>.val == val:</span><br><span class="line">                cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h3 id="虚拟结点"><a href="#虚拟结点" class="headerlink" title="虚拟结点"></a>虚拟结点</h3><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>为了不单独区分头节点和不是头节点的删除操作</li><li>创造一个<code>dummy = ListNode()----dummy.next = head</code>的节点，然后再去创造一个新的current指针去遍历整个dummy链表</li><li>操作的点一定是<code>current.next</code> 这样子才可以进行增加或者删除操作</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElements</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy = ListNode()</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        cur = dummy</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.<span class="built_in">next</span>.val != val:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;head&#x27;</span>,head)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;cur&#x27;</span>,cur)</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><h2 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707. 设计链表"></a>707. 设计链表</h2><p>题目链接：<a href="https://leetcode.cn/problems/design-linked-list/">https://leetcode.cn/problems/design-linked-list/</a></p><h3 id="单链表解法"><a href="#单链表解法" class="headerlink" title="单链表解法"></a>单链表解法</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>我这道题主要看到问题知道怎么写但是对类的创建不是很了解，所以参考了视频以后才写出来</p><ul><li>首先创建单独的node类</li><li>对于提供的mylinkedlist 需要在构造函数里面初始化需要用的dummyhead和整个链表的长度</li><li>其他的基本没什么难度但是需要注意while内部需要自己定义index – 和进行添加以后的长度++</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,val = <span class="number">0</span>,<span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.dummyhead = Node()</span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, index: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt;= self.size:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        cur = self.dummyhead</span><br><span class="line">        <span class="keyword">while</span>(index != <span class="number">0</span>):</span><br><span class="line">            index -= <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> cur.<span class="built_in">next</span>.val</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addAtHead</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        add_head = Node(val)</span><br><span class="line">        add_head.<span class="built_in">next</span> = self.dummyhead.<span class="built_in">next</span></span><br><span class="line">        self.dummyhead.<span class="built_in">next</span> = add_head</span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addAtTail</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        add_tail = Node(val)</span><br><span class="line">        cur = self.dummyhead</span><br><span class="line">        <span class="keyword">while</span>(cur.<span class="built_in">next</span> != <span class="literal">None</span>):</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        cur.<span class="built_in">next</span> = add_tail</span><br><span class="line">        add_tail.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addAtIndex</span>(<span class="params">self, index: <span class="built_in">int</span>, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> index == self.size:</span><br><span class="line">            self.addAtTail(val)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> index &lt; <span class="number">0</span>:</span><br><span class="line">            self.addAtHead()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> index &gt; self.size:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        add_index_node = Node(val)</span><br><span class="line">        cur = self.dummyhead</span><br><span class="line">        <span class="keyword">while</span>(index != <span class="number">0</span>):</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">            index -= <span class="number">1</span></span><br><span class="line">        add_index_node.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">        cur.<span class="built_in">next</span> = add_index_node</span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteAtIndex</span>(<span class="params">self, index: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> index &gt;= <span class="number">0</span> <span class="keyword">and</span> index &lt; self.size:</span><br><span class="line">            cur = self.dummyhead</span><br><span class="line">            <span class="keyword">while</span>(index != <span class="number">0</span>):</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">                index -= <span class="number">1</span></span><br><span class="line">            cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            self.size -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyLinkedList()</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(index)</span></span><br><span class="line"><span class="comment"># obj.addAtHead(val)</span></span><br><span class="line"><span class="comment"># obj.addAtTail(val)</span></span><br><span class="line"><span class="comment"># obj.addAtIndex(index,val)</span></span><br><span class="line"><span class="comment"># obj.deleteAtIndex(index)</span></span><br></pre></td></tr></table></figure><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h2><p><a href="https://leetcode.cn/problems/reverse-linked-list/">https://leetcode.cn/problems/reverse-linked-list/</a></p><h3 id="双指针（迭代）"><a href="#双指针（迭代）" class="headerlink" title="双指针（迭代）"></a>双指针（迭代）</h3><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ul><li>自己没想出来：用双指针</li><li>用temp存储cur.next保证cur下一步成功赋值</li><li>先赋值cur再赋值pre</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur!= <span class="literal">None</span>:</span><br><span class="line">            temp = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = temp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure><h3 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h3><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><ul><li>利用双指针的思路实际上只是替换了pre和current指针移动的步骤</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">pre,cur</span>):</span><br><span class="line">            <span class="keyword">if</span> cur == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> pre</span><br><span class="line">            temp = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            <span class="keyword">return</span> reverse(cur,temp)</span><br><span class="line">        <span class="keyword">return</span> reverse(<span class="literal">None</span>,head)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组专题2</title>
      <link href="/2022/12/12/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%95%B0%E7%BB%84%E4%B8%93%E9%A2%982/"/>
      <url>/2022/12/12/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%95%B0%E7%BB%84%E4%B8%93%E9%A2%982/</url>
      
        <content type="html"><![CDATA[<h2 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h2><p>题目链接：<a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">https://leetcode.cn/problems/squares-of-a-sorted-array/</a></p><h3 id="1-暴力"><a href="#1-暴力" class="headerlink" title="1.暴力"></a>1.暴力</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>最直接的思路就是全部都平方然后调用<code>sorted()</code>函数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedSquares</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            nums[i] = nums[i]*nums[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sorted</span>(nums)</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            nums[i] *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-双指针"><a href="#2-双指针" class="headerlink" title="2.双指针"></a>2.双指针</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul><li>因为最大值在数组的两端，所以两个指针，一个指向起始位置一个指向末尾位置。</li><li>然后定义一个新的数组让他从末尾的位置（因为要一个非递减数列）开始赋值</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(nums.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>,j = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt;= j;)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]* nums[i] &gt;= nums[j]*nums[j])&#123;</span><br><span class="line">                result[k--] = nums[i] * nums[i];</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                result[k--] = nums[j] * nums[j];</span><br><span class="line">                j --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedSquares</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        result = [<span class="number">0</span>] * (<span class="built_in">len</span>(nums))</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="comment"># k指针是新的数组倒叙进行赋值</span></span><br><span class="line">        k = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">            <span class="comment"># 左边值大于等于右边值的平方的时候都是赋值给新的数组左边的值</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] * nums[i] &gt;= nums[j] * nums[j]:</span><br><span class="line">                result[k] = nums[i] * nums[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result[k] = nums[j] * nums[j]</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h2><p>题目链接：<a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">https://leetcode.cn/problems/minimum-size-subarray-sum/</a></p><h3 id="1-暴力-1"><a href="#1-暴力-1" class="headerlink" title="1.暴力"></a>1.暴力</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ul><li>两个for循环（外层的循环可以看作这个subset的开头，内层的是不断的累加来寻找最佳的连续的子数组, <strong>i：可以视作开头，j：可以视作结尾</strong>）</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#超时了</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        min_length = <span class="number">10</span>**<span class="number">10</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            sum_sub = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,<span class="built_in">len</span>(nums)):</span><br><span class="line">               sum_sub += nums[j]</span><br><span class="line">               <span class="keyword">if</span> sum_sub &gt;= target:</span><br><span class="line">                   length = j - i + <span class="number">1</span></span><br><span class="line">                   <span class="built_in">print</span>(<span class="string">&#x27;sum_sub&#x27;</span>,sum_sub)</span><br><span class="line">                   <span class="built_in">print</span>(<span class="string">&#x27;\tlength&#x27;</span>,length)</span><br><span class="line">                   <span class="built_in">print</span>(<span class="string">&#x27;\t\tmin_lenght&#x27;</span>,min_length)</span><br><span class="line">                   <span class="keyword">if</span> min_length &gt; length:</span><br><span class="line">                       min_length = length</span><br><span class="line">                   <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> min_length == <span class="number">10</span>**<span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> min_length</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C++同样超时了</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> min_len = INT32_MAX;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>();i ++)&#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; nums.<span class="built_in">size</span>();j ++)&#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span> (sum&gt;= target)&#123;</span><br><span class="line">                    length = j - i + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (min_len &gt; length)&#123;</span><br><span class="line">                        min_len = length;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min_len == INT32_MAX)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min_len;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-滑动窗口"><a href="#2-滑动窗口" class="headerlink" title="2.滑动窗口"></a>2.滑动窗口</h3><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ul><li>通过移动末尾坐标不断让数组累积啊</li><li>当值大于等于target的时候移动i头坐标</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        min_length = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="comment">#无限大的数</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        sum_sub = <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            sum_sub += nums[j]</span><br><span class="line">            <span class="keyword">while</span> sum_sub &gt;= target:</span><br><span class="line">                <span class="comment">#精髓（不要一直用 length+= 1或者 length -= 1）</span></span><br><span class="line">                <span class="comment">#用 j-i+1</span></span><br><span class="line">                length = j - i + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> min_length &gt; length:</span><br><span class="line">                    min_length = length</span><br><span class="line">                <span class="comment">#滑动窗口的精髓</span></span><br><span class="line">                sum_sub -= nums[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> min_length == <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> min_length</span><br></pre></td></tr></table></figure><h2 id="59-螺旋矩阵II"><a href="#59-螺旋矩阵II" class="headerlink" title="59.螺旋矩阵II"></a>59.螺旋矩阵II</h2><p>题目链接：<br><a href="https://leetcode.cn/problems/spiral-matrix-ii/">https://leetcode.cn/problems/spiral-matrix-ii/</a></p><h3 id="模拟题"><a href="#模拟题" class="headerlink" title="模拟题"></a>模拟题</h3><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>我最开始一点思路没有应该是卡在了count的这里,我在想不知道怎么创建数组因为只给了一个n，现在知道了就是固定住不变量（开区间）然后四个for循环去模拟。</p><ul><li>按照开区间从左到右</li><li>从上到下</li><li>从左到右</li><li>再次从上到下</li><li>最后如果n是奇数最后赋值</li><li>while loop循环的次数是n除以2</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateMatrix</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        loop = <span class="number">0</span></span><br><span class="line">        row = <span class="number">0</span></span><br><span class="line">        col = <span class="number">0</span></span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        offset = <span class="number">1</span></span><br><span class="line">        arr = [[<span class="number">0</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">while</span> loop &lt; n // <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(col,n - offset):</span><br><span class="line">                arr[row][i] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(row,n- offset):</span><br><span class="line">                arr[j][n-offset] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 重点这里是-1的操作，倒着遍历</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-offset,col,-<span class="number">1</span>):</span><br><span class="line">                arr[n-offset][i] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(n-offset,row,-<span class="number">1</span>):</span><br><span class="line">                arr[l][col] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            loop += <span class="number">1</span></span><br><span class="line">            row += <span class="number">1</span></span><br><span class="line">            col += <span class="number">1</span></span><br><span class="line">            offset += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            arr[n//<span class="number">2</span>][n//<span class="number">2</span>] = n*n</span><br><span class="line">        <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组专题1</title>
      <link href="/2022/12/11/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%95%B0%E7%BB%84%E4%B8%93%E9%A2%981/"/>
      <url>/2022/12/11/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%95%B0%E7%BB%84%E4%B8%93%E9%A2%981/</url>
      
        <content type="html"><![CDATA[<h2 id="数组理论基础"><a href="#数组理论基础" class="headerlink" title="数组理论基础"></a>数组理论基础</h2><p>数组可以方便的通过下标索引的方式获取到下标下对应的数据。</p><ul><li><strong>数组是存放在连续内存空间上的相同类型数据的集合</strong></li><li><strong>数组下标从零开始</strong></li><li><strong>数组内存空间地址是连续的</strong></li><li><strong>添加或者删除元素需要移动其他元素地址</strong></li><li><strong>数组的元素是不能删的，只能覆盖</strong><img src="https://github.com/YuuuWeng/YuuuWeng.github.io/raw/main/images/算法通关数组.png" alt="drawing" width="400" height/><img src="https://github.com/YuuuWeng/YuuuWeng.github.io/raw/main/images/算法通关数组1.png" alt="drawing" width="400" height/></li></ul><h2 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a>704. 二分查找</h2><p>题目链接: <a href="https://leetcode.cn/problems/binary-search/description/">https://leetcode.cn/problems/binary-search/description/</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>二分法必须是有序数组</li><li>无重复元素</li></ul><h3 id="两种不同的二分模版"><a href="#两种不同的二分模版" class="headerlink" title="两种不同的二分模版"></a>两种不同的二分模版</h3><h4 id="左闭右闭"><a href="#左闭右闭" class="headerlink" title="左闭右闭"></a>左闭右闭</h4><ul><li>[left,right]</li><li>left &#x3D; 0, right &#x3D; len(array) - 1</li><li>while(left &lt;&#x3D; right)</li><li>更新右边界的时候需要 right &#x3D; mid - 1 因为是闭区间，所以 nums[mid] 一定是不需要被包含到下一次while循环中的</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> middle = left + ((right - left) / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target)&#123;</span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target)&#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right):</span><br><span class="line">            middle = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[middle] &lt; target:</span><br><span class="line">                left = middle + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[middle] &gt; target:</span><br><span class="line">                right = middle - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> middle</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="左闭右开"><a href="#左闭右开" class="headerlink" title="左闭右开"></a>左闭右开</h4><ul><li>[left,right)</li><li>left &#x3D; 0, right &#x3D; len(array)</li><li>while(left &lt; right)</li><li>因为是开区间，所以更新right的时候 right &#x3D; mid,这个时候还是不会去比较nums[mid]</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> middle = left + ((right - left) / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target)&#123;</span><br><span class="line">                right = middle;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target)&#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right):</span><br><span class="line">            middle = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[middle] &lt; target:</span><br><span class="line">                left = middle + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[middle] &gt; target:</span><br><span class="line">                right = middle</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> middle</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h2><p><a href="https://leetcode.cn/problems/remove-element/">https://leetcode.cn/problems/remove-element/</a></p><h3 id="1-暴力"><a href="#1-暴力" class="headerlink" title="1.暴力"></a>1.暴力</h3><ul><li>暴力就是两个for loop,遇到要删除对val就用后面一个值进行替换。（重点是要记得替换以后下标发生了改变）</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">0</span>; i &lt; size;i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == val)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; size; j++)&#123;</span><br><span class="line">                    nums[j - <span class="number">1</span>] = nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">                i --;</span><br><span class="line">                size --;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>对于python的代码暴力做法下标 i-&#x3D; 1不适用,  python i-&#x3D; 1对于for loop 循环没有影响<strong>所以python无法用</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">nums, val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == val:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;i&#x27;</span>,i)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;nums[i]&#x27;</span>,nums[i])</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">                    nums[j-<span class="number">1</span>] = nums[j]</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;\ti——post&#x27;</span>,i)</span><br><span class="line">                size -= <span class="number">1</span>  </span><br><span class="line">                <span class="comment"># print(&quot;nums&quot;,nums)  </span></span><br><span class="line">        <span class="keyword">return</span> size</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">    target = <span class="number">2</span></span><br><span class="line">    size = removeElement(nums,val = target)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;size&quot;</span>,size)</span><br><span class="line">    <span class="built_in">print</span>(nums)</span><br><span class="line">[Running] python -u <span class="string">&quot;/Users/yuweng/Desktop/test.py&quot;</span></span><br><span class="line">i <span class="number">1</span></span><br><span class="line">nums[i] <span class="number">2</span></span><br><span class="line">i——post <span class="number">0</span></span><br><span class="line">size <span class="number">3</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-双指针（快慢指针）"><a href="#2-双指针（快慢指针）" class="headerlink" title="2.双指针（快慢指针）"></a>2.双指针（快慢指针）</h3><ul><li>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</li><li>本质上利用两个指针，一个指针进行遍历操作(寻找新数组元素)，一个指针进行更新记录操作（赋值新数组元素）</li><li>遇到等于删除的元素直接跳过</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> fast = <span class="number">0</span>; fast &lt; size; fast ++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != val)&#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow ++;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        slow = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != val:</span><br><span class="line">                nums[slow] = nums[i]</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
