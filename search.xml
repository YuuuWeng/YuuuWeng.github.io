<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>二叉树专题8</title>
      <link href="/2022/12/30/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%988/"/>
      <url>/2022/12/30/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%988/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树专题7</title>
      <link href="/2022/12/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%987/"/>
      <url>/2022/12/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%987/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树专题6</title>
      <link href="/2022/12/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%986/"/>
      <url>/2022/12/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%986/</url>
      
        <content type="html"><![CDATA[<h2 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654. 最大二叉树"></a>654. 最大二叉树</h2><p><a href="https://leetcode.cn/problems/maximum-binary-tree/">https://leetcode.cn/problems/maximum-binary-tree/</a></p><h3 id="递归（前序遍历）"><a href="#递归（前序遍历）" class="headerlink" title="递归（前序遍历）"></a>递归（前序遍历）</h3><p>凡是构造二叉树的题目都用前序遍历</p><p>和前面的思路一样</p><ul><li>终止条件，当数组为空返回None</li><li>单层逻辑：<ol><li>先寻找最大值，创建root node然后记录对应最大值的index用来split数组</li><li>然后进行递归左子树递归右子树去解决小问题</li></ol></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">constructMaximumBinaryTree</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        max_value = <span class="built_in">max</span>(nums)</span><br><span class="line">        root = TreeNode(max_value)</span><br><span class="line">        index = nums.index(max_value)</span><br><span class="line"></span><br><span class="line">        nums_left = nums[:index]</span><br><span class="line">        nums_right = nums[index + <span class="number">1</span>:]</span><br><span class="line">        root.left = self.constructMaximumBinaryTree(nums_left)</span><br><span class="line">        root.right = self.constructMaximumBinaryTree(nums_right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a>617. 合并二叉树</h2><p><a href="https://leetcode.cn/problems/merge-two-binary-trees/">https://leetcode.cn/problems/merge-two-binary-trees/</a></p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul><li>返回值和参数：参数就是两个给的树，返回值：返回合并的tree</li><li>递归终止条件：当一个空了就返回另外一个</li><li>单层逻辑：中左右，就是创建个新的node值是左边加右边。然后左右递归</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTrees</span>(<span class="params">self, root1: <span class="type">Optional</span>[TreeNode], root2: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> root1 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root2</span><br><span class="line">        <span class="keyword">if</span> root2 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root1</span><br><span class="line">        merge = TreeNode(root1.val + root2.val)</span><br><span class="line">        merge.left = self.mergeTrees(root1.left,root2.left)</span><br><span class="line">        merge.right = self.mergeTrees(root1.right,root2.right)</span><br><span class="line">        <span class="keyword">return</span> merge</span><br></pre></td></tr></table></figure><h2 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a>700. 二叉搜索树中的搜索</h2><p><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">https://leetcode.cn/problems/search-in-a-binary-search-tree/</a></p><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><ul><li>参数和返回值：参数是整个树，返回值也是树</li><li>终止条件：如果是None或者值等于给定值就返回树</li><li>单层递归逻辑： 大于就递归遍历左边，小于就递归遍历右边</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> root.val &gt; val:</span><br><span class="line">            root = root.left</span><br><span class="line">        <span class="keyword">elif</span> root.val == val:</span><br><span class="line">           <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            root = root.right</span><br><span class="line">        <span class="keyword">return</span> self.searchBST(root,val)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span> <span class="keyword">or</span> root.val == val:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; val:</span><br><span class="line">            <span class="keyword">return</span> self.searchBST(root.left,val)</span><br><span class="line">        <span class="keyword">if</span> root.val &lt; val:</span><br><span class="line">            <span class="keyword">return</span> self.searchBST(root.right,val)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树专题5</title>
      <link href="/2022/12/27/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%985/"/>
      <url>/2022/12/27/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%985/</url>
      
        <content type="html"><![CDATA[<h2 id="513-找树左下角的值（最底层最左边）"><a href="#513-找树左下角的值（最底层最左边）" class="headerlink" title="513. 找树左下角的值（最底层最左边）"></a>513. 找树左下角的值（最底层最左边）</h2><p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">https://leetcode.cn/problems/find-bottom-left-tree-value/</a></p><h3 id="迭代层序遍历"><a href="#迭代层序遍历" class="headerlink" title="迭代层序遍历"></a>迭代层序遍历</h3><ul><li>层序遍历模版，只有遇到每层的开头元素才会去赋值</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findBottomLeftValue</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="comment"># print(queue)</span></span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            total_size = <span class="built_in">len</span>(queue)</span><br><span class="line">            node = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">while</span> size:</span><br><span class="line">                <span class="keyword">if</span> total_size == <span class="built_in">len</span>(queue):</span><br><span class="line">                    node = queue.popleft()</span><br><span class="line">                    </span><br><span class="line">                    result = node.val</span><br><span class="line">                    <span class="comment"># print(result)</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    node = queue.popleft()</span><br><span class="line">                size -= <span class="number">1</span></span><br><span class="line">                <span class="comment">#这两个写在while里面，debug半天没找出来</span></span><br><span class="line">                <span class="keyword">if</span> node.left != <span class="literal">None</span>:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right != <span class="literal">None</span>:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findBottomLeftValue</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        queue = deque()</span><br><span class="line">        <span class="keyword">if</span> root: </span><br><span class="line">            queue.append(root)</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue: </span><br><span class="line">            q_len = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(q_len): </span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span>: </span><br><span class="line">                    result = queue[i].val </span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> cur.left: </span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right: </span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><a href="https://www.w3schools.com/python/ref_keyword_nonlocal.asp">https://www.w3schools.com/python/ref_keyword_nonlocal.asp</a></p><p>The <strong>nonlocal keyword</strong> is used to work with variables inside nested functions, <strong>where the variable should not belong to the inner function</strong>.</p><p>Use the keyword nonlocal to declare that the variable is not local.</p><h3 id="递归遍历（dfs）"><a href="#递归遍历（dfs）" class="headerlink" title="递归遍历（dfs）"></a>递归遍历（dfs）</h3><p>要找到左下角的值必须要找到最深处，所以需要个变量记录最大深度。只有当当前节点的深度大于最大深度的时候才会赋值给result</p><ul><li>递归函数参数：每个node的depth和每个node无返回值</li><li>递归终止条件：当node左右都子节点都为空的时候，如果当前节点的depth是大于记录的最深节点就记录成result</li><li>单层遍历逻辑： 遍历左边遍历右边。遍历的时候传depth值。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findBottomLeftValue</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root,depth</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> max_depth,result</span><br><span class="line">            <span class="keyword">if</span> root.left == <span class="literal">None</span> <span class="keyword">and</span> root.right == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> depth &gt; max_depth:</span><br><span class="line">                    max_depth = depth</span><br><span class="line">                    result = root.val</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                depth += <span class="number">1</span></span><br><span class="line">                dfs(root.left,depth)</span><br><span class="line">                <span class="comment">#回溯</span></span><br><span class="line">                depth -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                depth += <span class="number">1</span></span><br><span class="line">                dfs(root.right,depth)</span><br><span class="line">                depth -= <span class="number">1</span></span><br><span class="line">        max_depth = - <span class="built_in">float</span>(<span class="string">&quot;INF&quot;</span>)</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        dfs(root,<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a>112. 路径总和</h2><p><a href="https://leetcode.cn/problems/path-sum/">https://leetcode.cn/problems/path-sum/</a></p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>自己受到前面打印路径的启发，用了个set作为记录每条路径的数值总和。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        hashset = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root,result,hashset</span>):</span><br><span class="line">            result += root.val</span><br><span class="line">            <span class="keyword">if</span> root.left == <span class="literal">None</span> <span class="keyword">and</span> root.right == <span class="literal">None</span>:</span><br><span class="line">                hashset.add(result)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> root.left != <span class="literal">None</span>:</span><br><span class="line">                dfs(root.left,result,hashset)</span><br><span class="line">            <span class="keyword">if</span> root.right != <span class="literal">None</span>:</span><br><span class="line">                dfs(root.right,result,hashset)</span><br><span class="line">        dfs(root,result,hashset)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> targetSum <span class="keyword">in</span> hashset <span class="keyword">else</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="标准做法递归"><a href="#标准做法递归" class="headerlink" title="标准做法递归"></a>标准做法递归</h4><p>把大问题转化成小问题。<br>大问题：求根节点到叶子节点到路径sum等于value。<br>小问题：<strong>假设根节点到当前节点的路径sum是val,<br>求当前节点的子节点到叶子节点到路径和是否为sum-val</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> root.left == <span class="literal">None</span> <span class="keyword">and</span> root.right == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> targetSum == root.val</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.hasPathSum(root.left, targetSum - root.val) <span class="keyword">or</span> self.hasPathSum(root.right, targetSum - root.val) </span><br></pre></td></tr></table></figure><h4 id="递归包含回溯"><a href="#递归包含回溯" class="headerlink" title="递归包含回溯"></a>递归包含回溯</h4><ul><li>递归函数返回值和参数：node,传入的count，返回值是布尔值也就是最后这个叶子节点是true还是false</li><li>终止条件：是这个当前的传入的值被剪为0同时左右都是空</li><li>单层逻辑：终止条件是判断叶子节点，所以递归过程中不要让空节点进入递归. 然后递归处理左右节点</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">root,targetSum</span>):</span><br><span class="line">            <span class="keyword">if</span> root.left == <span class="literal">None</span> <span class="keyword">and</span> root.right == <span class="literal">None</span> <span class="keyword">and</span> targetSum ==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> root.left != <span class="literal">None</span>:</span><br><span class="line">                <span class="comment">#包含回溯</span></span><br><span class="line">                targetSum -= root.left.val</span><br><span class="line">                <span class="keyword">if</span> helper(root.left,targetSum):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                targetSum += root.left.val</span><br><span class="line">            <span class="keyword">if</span> root.right != <span class="literal">None</span>:</span><br><span class="line">                targetSum -= root.right.val</span><br><span class="line">                <span class="keyword">if</span> helper(root.right,targetSum):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">                targetSum += root.right.val</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="keyword">return</span> helper(root,targetSum-root.val)</span><br></pre></td></tr></table></figure><h2 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a>113. 路径总和 II</h2><p><a href="https://leetcode.cn/problems/path-sum-ii/">https://leetcode.cn/problems/path-sum-ii/</a></p><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><ul><li>递归函数参数和返回值：返回值是空，参数有一个count是用来递减判断路径的，有一个result是用来append合法路径的</li><li>终止条件：当两个都是空的时候终止，或者当两个都是空并且count也剪到0了就可以用result append了</li><li>单层逻辑：遍历左边遍历右边</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = <span class="built_in">list</span>()</span><br><span class="line">        path =<span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        path.append(root.val)</span><br><span class="line">        self.helper(root,targetSum-root.val,path,result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">self,root,targetSum,path,result</span>):</span><br><span class="line">        <span class="keyword">if</span> targetSum == <span class="number">0</span> <span class="keyword">and</span> root.left == <span class="literal">None</span> <span class="keyword">and</span> root.right == <span class="literal">None</span>:</span><br><span class="line">            result.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> root.left == <span class="literal">None</span> <span class="keyword">and</span> root.right == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">if</span> root.left != <span class="literal">None</span>:</span><br><span class="line">            path.append(root.left.val)</span><br><span class="line">            self.helper(root.left,targetSum -root.left.val,path,result)</span><br><span class="line">            <span class="comment"># 回溯</span></span><br><span class="line">            path.pop()</span><br><span class="line">        <span class="keyword">if</span> root.right != <span class="literal">None</span>:</span><br><span class="line">            path.append(root.right.val)</span><br><span class="line">            self.helper(root.right,targetSum -root.right.val,path,result)</span><br><span class="line">            path.pop()</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure><h2 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a>106. 从中序与后序遍历序列构造二叉树</h2><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/</a></p><h3 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h3><ol><li>如果后序数组是空说明遍历结束终止</li><li>后序遍历是左右中，所以中一定是最后的，所以索取中的index</li><li>通过index来切分中序遍历的数组</li><li>通过前面切分的数组长度来切分后序遍历的数组</li><li>递归遍历左子树然后递归遍历右子树</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, inorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> postorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#后序遍历最后一个点就是中</span></span><br><span class="line">        root_value = postorder[-<span class="number">1</span>]</span><br><span class="line">        root = TreeNode(root_value)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#找切割点</span></span><br><span class="line">        index = inorder.index(root_value)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 切割中序</span></span><br><span class="line">        inorder_left = inorder[<span class="number">0</span>:index]</span><br><span class="line">        inorder_right = inorder[index + <span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 切割后序</span></span><br><span class="line">        <span class="comment">#重点 中序数组大小和后序数组大小一定一样</span></span><br><span class="line">        postorder_left = postorder[<span class="number">0</span>:<span class="built_in">len</span>(inorder_left)]</span><br><span class="line">        postorder_right = postorder[<span class="built_in">len</span>(inorder_left):<span class="built_in">len</span>(postorder) - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        root.left = self.buildTree(inorder_left,postorder_left)</span><br><span class="line">        root.right = self.buildTree(inorder_right,postorder_right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a>105. 从前序与中序遍历序列构造二叉树</h2><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p><h3 id="递归-3"><a href="#递归-3" class="headerlink" title="递归"></a>递归</h3><p>和上面同样逻辑</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        root_value = preorder[<span class="number">0</span>]</span><br><span class="line">        root = TreeNode(root_value)</span><br><span class="line">        index = inorder.index(root_value)</span><br><span class="line"></span><br><span class="line">        inorder_left = inorder[:index]</span><br><span class="line">        inorder_right = inorder[index + <span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        preorder_left = preorder[<span class="number">1</span>:<span class="built_in">len</span>(inorder_left)+ <span class="number">1</span>]</span><br><span class="line">        preorder_right = preorder[<span class="built_in">len</span>(inorder_left) + <span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        root.left = self.buildTree(preorder_left,inorder_left)</span><br><span class="line">        root.right = self.buildTree(preorder_right,inorder_right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树专题4</title>
      <link href="/2022/12/27/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%984/"/>
      <url>/2022/12/27/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%984/</url>
      
        <content type="html"><![CDATA[<h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a>110. 平衡二叉树</h2><p><a href="https://leetcode.cn/problems/balanced-binary-tree/">https://leetcode.cn/problems/balanced-binary-tree/</a></p><p>本题中，一棵高度平衡二叉树定义为：<br>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1</p><ul><li>求高度用后序遍历</li><li>求深度用前序遍历</li></ul><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul><li>明确递归函数的参数和返回值: 参数就是当前节点,返回值就是当前节点的树的高度</li><li>终止条件: 遇到空节点就返回高度是0</li><li>单层递归的逻辑<ol><li>求左右子树的高度差值，如果高度大于1就<strong>返回-1</strong></li></ol></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isBalanced</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> self.getHeight(root) == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getHeight</span>(<span class="params">self,root</span>):</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment">#左</span></span><br><span class="line">        left_h = self.getHeight(root.left)</span><br><span class="line">        <span class="keyword">if</span> left_h == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="comment">#右</span></span><br><span class="line">        right_h = self.getHeight(root.right)</span><br><span class="line">        <span class="keyword">if</span> right_h == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="comment">#中</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(left_h - right_h) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        result = <span class="number">1</span> + <span class="built_in">max</span>(left_h,right_h)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">        </span><br></pre></td></tr></table></figure><h2 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a>257. 二叉树的所有路径</h2><p><a href="https://leetcode.cn/problems/binary-tree-paths/">https://leetcode.cn/problems/binary-tree-paths/</a></p><h3 id="递归（前序遍历）"><a href="#递归（前序遍历）" class="headerlink" title="递归（前序遍历）"></a>递归（前序遍历）</h3><ul><li>利用path记录每个path</li><li>利用result对每个path进行append</li></ul><p>递归函数的参数和返回值:参数有node,result列表，path字符串<br>终止条件：当node.left和node.right都是空的时候把path加入到结果中<br>单层逻辑：对于每层如果node.left存在就进行递归，node.right存在就进行递归</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">binaryTreePaths</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        path = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node,result,path</span>):</span><br><span class="line">            <span class="comment">#中：写在这里是为了避免叶子节点没有被加入到path里面</span></span><br><span class="line">            path += <span class="built_in">str</span>(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left == <span class="literal">None</span> <span class="keyword">and</span> node.right == <span class="literal">None</span>:</span><br><span class="line">                result.append(path)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> node.left != <span class="literal">None</span>:</span><br><span class="line">                <span class="comment">#回溯的过程其实就是删掉&quot;-&gt;&quot;</span></span><br><span class="line">                dfs(node.left,result,path + <span class="string">&#x27;-&gt;&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> node.right != <span class="literal">None</span>:</span><br><span class="line">                dfs(node.right,result,path + <span class="string">&#x27;-&gt;&#x27;</span>)</span><br><span class="line">        dfs(root,result,path)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a>404. 左叶子之和</h2><p><a href="https://leetcode.cn/problems/sum-of-left-leaves/">https://leetcode.cn/problems/sum-of-left-leaves/</a></p><h3 id="递归（后序遍历）"><a href="#递归（后序遍历）" class="headerlink" title="递归（后序遍历）"></a>递归（后序遍历）</h3><ul><li>递归函数返回值和参数：返回值类型是int，参数是node</li><li>终止条件是：节点是none 返回0</li><li>单层逻辑：遇到左叶子节点就记录数值然后递归求取左子树左叶子之和和右子树的左叶子之和<br>重点是通过节点的父节点来判断本节点的属性</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumOfLeftLeaves</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> root.left == <span class="literal">None</span> <span class="keyword">and</span> root.right == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left_val = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> root.left != <span class="literal">None</span> <span class="keyword">and</span> root.left.left == <span class="literal">None</span> <span class="keyword">and</span> root.left.right == <span class="literal">None</span>:</span><br><span class="line">            left_val = root.left.val</span><br><span class="line">        <span class="keyword">return</span> left_val + self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树专题3</title>
      <link href="/2022/12/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%983/"/>
      <url>/2022/12/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%983/</url>
      
        <content type="html"><![CDATA[<h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h2><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">https://leetcode.cn/problems/maximum-depth-of-binary-tree/</a></p><ul><li><strong>二叉树高度</strong>是指二叉树中任意一个节点到叶子节点到距离，根节点到高度是最大的（用<strong>后序</strong>从下往上去计数）</li><li><strong>二叉树深度</strong>是指任意一个节点到根节点的距离，叶子节点深度最大（用<strong>前序</strong>从上往下去计数）</li></ul><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul><li>用后序遍历求高度得出的结论就是二叉树的深度</li><li>停止条件就是遍历到none节点 return 0</li><li>每层都是求left的height然后求right的height</li><li>最后返回是 1 + max(left_height,right_height)</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.getHeight(root)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getHeight</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        lh = self.getHeight(root.left)</span><br><span class="line">        rh = self.getHeight(root.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(lh,rh)</span><br></pre></td></tr></table></figure><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><ul><li>套层序遍历模版然后一样用queue每遍历一层就加一</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> count</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="keyword">while</span> size:</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> node.left != <span class="literal">None</span>: queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right != <span class="literal">None</span>: queue.append(node.right)</span><br><span class="line">                size -= <span class="number">1</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h2 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a>111. 二叉树的最小深度</h2><p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">https://leetcode.cn/problems/minimum-depth-of-binary-tree/</a></p><h3 id="递归-后序求高度的逻辑来求的深度"><a href="#递归-后序求高度的逻辑来求的深度" class="headerlink" title="递归 (后序求高度的逻辑来求的深度)"></a>递归 (后序求高度的逻辑来求的深度)</h3><p>暂未理解</p><h3 id="层序遍历-1"><a href="#层序遍历-1" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>重点：套层序遍历模版，<strong>判断条件当node.left和node.right都是空的时候才会去return count</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            size  = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="comment"># count必须写前面</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> size:</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> node.left != <span class="literal">None</span>:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right != <span class="literal">None</span>:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> node.left == <span class="literal">None</span> <span class="keyword">and</span> node.right == <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">return</span> count</span><br><span class="line">                size -= <span class="number">1</span> </span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">        </span><br></pre></td></tr></table></figure><h2 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a>222. 完全二叉树的节点个数</h2><p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">https://leetcode.cn/problems/count-complete-tree-nodes/</a></p><h3 id="递归-后序"><a href="#递归-后序" class="headerlink" title="递归 (后序)"></a>递归 (后序)</h3><p>复杂度O(n)</p><ul><li>和求最大深度一个道理但是没有来max()</li><li>而是每遍历一次加一</li><li>终止条件就是root是None</li><li>每次递归条件就是left + right + 1</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countNodes</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.num(root)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">num</span>(<span class="params">self,root</span>):</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = self.num(root.left)</span><br><span class="line">        right = self.num(root.right)</span><br><span class="line">        <span class="keyword">return</span> left + right + <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="迭代（层序遍历）"><a href="#迭代（层序遍历）" class="headerlink" title="迭代（层序遍历）"></a>迭代（层序遍历）</h3><p>复杂度O(n)</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countNodes</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="keyword">while</span> size:</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> node.left != <span class="literal">None</span>: queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right != <span class="literal">None</span>: queue.append(node.right)</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                size -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p><a href="https://baike.baidu.com/item/%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/5622348">https://baike.baidu.com/item/%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/5622348</a></p><p>左移运算符（&lt;&lt;）规则：<br>3 &lt;&lt; 2，则是将数字3左移2位 &#x3D; 3 * 2^2 &#x3D; 12<br>在数字没有溢出的前提下，对于正数和负数，左移一位都相当于乘以2的1次方，左移n位就相当于乘以2的n次方。<br>右移运算符（&gt;&gt;）规则：<br>右移一位相当于除2，右移n位相当于除以2的n次方。</p><h3 id="完全二叉树方法"><a href="#完全二叉树方法" class="headerlink" title="完全二叉树方法"></a>完全二叉树方法</h3><p>时间复杂度：O(logn *logn)<br>空间复杂度 O(logn)</p><ul><li>终止条件：<ol><li>root是none return 0 </li><li>当计算的只遍历左边二叉树和只遍历右边二叉树的长度是一样的时候return 2**k - 1（这个k从1开始计算）</li></ol></li><li>单层遍历<ol><li>初始四个参数一个是left被赋值成root.left和left长度的count</li><li>一个是right被赋值成root.right和right的长度的count</li><li>一直遍历left和right求出长度</li><li>单层回归逻辑还是左右中，中为+1</li></ol></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countNodes</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left_len = <span class="number">1</span></span><br><span class="line">        right_len = <span class="number">1</span></span><br><span class="line">        left = root.left</span><br><span class="line">        right = root.right</span><br><span class="line">        <span class="keyword">while</span> left != <span class="literal">None</span>:<span class="comment">#求左子树深度</span></span><br><span class="line">            left_len += <span class="number">1</span></span><br><span class="line">            left = left.left</span><br><span class="line">        <span class="keyword">while</span> right != <span class="literal">None</span>:<span class="comment">#求右子树深度</span></span><br><span class="line">            right_len += <span class="number">1</span></span><br><span class="line">            right = right.right</span><br><span class="line">        <span class="keyword">if</span> left_len == right_len: <span class="keyword">return</span> <span class="number">2</span>**left_len - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.countNodes(root.left) + self.countNodes(root.right) + <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树专题2</title>
      <link href="/2022/12/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%982/"/>
      <url>/2022/12/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%982/</url>
      
        <content type="html"><![CDATA[<h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a>102. 二叉树的层序遍历</h2><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">https://leetcode.cn/problems/binary-tree-level-order-traversal/</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>利用队列</li><li>重点是要用size记录每层的queue的长度</li><li>cur指向当前pop的节点然后当cur.left不为空加入到queue当cur.right不为空加入到queue</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        queue.append(root)</span><br><span class="line">        cur = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            result = []</span><br><span class="line">            <span class="keyword">while</span> size:</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                result.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left != <span class="literal">None</span>:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right != <span class="literal">None</span>:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">                size -= <span class="number">1</span></span><br><span class="line">            res.append(result)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a>226. 翻转二叉树</h2><p><a href="https://leetcode.cn/problems/invert-binary-tree/description/">https://leetcode.cn/problems/invert-binary-tree/description/</a></p><h3 id="深度优先遍历递归（前序和后序都可以，目前只提供了前序）"><a href="#深度优先遍历递归（前序和后序都可以，目前只提供了前序）" class="headerlink" title="深度优先遍历递归（前序和后序都可以，目前只提供了前序）"></a>深度优先遍历递归（前序和后序都可以，目前只提供了前序）</h3><ul><li>前序和后序都可以做</li><li>中序遍历回产生重复交换</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root.left, root.right = root.right, root.left</span><br><span class="line">        self.invertTree(root.left)</span><br><span class="line">        self.invertTree(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h3 id="深度优先遍历迭代-（前序和后序都可以，目前只提供了前序）"><a href="#深度优先遍历迭代-（前序和后序都可以，目前只提供了前序）" class="headerlink" title="深度优先遍历迭代 （前序和后序都可以，目前只提供了前序）"></a>深度优先遍历迭代 （前序和后序都可以，目前只提供了前序）</h3><ul><li>和前序一样，当栈不是空的就从栈中pop出来就交换</li><li>如果cur.left存在就加入栈中</li><li>如果cur.right存在就加入栈中</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        stack = []</span><br><span class="line">        stack.append(root)</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            cur = stack.pop()</span><br><span class="line">            cur.left, cur.right = cur.right, cur.left</span><br><span class="line">            <span class="keyword">if</span> cur.left != <span class="literal">None</span>:</span><br><span class="line">                stack.append(cur.left)</span><br><span class="line">            <span class="keyword">if</span> cur.right != <span class="literal">None</span>:</span><br><span class="line">                stack.append(cur.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h3 id="广度优先遍历迭代"><a href="#广度优先遍历迭代" class="headerlink" title="广度优先遍历迭代"></a>广度优先遍历迭代</h3><ul><li>(queue记录)同样利用size记录每层</li><li>当queue不是空的时候，记录size，当size不是空的时候就pop出来然后交换pop出来的节点left和right</li><li>之后cur.left不是空就加入，cur.right不是空就加入</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="keyword">while</span> size:</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                cur.left, cur.right = cur.right, cur.left</span><br><span class="line">                <span class="keyword">if</span> cur.left != <span class="literal">None</span>:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right != <span class="literal">None</span>:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">                size -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h2><p><a href="https://leetcode.cn/problems/symmetric-tree/">https://leetcode.cn/problems/symmetric-tree/</a></p><h3 id="递归（可以看成是后序）"><a href="#递归（可以看成是后序）" class="headerlink" title="递归（可以看成是后序）"></a>递归（可以看成是后序）</h3><ol><li>确定函数参数和返回值：compare(left,right) 返回值是boolean</li><li>终止条件四个：需要最后判断val，因为会出现nontype问题</li></ol><ul><li>左孩子空右孩子不是空 - False</li><li>左孩子不是空右孩子是空 - False</li><li>左孩子和右孩子都是空 - True</li><li>左孩子和右孩子的val值不一样 - False</li></ul><ol start="3"><li>判断outside是compare左节点的左边后右节点的右边</li><li>判断inside compare左节点的右边和右节点的左边</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">return</span> self.compare(root.left,root.right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compare</span>(<span class="params">self,left,right</span>):</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> left == <span class="literal">None</span> <span class="keyword">and</span> right != <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> left != <span class="literal">None</span> <span class="keyword">and</span> right == <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> left == <span class="literal">None</span> <span class="keyword">and</span> right == <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> left.val != right.val: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment">#左右中或者右左中</span></span><br><span class="line">        outside = self.compare(left.left,right.right)</span><br><span class="line">        inside = self.compare(left.right,right.left)</span><br><span class="line">        <span class="keyword">return</span> outside <span class="keyword">and</span> inside</span><br></pre></td></tr></table></figure><h3 id="迭代-（使用队列）"><a href="#迭代-（使用队列）" class="headerlink" title="迭代 （使用队列）"></a>迭代 （使用队列）</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul><li>利用队列先判断根节点是不是none</li><li>queue再进行append左节点和右节点</li><li>进入while循环当queue不是空的时候停止</li><li>pop出来两个节点进行比较</li><li>如果都是none的话就continue，因为到最后queue里面存放的全都是none的节点</li><li>其他就是和上面的思路一样左右节点一个为空return false</li><li>左右节点的值不一样return false</li><li>遍历完成return true</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root.left)</span><br><span class="line">        queue.append(root.right)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            pop1 = queue.popleft()</span><br><span class="line">            pop2 = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> pop1 == <span class="literal">None</span> <span class="keyword">and</span> pop2 == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> pop1 == <span class="literal">None</span> <span class="keyword">and</span> pop2 != <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> pop1 != <span class="literal">None</span> <span class="keyword">and</span> pop2 == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> pop1.val != pop2.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            queue.append(pop1.left)</span><br><span class="line">            queue.append(pop2.right)</span><br><span class="line">            queue.append(pop1.right)</span><br><span class="line">            queue.append(pop2.left)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树专题1</title>
      <link href="/2022/12/24/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%981/"/>
      <url>/2022/12/24/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%981/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树理论基础"><a href="#二叉树理论基础" class="headerlink" title="二叉树理论基础"></a>二叉树理论基础</h2><h3 id="二叉树种类"><a href="#二叉树种类" class="headerlink" title="二叉树种类"></a>二叉树种类</h3><h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><ol><li><strong>每层的节点数都达到最大值</strong></li><li><strong>如果这有k层，那么总节点数是(2^k) - 1,那么就是满二叉树</strong></li></ol><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p><strong>简单点的定义</strong>：除了最后一层，其他每层的节点数量都是满的，并且在最后一层所有的节点都是集中在这一层的最左边的位置</p><p>假设深度有h层，除了最后一层h层以外，其他层（1-h-1）都是满节点，然后最后一层都集中在靠左的位置。</p><p><strong>优先级队列是个堆，所以就是完全二叉树</strong></p><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><ul><li>有数值并且有序</li><li>可以不是满二叉树也不是完全二叉树</li><li>当左子树不是空时，左子树子节点 &lt; 根节点</li><li>当右子树不是空时，右子树子节点 &lt; 根节点</li></ul><h4 id="平衡二叉搜索树-AVL"><a href="#平衡二叉搜索树-AVL" class="headerlink" title="平衡二叉搜索树 AVL"></a>平衡二叉搜索树 AVL</h4><p><strong>性质</strong></p><ol><li>一个空树</li><li>或者左右两个子树的高度差绝对值不超过一，并且左右两个子树都是平衡二叉树</li></ol><h3 id="二叉树储存方式"><a href="#二叉树储存方式" class="headerlink" title="二叉树储存方式"></a>二叉树储存方式</h3><h4 id="链式储存（指针）"><a href="#链式储存（指针）" class="headerlink" title="链式储存（指针）"></a>链式储存（指针）</h4><ul><li>通过指针把分布在各个地址上面的节点串联到一起</li><li>每一个节点都有三个位置，一个是存放value,一个是存放左指针，一个是存放右指针</li></ul><h4 id="顺序储存（数组）"><a href="#顺序储存（数组）" class="headerlink" title="顺序储存（数组）"></a>顺序储存（数组）</h4><ul><li>内存是连续的</li><li>从上到下从左到右的顺序是下标，根节点是0</li><li>树的节点储存的是值</li></ul><p><strong>对于遍历二叉树数组，当父节点下标是i,左孩子就是 2 * i + 1<br>右孩子就是 2 * i + 2，i从0开始</strong></p><h3 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h3><h4 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h4><ul><li>前序遍历（递归法，迭代法） 中左右（是指整个的左子树和右子树）</li><li>中序遍历（递归法，迭代法） 左中右</li><li>后序遍历（递归法，迭代法） 左右中</li></ul><p>可以利用栈使用非递归的方式来实现</p><h4 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h4><ul><li>层次遍历（迭代法）</li></ul><p>可以利用队列的先进先出来实现</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>: </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.value = value</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">      <span class="built_in">this</span>.val = val;</span><br><span class="line">      <span class="built_in">this</span>.left = left;</span><br><span class="line">      <span class="built_in">this</span>.right = right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h2><p>递归遍历的三个条件</p><ol><li>递归函数的参数和返回值</li><li>终止条件</li><li>单层递归逻辑</li></ol><p>递归逻辑：每一次调用，都会把函数的局部变量，返回地址，参数值等参数压入栈中，然后递归返回会从栈顶弹出是一次递归的所有存入参数。</p><h3 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a>144. 二叉树的前序遍历</h3><p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">https://leetcode.cn/problems/binary-tree-preorder-traversal/</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        self.pre(root,res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pre</span>(<span class="params">self,node,result</span>):</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        result.append(node.val)</span><br><span class="line">        self.pre(node.left,result)</span><br><span class="line">        self.pre(node.right, result)</span><br></pre></td></tr></table></figure><h3 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a>145. 二叉树的后序遍历</h3><p><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">https://leetcode.cn/problems/binary-tree-postorder-traversal/</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        self.post(root,res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">post</span>(<span class="params">self,node,res</span>):</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.post(node.left,res)</span><br><span class="line">        self.post(node.right,res )</span><br><span class="line">        res.append(node.val)</span><br></pre></td></tr></table></figure><h3 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a>94. 二叉树的中序遍历</h3><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">https://leetcode.cn/problems/binary-tree-inorder-traversal/</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        self.inorder(root,res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">self,node,res</span>):</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.inorder(node.left,res)</span><br><span class="line">        res.append(node.val)</span><br><span class="line">        self.inorder(node.right,res)</span><br></pre></td></tr></table></figure><h2 id="二叉树的迭代法模拟递归遍历（利用栈）"><a href="#二叉树的迭代法模拟递归遍历（利用栈）" class="headerlink" title="二叉树的迭代法模拟递归遍历（利用栈）"></a>二叉树的迭代法模拟递归遍历（利用栈）</h2><p>只有pop掉才会继续append</p><h3 id="144-二叉树的前序遍历-1"><a href="#144-二叉树的前序遍历-1" class="headerlink" title="144. 二叉树的前序遍历"></a>144. 二叉树的前序遍历</h3><p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">https://leetcode.cn/problems/binary-tree-preorder-traversal/</a></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>中左右变成了<strong>中右左</strong></li><li>所以出栈顺序变成了中左右</li></ul><ol><li>先添加root节点到stack中</li><li>当栈不是空的时候，利用指针记录pop出来的元素</li><li>然后加入到result中</li><li>判断pop出来的元素是否有右节点，如果有加到栈中</li><li>判断pop出来的元素是否有左节点，如果有加到栈中</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        stack = collections.deque()</span><br><span class="line">        stack.append(root)</span><br><span class="line">        node = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> (stack):</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">None</span>:</span><br><span class="line">                res.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.right != <span class="literal">None</span>:</span><br><span class="line">                    stack.append(node.right)</span><br><span class="line">                <span class="keyword">if</span> node.left != <span class="literal">None</span>:</span><br><span class="line">                    stack.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="145-二叉树的后序遍历-1"><a href="#145-二叉树的后序遍历-1" class="headerlink" title="145. 二叉树的后序遍历"></a>145. 二叉树的后序遍历</h3><p><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">https://leetcode.cn/problems/binary-tree-postorder-traversal/</a></p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul><li>左右中 </li><li>入栈顺序是中左右 所有出来是中右左，然后reverse是左右中</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        stack = collections.deque()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        stack.append(root)</span><br><span class="line">        node = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left != <span class="literal">None</span>:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right != <span class="literal">None</span>:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">        res.reverse()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="94-二叉树的中序遍历-1"><a href="#94-二叉树的中序遍历-1" class="headerlink" title="94. 二叉树的中序遍历"></a>94. 二叉树的中序遍历</h3><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">https://leetcode.cn/problems/binary-tree-inorder-traversal/</a></p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>左中右</p><ul><li>因为遍历的node和存储到stack的node不一样</li><li>所以引入遍历指针cur指向当前的root节点</li><li><strong>当cur指针节点不是空或者stack不是空的时候才会停止</strong></li></ul><ol><li>if 当前cur指针不是空的话就push到栈中<br>cur指针继续指向下一个left节点</li><li>if cur指针是空的话就从栈里pop出来 让cur指针回指pop出来的节点，记录当前节点的val到result里然后让指针指向cur.right</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        cur = root</span><br><span class="line">        stack = collections.deque()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span> <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> cur != <span class="literal">None</span>:</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = stack.pop()</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="二叉树的统一迭代法"><a href="#二叉树的统一迭代法" class="headerlink" title="二叉树的统一迭代法"></a>二叉树的统一迭代法</h2><p>搁置中</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈与队列专题3</title>
      <link href="/2022/12/22/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%93%E9%A2%983/"/>
      <url>/2022/12/22/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%93%E9%A2%983/</url>
      
        <content type="html"><![CDATA[<h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a>239. 滑动窗口最大值</h2><p><a href="https://leetcode.cn/problems/sliding-window-maximum/">https://leetcode.cn/problems/sliding-window-maximum/</a></p><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回 滑动窗口中的最大值 。</p><p> </p><p>示例 1：</p><p>输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3<br>输出：[3,3,5,5,6,7]<br>解释：<br>滑动窗口的位置           —- 最大值</p><hr><p>[1  3  -1] -3  5  3  6  7       —- 3<br> 1 [3  -1  -3] 5  3  6  7       —- 3<br> 1  3 [-1  -3  5] 3  6  7       —- 5<br> 1  3  -1 [-3  5  3] 6  7       —- 5<br> 1  3  -1  -3 [5  3  6] 7       —- 6<br> 1  3  -1  -3  5 [3  6  7]      —- 7<br>示例 2：</p><p>输入：nums &#x3D; [1], k &#x3D; 1<br>输出：[1] </p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104<br>1 &lt;&#x3D; k &lt;&#x3D; nums.length</p><h3 id="思路（单调队列用deque实现）"><a href="#思路（单调队列用deque实现）" class="headerlink" title="思路（单调队列用deque实现）"></a>思路（单调队列用deque实现）</h3><p>5 - 3 + 1 &#x3D; 3 用角标的差值查看数量 [3,4,5]</p><ul><li>滑动数组的题目最适合单调队列</li><li><strong>创建deque存角标为后面的滑动数组保证在提供的k size内<br>如果当前遍历的i - 队列最开头存放的角标 + 1 &gt; 滑动窗口内的元素数量 则popleft() 把左边的元素pop掉保证滑动窗口元素数量一致</strong></li><li>另外单调队列保证窗口头部元素永远是最大的，利用while当当前要遍历的元素大于等于队尾元素的时候pop()掉尾部元素。同时要保证这个deque不是空的</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            <span class="keyword">while</span> queue <span class="keyword">and</span> nums[i] &gt;= nums[queue[-<span class="number">1</span>]]:</span><br><span class="line">                queue.pop()</span><br><span class="line">            queue.append(i)</span><br><span class="line">        res.append(nums[queue[<span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k,<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> i - queue[<span class="number">0</span>] == k:</span><br><span class="line">                queue.popleft()</span><br><span class="line">            <span class="keyword">while</span> queue <span class="keyword">and</span> nums[i] &gt;= nums[queue[-<span class="number">1</span>]]:</span><br><span class="line">                queue.pop()</span><br><span class="line">            queue.append(i)</span><br><span class="line">            res.append(nums[queue[<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a>347. 前 K 个高频元素</h2><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/">https://leetcode.cn/problems/top-k-frequent-elements/</a></p><p>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。</p><p>示例 1:</p><p>输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2<br>输出: [1,2]<br>示例 2:</p><p>输入: nums &#x3D; [1], k &#x3D; 1<br>输出: [1]</p><p>提示：<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>k 的取值范围是 [1, 数组中不相同的元素的个数]<br>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的</p><h3 id="python-heapq-库"><a href="#python-heapq-库" class="headerlink" title="python heapq 库"></a>python heapq 库</h3><p><a href="https://www.geeksforgeeks.org/heap-queue-or-heapq-in-python/">https://www.geeksforgeeks.org/heap-queue-or-heapq-in-python/</a><br>提供了小根堆堆方法和基本操作</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">方法</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line">heapq.heapify(iterable)：把iterable换成heap结构</span><br><span class="line">heapq.heappush(heap, ele)</span><br><span class="line">heapq.heappop(heap):remove <span class="keyword">and</span> <span class="keyword">return</span> the smallest element <span class="keyword">from</span> the heap</span><br><span class="line"></span><br><span class="line">**如果push的是<span class="built_in">tuple</span>的话会根据第一个element 进行排序</span><br><span class="line">pop出来以后heappop(<span class="built_in">tuple</span>/<span class="built_in">list</span>)[<span class="number">0</span>或者<span class="number">1</span>]**</span><br><span class="line"></span><br><span class="line">heapq.nlargest(k, iterable, key = fun)</span><br><span class="line">heapq.nsmallest(k, iterable, key = fun)</span><br><span class="line"></span><br><span class="line">首先定义heap heap = []</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"> </span><br><span class="line"><span class="comment"># initializing list</span></span><br><span class="line">li = [<span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># using heapify to convert list into heap</span></span><br><span class="line">heapq.heapify(li)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># printing created heap</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The created heap is : &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(li))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># using heappush() to push elements into heap</span></span><br><span class="line"><span class="comment"># pushes 4</span></span><br><span class="line">heapq.heappush(li, <span class="number">4</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># printing modified heap</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The modified heap after push is : &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(li))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># using heappop() to pop smallest element</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The popped and smallest element is : &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(heapq.heappop(li))</span><br><span class="line">The created heap <span class="keyword">is</span> : [<span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>]</span><br><span class="line">The modified heap after push <span class="keyword">is</span> : [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br><span class="line">The popped <span class="keyword">and</span> smallest element <span class="keyword">is</span> : <span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span>(重点，pop是pop smallest的元素)</span><br><span class="line"><span class="number">7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># importing &quot;heapq&quot; to implement heap queue</span></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="comment"># initializing list</span></span><br><span class="line">li1 = [<span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># using heapify() to convert list into heap</span></span><br><span class="line">heapq.heapify(li1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># using nlargest to print 3 largest numbers</span></span><br><span class="line"><span class="comment"># prints 10, 9 and 8</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The 3 largest numbers in list are : &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(heapq.nlargest(<span class="number">3</span>, li1))</span><br><span class="line"></span><br><span class="line"><span class="comment"># using nsmallest to print 3 smallest numbers</span></span><br><span class="line"><span class="comment"># prints 1, 3 and 4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The 3 smallest numbers in list are : &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(heapq.nsmallest(<span class="number">3</span>, li1))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="思路（topk大用小根堆）"><a href="#思路（topk大用小根堆）" class="headerlink" title="思路（topk大用小根堆）"></a>思路（topk大用小根堆）</h3><p>一般我们说 topK 问题，就可以用大顶堆或小顶堆来实现，<br>最大的 K 个：小顶堆<br>最小的 K 个：大顶堆</p><p><strong>从 排序的O(nlogn)优化成 O(nlogk) k表示里面存放的元素</strong></p><p>1.先创建map生成每个key对应的频率<br>2.再利用heapq创建小根堆进行push和pop操作，维持只有k个数的小根堆<br>3.因为生成的是小根堆需要pop出来的元素也是从小到大进行pop，所以需要先创建一个赋值好的全是0 size是k的list，然后从后面往前进行遍历重新赋值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">topKFrequent</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">        dict_ = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            dict_[i] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        heap = []</span><br><span class="line">        <span class="keyword">for</span> i,j <span class="keyword">in</span> dict_.items():</span><br><span class="line">            heapq.heappush(heap,(j,i))</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(heap) &gt; k:</span><br><span class="line">                heapq.heappop(heap)</span><br><span class="line">        result = [<span class="number">0</span>] * k</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            result[i] = heapq.heappop(heap)[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈与队列专题2</title>
      <link href="/2022/12/21/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%93%E9%A2%982/"/>
      <url>/2022/12/21/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%93%E9%A2%982/</url>
      
        <content type="html"><![CDATA[<h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h2><p><a href="https://leetcode.cn/problems/valid-parentheses/">https://leetcode.cn/problems/valid-parentheses/</a></p><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>每个右括号都有一个对应的相同类型的左括号。<br>示例 1：</p><p>输入：s &#x3D; “()”<br>输出：true<br>示例 2：</p><p>输入：s &#x3D; “()[]{}”<br>输出：true<br>示例 3：</p><p>输入：s &#x3D; “(]”<br>输出：false</p><h3 id="（思路）利用栈"><a href="#（思路）利用栈" class="headerlink" title="（思路）利用栈"></a>（思路）利用栈</h3><ul><li>挺难想的一道题 利用python的list当作栈使用</li><li>遇到对应左括号添加右括号 （到遍历右括号遇到相同的就pop出去）</li><li>如果左括号遍历，遍历右括号分三种情况</li></ul><ol><li>stack里面是空的说明右括号多出来</li><li>stack最后一个元素和当前的遍历的括号不一样</li><li>遍历完成的时候stack不是空的说明有左括号多出来了</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        dict_ = &#123;<span class="string">&#x27;(&#x27;</span>:<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;&#123;&#x27;</span>:<span class="string">&#x27;&#125;&#x27;</span>,<span class="string">&#x27;[&#x27;</span>:<span class="string">&#x27;]&#x27;</span>&#125;</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                stack.append(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> i == <span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">                stack.append(<span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> i == <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">                stack.append(<span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> stack <span class="keyword">or</span> i != stack[-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.pop()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047. 删除字符串中的所有相邻重复项"></a>1047. 删除字符串中的所有相邻重复项</h2><p><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/</a></p><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p><p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p><p>示例：</p><p>输入：”abbaca”<br>输出：”ca”<br>解释：<br>例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>简单题，push到栈中然后遇到和stack的顶端元素一样的就pop()</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> stack <span class="keyword">and</span> stack[-<span class="number">1</span>] == i:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(stack)</span><br></pre></td></tr></table></figure><h2 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a>150. 逆波兰表达式求值</h2><p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">https://leetcode.cn/problems/evaluate-reverse-polish-notation/</a></p><p>根据 逆波兰表示法，求表达式的值。</p><p>有效的算符包括 +、-、*、&#x2F; 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><p>注意 两个整数之间的除法只保留整数部分。</p><p>可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p><p> </p><p>示例 1：</p><p>输入：tokens &#x3D; [“2”,”1”,”+”,”3”,”*”]<br>输出：9<br>解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) &#x3D; 9<br>示例 2：</p><p>输入：tokens &#x3D; [“4”,”13”,”5”,”&#x2F;“,”+”]<br>输出：6<br>解释：该算式转化为常见的中缀算术表达式为：(4 + (13 &#x2F; 5)) &#x3D; 6<br>示例 3：</p><p>输入：tokens &#x3D; [“10”,”6”,”9”,”3”,”+”,”-11”,”<em>“,”&#x2F;“,”</em>“,”17”,”+”,”5”,”+”]<br>输出：22<br>解释：该算式转化为常见的中缀算术表达式为：<br>  ((10 * (6 &#x2F; ((9 + 3) * -11))) + 17) + 5<br>&#x3D; ((10 * (6 &#x2F; (12 * -11))) + 17) + 5<br>&#x3D; ((10 * (6 &#x2F; -132)) + 17) + 5<br>&#x3D; ((10 * 0) + 17) + 5<br>&#x3D; (0 + 17) + 5<br>&#x3D; 17 + 5<br>&#x3D; 22</p><p>逆波兰表达式：</p><p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p><p>平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。<br>该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。<br>逆波兰表达式主要有以下两个优点：</p><p>去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。<br><strong>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</strong></p><h3 id="python-x2F-x2F-x2F-round-int-的区别"><a href="#python-x2F-x2F-x2F-round-int-的区别" class="headerlink" title="python &#x2F;&#x2F; , &#x2F; , round , int()的区别"></a>python &#x2F;&#x2F; , &#x2F; , round , int()的区别</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">// 是整除的意思会向小取整</span><br><span class="line"><span class="built_in">int</span> 是向<span class="number">0</span>取整</span><br><span class="line"><span class="built_in">round</span> 四舍五入</span><br><span class="line"><span class="keyword">import</span> math </span><br><span class="line">math.ceil() 向上取整</span><br><span class="line">math.floor()向下取整</span><br><span class="line"></span><br><span class="line"><span class="number">5</span> / <span class="number">2</span>     输出： <span class="number">2.5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>(<span class="number">5</span>/<span class="number">2</span>)  输出：  <span class="number">2</span></span><br><span class="line"><span class="number">5</span> // <span class="number">2</span>    输出：  <span class="number">2</span></span><br><span class="line"></span><br><span class="line">-<span class="number">5</span> / <span class="number">2</span>    输出： -<span class="number">2.5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>(-<span class="number">5</span>/<span class="number">2</span>) 输出： -<span class="number">2</span></span><br><span class="line">-<span class="number">5</span> // <span class="number">2</span>   输出： -<span class="number">3</span> 重要！！</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="python-eval-表达式"><a href="#python-eval-表达式" class="headerlink" title="python eval 表达式"></a>python eval 表达式</h3><p><a href="https://www.programiz.com/python-programming/methods/built-in/eval">https://www.programiz.com/python-programming/methods/built-in/eval</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(expression, <span class="built_in">globals</span>=<span class="literal">None</span>, <span class="built_in">locals</span>=<span class="literal">None</span>)</span><br><span class="line">expression: A String, that will be evaluated <span class="keyword">as</span> Python code</span><br><span class="line">number = <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># eval performs the multiplication passed as argument</span></span><br><span class="line">square_number = <span class="built_in">eval</span>(<span class="string">&#x27;number * number&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(square_number)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output: 81</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&#x27;x + 1&#x27;</span>)) ---output: <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>把 加减乘除 放到set中，因为set的查询是O(1)</li><li>利用stack 遇到不是加减乘除就加进去</li><li>遇到加减乘除就pop出来倒数最后两个和符号进行操作</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">evalRPN</span>(<span class="params">self, tokens: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        c = &#123;<span class="string">&quot;+&quot;</span>, <span class="string">&quot;-&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="string">&quot;/&quot;</span>&#125;</span><br><span class="line">        stack = []</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> c:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                a = <span class="built_in">int</span>(stack.pop())</span><br><span class="line">                b = <span class="built_in">int</span>(stack.pop())</span><br><span class="line">                <span class="keyword">if</span> i == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    res = b * a</span><br><span class="line">                <span class="keyword">elif</span> i == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    res = b - a</span><br><span class="line">                <span class="keyword">elif</span> i == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    res = b + a</span><br><span class="line">                <span class="keyword">elif</span> i == <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    <span class="comment">#加int向0取整</span></span><br><span class="line">                    res = <span class="built_in">int</span>(b / a)</span><br><span class="line">                stack.append(<span class="built_in">str</span>(res))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(stack.pop())</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python list操作</title>
      <link href="/2022/12/21/python-list%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/12/21/python-list%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="python-list-包含的方法-amp-函数"><a href="#python-list-包含的方法-amp-函数" class="headerlink" title="python list 包含的方法&amp; 函数"></a>python list 包含的方法&amp; 函数</h2><p>参考：<br><a href="https://www.runoob.com/python/python-lists.html">https://www.runoob.com/python/python-lists.html</a><br>and <a href="https://blog.csdn.net/qq_41500249/article/details/106244810">https://blog.csdn.net/qq_41500249/article/details/106244810</a> and<br><a href="https://realpython.com/python-reverse-list/">https://realpython.com/python-reverse-list/</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">---函数</span><br><span class="line"><span class="number">1.</span> <span class="built_in">list</span>()将seq转换成<span class="built_in">list</span></span><br><span class="line"><span class="number">2.</span> <span class="built_in">len</span>()</span><br><span class="line"><span class="number">3.</span> <span class="built_in">max</span>()</span><br><span class="line"><span class="number">4.</span> <span class="built_in">min</span>()</span><br><span class="line">---方法</span><br><span class="line"><span class="built_in">list</span>.append()</span><br><span class="line"><span class="built_in">list</span>.copy()</span><br><span class="line"><span class="built_in">list</span>.clear(): remove <span class="built_in">all</span> elements</span><br><span class="line"><span class="built_in">list</span>.insert(pos, elmnt)</span><br><span class="line"><span class="built_in">list</span>.count()</span><br><span class="line"><span class="built_in">list</span>.extend(seq) seq:列表元素</span><br><span class="line"><span class="built_in">list</span>.index(x[, start[, end]])</span><br><span class="line"><span class="built_in">list</span>.pop([index=-<span class="number">1</span>]) 默认index是-<span class="number">1</span></span><br><span class="line"><span class="built_in">list</span>.remove(obj) 该方法没有返回值但是会移除列表中的某个值的第一个匹配项。</span><br><span class="line"><span class="built_in">list</span>.reverse() 反向排序</span><br><span class="line">The reverse() method doesn<span class="string">&#x27;t return any value. It updates the existing list.</span></span><br><span class="line"><span class="string">reversed():If you want to create a reversed copy of an existing list in Python, then you can use reversed(). With a list as an argument, reversed() returns an iterator that yields items in reverse order:</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&gt;&gt;&gt; reversed_digits = reversed(digits)</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; reversed_digits</span></span><br><span class="line"><span class="string">&lt;list_reverseiterator object at 0x7fca9999e790&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&gt;&gt;&gt; list(reversed_digits)</span></span><br><span class="line"><span class="string">[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">list.sort(cmp=None, key=None, reverse=False)</span></span><br><span class="line"><span class="string">A list also has the sort() method which performs the same way as sorted(). The only difference is that the sort() method doesn&#x27;</span>t <span class="keyword">return</span> <span class="built_in">any</span> value <span class="keyword">and</span> changes the original <span class="built_in">list</span>.</span><br><span class="line">key代表迭代对象中的某个属性，如某个元素的下标</span><br><span class="line"><span class="keyword">lambda</span> [arg1 [,arg2,…argn]]:expression</span><br><span class="line">a = [(<span class="string">&#x27;b&#x27;</span>, <span class="number">4</span>), (<span class="string">&#x27;a&#x27;</span>, <span class="number">12</span>), (<span class="string">&#x27;d&#x27;</span>, <span class="number">7</span>), (<span class="string">&#x27;h&#x27;</span>, <span class="number">6</span>), (<span class="string">&#x27;j&#x27;</span>, <span class="number">3</span>)]</span><br><span class="line">a.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(a)&lt;br&gt;&gt;&gt;&gt;[(<span class="string">&#x27;a&#x27;</span>, <span class="number">12</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">4</span>), (<span class="string">&#x27;d&#x27;</span>, <span class="number">7</span>), (<span class="string">&#x27;h&#x27;</span>, <span class="number">6</span>), (<span class="string">&#x27;j&#x27;</span>, <span class="number">3</span>)]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈与队列专题1</title>
      <link href="/2022/12/21/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%93%E9%A2%981/"/>
      <url>/2022/12/21/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%93%E9%A2%981/</url>
      
        <content type="html"><![CDATA[<h2 id="栈与队列基础知识"><a href="#栈与队列基础知识" class="headerlink" title="栈与队列基础知识"></a>栈与队列基础知识</h2><ul><li>stack(栈)：先进后出</li><li>Queue(队列)：先进先出</li></ul><h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a>232. 用栈实现队列</h2><p><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">https://leetcode.cn/problems/implement-queue-using-stacks/</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>python way 检查一个list是不是空，如果是空意味着0,会返回false,所以 if not a: 这个就可以检查是不是空</li><li>两个栈一个进一个出，要保证进的都是空了以后才可以对出的栈进行pop操作</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.stack_in = []</span><br><span class="line">        self.stack_out = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.stack_in.append(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> self.stack_out:</span><br><span class="line">            <span class="keyword">return</span> self.stack_out.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> self.stack_in:</span><br><span class="line">                a = self.stack_in.pop()</span><br><span class="line">                self.stack_out.append(a)</span><br><span class="line">            <span class="keyword">return</span> self.stack_out.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        a = self.pop()</span><br><span class="line">        self.stack_out.append(a)</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.stack_in <span class="keyword">and</span> <span class="keyword">not</span> self.stack_out</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyQueue()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.peek()</span></span><br><span class="line"><span class="comment"># param_4 = obj.empty()</span></span><br></pre></td></tr></table></figure><h2 id="Deque的用法"><a href="#Deque的用法" class="headerlink" title="Deque的用法"></a>Deque的用法</h2><p><a href="https://www.geeksforgeeks.org/deque-in-python/">https://www.geeksforgeeks.org/deque-in-python/</a><br>deque提供O(1)的append和pop()相比较于list<br>相关操作:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">append()</span><br><span class="line">appendleft()</span><br><span class="line">pop()</span><br><span class="line">popleft()</span><br></pre></td></tr></table></figure><h2 id="225-用队列实现栈-只用一个队列"><a href="#225-用队列实现栈-只用一个队列" class="headerlink" title="225. 用队列实现栈(只用一个队列)"></a>225. 用队列实现栈(只用一个队列)</h2><p><a href="https://leetcode.cn/problems/implement-stack-using-queues/">https://leetcode.cn/problems/implement-stack-using-queues/</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>利用deque的O(1)的性质</li><li>对于pop操作留下最后一个数每次都popleft然后append到队尾</li><li>top操作直接返回deque的最后一位</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.que = collections.deque()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.que.append(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.que) - <span class="number">1</span>):</span><br><span class="line">            self.que.append(self.que.popleft())</span><br><span class="line">        <span class="keyword">return</span> self.que.popleft()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.que[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.que</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.empty()</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串专题2</title>
      <link href="/2022/12/20/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%93%E9%A2%982/"/>
      <url>/2022/12/20/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%93%E9%A2%982/</url>
      
        <content type="html"><![CDATA[<h1 id="KMP算法（暂跳过）"><a href="#KMP算法（暂跳过）" class="headerlink" title="KMP算法（暂跳过）"></a>KMP算法（暂跳过）</h1><h2 id="28-找出字符串中第一个匹配项的下标"><a href="#28-找出字符串中第一个匹配项的下标" class="headerlink" title="28. 找出字符串中第一个匹配项的下标"></a>28. 找出字符串中第一个匹配项的下标</h2><p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/</a></p><h2 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459. 重复的子字符串"></a>459. 重复的子字符串</h2><p><a href="https://leetcode.cn/problems/repeated-substring-pattern/">https://leetcode.cn/problems/repeated-substring-pattern/</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串专题1</title>
      <link href="/2022/12/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%93%E9%A2%981/"/>
      <url>/2022/12/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%93%E9%A2%981/</url>
      
        <content type="html"><![CDATA[<h2 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a>344. 反转字符串</h2><p><a href="https://leetcode.cn/problems/reverse-string/">https://leetcode.cn/problems/reverse-string/</a></p><h3 id="相向双指针"><a href="#相向双指针" class="headerlink" title="相向双指针"></a>相向双指针</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseString</span>(<span class="params">self, s: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        j = n - <span class="number">1</span></span><br><span class="line">        temp = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            s[i], s[j] = s[j], s[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="541-反转字符串-II"><a href="#541-反转字符串-II" class="headerlink" title="541. 反转字符串 II"></a>541. 反转字符串 II</h2><p><a href="https://leetcode.cn/problems/reverse-string-ii/">https://leetcode.cn/problems/reverse-string-ii/</a></p><h3 id="思路（反转字符串相向双指针-条件）"><a href="#思路（反转字符串相向双指针-条件）" class="headerlink" title="思路（反转字符串相向双指针+条件）"></a>思路（反转字符串相向双指针+条件）</h3><ul><li>相当于 i 在前面 j 在后面 i + k-1，如果大于范围，就让 j 在数组的长度减一</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseStr</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        s = <span class="built_in">list</span>(s)</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="comment"># range(start,end,step)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n, <span class="number">2</span>* k):</span><br><span class="line">            j = i + k - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j &gt;= n:</span><br><span class="line">                j = n - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; j):</span><br><span class="line">                s[i], s[j] = s[j], s[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(s)</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a>剑指 Offer 05. 替换空格</h2><p><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">https://leetcode.cn/problems/ti-huan-kong-ge-lcof/</a></p><h3 id="暴力（最简单的想法）"><a href="#暴力（最简单的想法）" class="headerlink" title="暴力（最简单的想法）"></a>暴力（最简单的想法）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">replaceSpace</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        s = <span class="built_in">list</span>(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                s[i] = <span class="string">&#x27;%20&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(s)</span><br></pre></td></tr></table></figure><h3 id="extend数组（从后向前计算，同向双指针）"><a href="#extend数组（从后向前计算，同向双指针）" class="headerlink" title="extend数组（从后向前计算，同向双指针）"></a>extend数组（从后向前计算，同向双指针）</h3><ul><li>计算需要添加的格子的数量</li><li>从后向前计算：同向双指针，一个在原本的string末尾，一个在extend以后的数组的末尾</li><li>然后left指针遇到空格就对right指针进行赋值</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">replaceSpace</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">        ext_list = [<span class="number">0</span>] * <span class="number">2</span> * cnt</span><br><span class="line">        res = <span class="built_in">list</span>(s)</span><br><span class="line">        res.extend(ext_list)</span><br><span class="line">        l = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        r = <span class="built_in">len</span>(res) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> res[l] == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                res[r-<span class="number">2</span>:r+<span class="number">1</span>:<span class="number">1</span>] = <span class="string">&#x27;%20&#x27;</span></span><br><span class="line">                r -= <span class="number">3</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[r] = res[l]</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            l -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(res)</span><br></pre></td></tr></table></figure><h2 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151. 反转字符串中的单词"></a>151. 反转字符串中的单词</h2><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">https://leetcode.cn/problems/reverse-words-in-a-string/</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>很难写的一道题</li><li>在移除space的时候不额外用数组空间的话需要使用双指针</li><li>首先移除space 并且每一个单词添加一个空格 最后的的字符串就是分割的s[:slow]</li><li>其次反转整个字符串</li><li>然后反转每个单词</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">removeSpace</span>(<span class="params">s</span>):</span><br><span class="line">            s = <span class="built_in">list</span>(s)</span><br><span class="line">            slow = <span class="number">0</span></span><br><span class="line">            fast = <span class="number">0</span></span><br><span class="line">            <span class="comment"># python 用不了for loop对i 进行加减操作，只能用while</span></span><br><span class="line">            <span class="keyword">while</span> fast &lt; <span class="built_in">len</span>(s):</span><br><span class="line">                <span class="keyword">if</span> s[fast] != <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                    <span class="comment">#每隔一个单词加一个空格</span></span><br><span class="line">                    <span class="keyword">if</span> slow != <span class="number">0</span> :</span><br><span class="line">                        s[slow] = <span class="string">&#x27; &#x27;</span></span><br><span class="line">                        slow += <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 重点对于单个单词的处理</span></span><br><span class="line">                    <span class="keyword">while</span> fast &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[fast] != <span class="string">&#x27; &#x27;</span> :</span><br><span class="line">                        s[slow] = s[fast]</span><br><span class="line">                        slow += <span class="number">1</span></span><br><span class="line">                        fast += <span class="number">1</span></span><br><span class="line">                fast += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> s[:slow]</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">reverseString</span>(<span class="params">s</span>):</span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            j = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; j:</span><br><span class="line">                s[i], s[j] = s[j], s[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#&quot;  hello world  &quot;</span></span><br><span class="line">        s = removeSpace(s)</span><br><span class="line">        s = reverseString(s)</span><br><span class="line">        l =<span class="number">0</span></span><br><span class="line">        r =<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="comment"># print(&#x27;s[r]&#x27;,s[r])</span></span><br><span class="line">            <span class="keyword">while</span> r&lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[r] != <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line">            rever = r - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; rever:</span><br><span class="line">                s[l],s[rever] = s[rever], s[l]</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">                rever -= <span class="number">1</span></span><br><span class="line">            l = r + <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(s)</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-58-II-左旋转字符串"><a href="#剑指-Offer-58-II-左旋转字符串" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串"></a>剑指 Offer 58 - II. 左旋转字符串</h2><p><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/</a></p><h3 id="申请额外空间（最初想法）"><a href="#申请额外空间（最初想法）" class="headerlink" title="申请额外空间（最初想法）"></a>申请额外空间（最初想法）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseLeftWords</span>(<span class="params">self, s: <span class="built_in">str</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        l = []</span><br><span class="line">        s = <span class="built_in">list</span>(s)</span><br><span class="line">        last= s[:n]</span><br><span class="line">        first = s[n:]</span><br><span class="line">        l = first + last</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(l)</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseLeftWords</span>(<span class="params">self, s: <span class="built_in">str</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> s[n:] + s[<span class="number">0</span>:n]</span><br></pre></td></tr></table></figure><h3 id="不用额外空间"><a href="#不用额外空间" class="headerlink" title="不用额外空间"></a>不用额外空间</h3><ul><li>很难想到</li><li>先反转前n个</li><li>在反转后n个</li><li>再反转全部</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseLeftWords</span>(<span class="params">self, s: <span class="built_in">str</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">s,l,r</span>):</span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                s[l],s[r] = s[r], s[l]</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        s = <span class="built_in">list</span>(s)</span><br><span class="line">        s = reverse(s,<span class="number">0</span>,n - <span class="number">1</span>)</span><br><span class="line">        s = reverse(s,n,<span class="built_in">len</span>(s) -<span class="number">1</span>)</span><br><span class="line">        s = reverse(s,<span class="number">0</span>,<span class="built_in">len</span>(s) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(s)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希表专题2</title>
      <link href="/2022/12/18/%E5%93%88%E5%B8%8C%E8%A1%A8%E4%B8%93%E9%A2%982/"/>
      <url>/2022/12/18/%E5%93%88%E5%B8%8C%E8%A1%A8%E4%B8%93%E9%A2%982/</url>
      
        <content type="html"><![CDATA[<h2 id="454-四数相加-II"><a href="#454-四数相加-II" class="headerlink" title="454. 四数相加 II"></a>454. 四数相加 II</h2><p><a href="https://leetcode.cn/problems/4sum-ii/">https://leetcode.cn/problems/4sum-ii/</a></p><h4 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h4><p>肯定是四个for loops然后相加等于0 — 超出时间限制</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSumCount</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>], nums3: <span class="type">List</span>[<span class="built_in">int</span>], nums4: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> nums2:</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> nums3:</span><br><span class="line">                    <span class="keyword">for</span> l <span class="keyword">in</span> nums4:</span><br><span class="line">                        <span class="keyword">if</span> i + j + k + l == <span class="number">0</span>:</span><br><span class="line">                            res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="把四个for-loop变成两个for-loop-利用哈希表储存"><a href="#把四个for-loop变成两个for-loop-利用哈希表储存" class="headerlink" title="把四个for loop变成两个for loop(利用哈希表储存)"></a>把四个for loop变成两个for loop(利用哈希表储存)</h4><ul><li>先遍历前面两个数组然后利用dict储存起来，key是数组相加的值，value是值出现的次数</li><li>后面遍历两个for loop查询负的两个相加的值是否出现在前面创建的字典的key里面</li><li><strong>如果出现了就是加上之前存储字典里面出现的次数</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSumCount</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>], nums3: <span class="type">List</span>[<span class="built_in">int</span>], nums4: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dict_ =&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> nums2:</span><br><span class="line">                dict_[i + j] = dict_.get(i+j,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums3:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> nums4:</span><br><span class="line">                <span class="keyword">if</span> -(i+j) <span class="keyword">in</span> dict_.keys():</span><br><span class="line">                    res += dict_[-(i+j)]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a>383. 赎金信</h2><p><a href="https://leetcode.cn/problems/ransom-note/">https://leetcode.cn/problems/ransom-note/</a></p><h3 id="defaultdict的使用"><a href="#defaultdict的使用" class="headerlink" title="defaultdict的使用"></a>defaultdict的使用</h3><p>From: <a href="https://www.geeksforgeeks.org/defaultdict-in-python/">https://www.geeksforgeeks.org/defaultdict-in-python/</a></p><p> It provides a default value for the key that does not exists.</p><h4 id="对于函数"><a href="#对于函数" class="headerlink" title="对于函数"></a>对于函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">def_value</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Not Present&quot;</span></span><br><span class="line">      </span><br><span class="line"><span class="comment"># Defining the dict</span></span><br><span class="line">d = defaultdict(def_value)</span><br><span class="line">d[<span class="string">&quot;a&quot;</span>] = <span class="number">1</span></span><br><span class="line">d[<span class="string">&quot;b&quot;</span>] = <span class="number">2</span></span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&quot;a&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&quot;b&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&quot;c&quot;</span>])</span><br><span class="line">-------------</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">Not Present </span><br></pre></td></tr></table></figure><h4 id="利用lambda表达式"><a href="#利用lambda表达式" class="headerlink" title="利用lambda表达式"></a>利用lambda表达式</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">  </span><br><span class="line">      </span><br><span class="line"><span class="comment"># Defining the dict and passing </span></span><br><span class="line"><span class="comment"># lambda as default_factory argument</span></span><br><span class="line">d = defaultdict(<span class="keyword">lambda</span>: <span class="string">&quot;Not Present&quot;</span>)</span><br><span class="line">d[<span class="string">&quot;a&quot;</span>] = <span class="number">1</span></span><br><span class="line">d[<span class="string">&quot;b&quot;</span>] = <span class="number">2</span></span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&quot;a&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&quot;b&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&quot;c&quot;</span>])</span><br><span class="line">-------------</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">Not Present</span><br><span class="line">--------------------------------------------------</span><br><span class="line">__missing__(): function的用法</span><br><span class="line"><span class="keyword">if</span>:argument <span class="keyword">is</span> <span class="literal">None</span> 会出现a KeyError</span><br><span class="line"><span class="keyword">else</span>:  provides a default value <span class="keyword">for</span> the given key</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="comment"># Defining the dict</span></span><br><span class="line">d = defaultdict(<span class="keyword">lambda</span>: <span class="string">&quot;Not Present&quot;</span>)</span><br><span class="line">d[<span class="string">&quot;a&quot;</span>] = <span class="number">1</span></span><br><span class="line">d[<span class="string">&quot;b&quot;</span>] = <span class="number">2</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># Provides the default value </span></span><br><span class="line"><span class="comment"># for the key</span></span><br><span class="line"><span class="built_in">print</span>(d.__missing__(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(d.__missing__(<span class="string">&#x27;d&#x27;</span>))</span><br><span class="line">---------------output</span><br><span class="line">Not Present</span><br><span class="line">Not Present </span><br></pre></td></tr></table></figure><h4 id="int-和-list"><a href="#int-和-list" class="headerlink" title="int 和 list"></a>int 和 list</h4><ul><li><p>Using int as default_factory(a defaultdict is created with <strong>default value as zero</strong>)<br><code>from collections import defaultdict</code><br><code>d = defaultdict(int)</code></p></li><li><p>a defaultdict is created with the values that are list.</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    d[i].append(i)</span><br><span class="line">d = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">&#123;<span class="number">0</span>: [<span class="number">0</span>], <span class="number">1</span>: [<span class="number">1</span>], <span class="number">2</span>: [<span class="number">2</span>], <span class="number">3</span>: [<span class="number">3</span>], <span class="number">4</span>: [<span class="number">4</span>]&#125;)</span><br></pre></td></tr></table></figure><h3 id="对于counter的使用"><a href="#对于counter的使用" class="headerlink" title="对于counter的使用"></a>对于counter的使用</h3><p>From: <a href="https://pythongeeks.org/python-counter-module/">https://pythongeeks.org/python-counter-module/</a><br>语法：<br><code>obj = collections.Counter([iterable-or-mapping])</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter  <span class="comment"># collections = module name </span></span><br><span class="line">                                 <span class="comment"># Counter = class name</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">issubclass</span>(Counter, <span class="built_in">dict</span>)) <span class="comment"># issubclass() = function name</span></span><br><span class="line"><span class="comment"># print() = function name, dict = class name</span></span><br><span class="line">-----output</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> Creating a Counter Object using **Iterables** <span class="keyword">in</span> Python</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">c = Counter([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(c) </span><br><span class="line">output: Counter(&#123;<span class="number">1</span>: <span class="number">3</span>, <span class="number">3</span>: <span class="number">2</span>, <span class="number">2</span>: <span class="number">1</span>, <span class="number">4</span>: <span class="number">1</span>&#125;)</span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="number">2.</span> Creating a Counter Object using **Strings** <span class="keyword">in</span> Python</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">c = Counter(<span class="string">&quot;PythonGeeks&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">output: Counter(&#123;‘e’: <span class="number">2</span>, ‘P’: <span class="number">1</span>, ‘y’: <span class="number">1</span>, ‘t’: <span class="number">1</span>, ‘h’: <span class="number">1</span>, ‘o’: <span class="number">1</span>, ‘n’: <span class="number">1</span>, ‘G’: <span class="number">1</span>, ‘k’: <span class="number">1</span>, ‘s’: <span class="number">1</span>&#125;)</span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="number">3.</span> Creating a Counter Object using **Dictionary** <span class="keyword">in</span> Python</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">c = Counter(&#123;<span class="string">&quot;A&quot;</span>: <span class="number">2</span>, <span class="string">&quot;B&quot;</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">output: Counter(&#123;‘A’: <span class="number">2</span>, ‘B’: <span class="number">1</span>&#125;)</span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="number">4.</span> Creating a Counter Object using Keyword Arguments <span class="keyword">in</span> Python</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">c = Counter(A=<span class="number">2</span>, B=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">output: Counter(&#123;‘A’: <span class="number">2</span>, ‘B’: <span class="number">1</span>&#125;)</span><br><span class="line">----------------------------------------------</span><br><span class="line"></span><br><span class="line">获取值</span><br><span class="line">c = Counter([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(c[<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">output: <span class="number">2</span></span><br><span class="line">不像普通字典，counter会返回<span class="number">0</span>，而不会引起 KeyError, 如果传入的argument不在里面</span><br><span class="line">c = Counter([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(c[<span class="string">&#x27;d&#x27;</span>])</span><br><span class="line">output: <span class="number">0</span></span><br><span class="line">----------------------------------------------</span><br><span class="line">修改添加值</span><br><span class="line"></span><br><span class="line">c[<span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span></span><br><span class="line">c[<span class="string">&#x27;c&#x27;</span>] = <span class="number">4</span></span><br><span class="line">----------------------------------------------</span><br><span class="line">方法：</span><br><span class="line"><span class="number">1.</span>update():</span><br><span class="line">c = Counter([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">c.update([<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">output:Counter(&#123;‘a’: <span class="number">2</span>, ‘b’: <span class="number">1</span>, ‘c’: <span class="number">1</span>&#125;)Counter(&#123;‘a’: <span class="number">3</span>, ‘d’: <span class="number">2</span>, ‘b’: <span class="number">1</span>, ‘c’: <span class="number">1</span>, ‘e’: <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>elements():returns an iterator that we can use <span class="keyword">in</span> <span class="keyword">for</span>-loops to iterate over <span class="built_in">all</span> elements <span class="keyword">and</span> their counts <span class="keyword">in</span> the counter <span class="built_in">object</span>.</span><br><span class="line">c = Counter([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="keyword">for</span> ele <span class="keyword">in</span> c.elements():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;ele&#125;</span> - <span class="subst">&#123;c[ele]&#125;</span>&quot;</span>)</span><br><span class="line">output: a – 2a – <span class="number">2</span></span><br><span class="line"></span><br><span class="line">b – <span class="number">1</span></span><br><span class="line"></span><br><span class="line">c – <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>most_common([n])：sort 从最高频率到最低评率到n</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">c = Counter([<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(c.most_common(<span class="number">2</span>))</span><br><span class="line">output: [(<span class="number">1</span>, <span class="number">5</span>), (<span class="number">2</span>, <span class="number">3</span>)]</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>clear():清空所有</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>算数+，-，&amp;，｜</span><br><span class="line">+：两个<span class="built_in">dict</span>元素相加</span><br><span class="line">-：两个<span class="built_in">dict</span> 相减，比如 a-b,最后的结果只是减去b中有相同key的元素</span><br><span class="line">c1 = Counter(a=<span class="number">3</span>, b=<span class="number">1</span>, c=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(c1)</span><br><span class="line">c2 = Counter(c=<span class="number">1</span>, d=<span class="number">2</span>, e=<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(c2)</span><br><span class="line">c3 = c1 - c2</span><br><span class="line"><span class="built_in">print</span>(c3)</span><br><span class="line">output: Counter(&#123;‘a’: <span class="number">3</span>, ‘c’: <span class="number">2</span>, ‘b’: <span class="number">1</span>&#125;)Counter(&#123;‘e’: <span class="number">3</span>, ‘d’: <span class="number">2</span>, ‘c’: <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line">Counter(&#123;‘a’: <span class="number">3</span>, ‘b’: <span class="number">1</span>, ‘c’: <span class="number">1</span>&#125;)</span><br><span class="line">&amp;: 返回item在两个<span class="built_in">dict</span>里面都出现</span><br><span class="line">|: 和加法类似但是不想家数值</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">c1 = Counter(a=<span class="number">3</span>, b=<span class="number">1</span>, c=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(c1)</span><br><span class="line">c2 = Counter(c=<span class="number">1</span>, d=<span class="number">2</span>, e=<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(c2)</span><br><span class="line">c3 = c1 | c2</span><br><span class="line"><span class="built_in">print</span>(c3)</span><br><span class="line">output:Counter(&#123;‘a’: <span class="number">3</span>, ‘c’: <span class="number">2</span>, ‘b’: <span class="number">1</span>&#125;)Counter(&#123;‘e’: <span class="number">3</span>, ‘d’: <span class="number">2</span>, ‘c’: <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line">Counter(&#123;‘a’: <span class="number">3</span>, ‘e’: <span class="number">3</span>, ‘c’: <span class="number">2</span>, ‘d’: <span class="number">2</span>, ‘b’: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="利用数组当作哈希表"><a href="#利用数组当作哈希表" class="headerlink" title="利用数组当作哈希表"></a>利用数组当作哈希表</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canConstruct</span>(<span class="params">self, ransomNote: <span class="built_in">str</span>, magazine: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        list_ = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> magazine:</span><br><span class="line">            list_[<span class="built_in">ord</span>(i) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> ransomNote:</span><br><span class="line">            list_[<span class="built_in">ord</span>(j) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> list_:</span><br><span class="line">            <span class="keyword">if</span> k &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="直接哈希表"><a href="#直接哈希表" class="headerlink" title="直接哈希表"></a>直接哈希表</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canConstruct</span>(<span class="params">self, ransomNote: <span class="built_in">str</span>, magazine: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        dict_ = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> magazine:</span><br><span class="line">            dict_[i] = dict_.get(i,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> ransomNote:</span><br><span class="line">            dict_[j] = dict_.get(j,<span class="number">0</span>) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> dict_.values():</span><br><span class="line">            <span class="keyword">if</span> k &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><strong>用defaultdict</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canConstruct</span>(<span class="params">self, ransomNote: <span class="built_in">str</span>, magazine: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">        dict_ = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> magazine:</span><br><span class="line">            dict_[i] = dict_.get(i,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> ransomNote:</span><br><span class="line">            <span class="keyword">if</span> dict_[j] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dict_[j] = dict_.get(j,<span class="number">0</span>) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><strong>用Counter</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canConstruct</span>(<span class="params">self, ransomNote: <span class="built_in">str</span>, magazine: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        a = collections.Counter(magazine)</span><br><span class="line">        b = collections.Counter(ransomNote)</span><br><span class="line">        diff = b - a</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(diff) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h2><p><a href="https://leetcode.cn/problems/3sum/">https://leetcode.cn/problems/3sum/</a></p><h3 id="相向双指针"><a href="#相向双指针" class="headerlink" title="相向双指针"></a>相向双指针</h3><ul><li>自己没做出来</li><li>先排序：优化数组可以使用相向双指针</li><li>重点在于去重</li></ul><ol><li><code>nums[i] == nums[i + 1] 并且 i &gt; 0 的时候跳过 i ++</code></li><li><code>while(j &lt;k and nums[j] == nums[j + 1]) j ++</code></li><li><code>while(j &lt; k and nums[k] -- nums[k - 1]) k --</code></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        nums.sort()</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">2</span>):</span><br><span class="line">            <span class="comment">#很重要是i 和 i-1,避免跳过相同元素</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment">#剪枝操作</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment">#剪枝操作</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] + nums[-<span class="number">2</span>] + nums[-<span class="number">1</span>] &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            j = i + <span class="number">1</span></span><br><span class="line">            k = n - <span class="number">1</span></span><br><span class="line">            x = nums[i]</span><br><span class="line">            <span class="keyword">while</span> (j &lt; k):</span><br><span class="line">                <span class="keyword">if</span> x + nums[j] + nums[k] &gt; <span class="number">0</span>:</span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> x + nums[j] + nums[k] &lt; <span class="number">0</span>:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append([x,nums[j],nums[k]])</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> (nums[j] == nums[j - <span class="number">1</span>] <span class="keyword">and</span> j &lt; k):</span><br><span class="line">                        j += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span>( nums[k] == nums[k + <span class="number">1</span>] <span class="keyword">and</span> j &lt; k):</span><br><span class="line">                        k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a>18. 四数之和</h2><p><a href="https://leetcode.cn/problems/4sum/">https://leetcode.cn/problems/4sum/</a></p><h3 id="思路和三数之和一样就是多了一层for-loop"><a href="#思路和三数之和一样就是多了一层for-loop" class="headerlink" title="思路和三数之和一样就是多了一层for loop"></a>思路和三数之和一样就是多了一层for loop</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        nums.sort()</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">3</span>):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] + nums[ i + <span class="number">1</span>] + nums[i+<span class="number">2</span>] + nums[i+<span class="number">3</span>] &gt; target:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            x1 = nums[i]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,n - <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">if</span> j &gt; i + <span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                x2 = nums[j]</span><br><span class="line">                l = j + <span class="number">1</span></span><br><span class="line">                r = n - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span>(l &lt; r):</span><br><span class="line">                    sum_ = x1 + x2 + nums[l] + nums[r]</span><br><span class="line">                    <span class="keyword">if</span> sum_ &gt; target:</span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> sum_ &lt; target:</span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        res.append([x1,x2,nums[l],nums[r]])</span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l] == nums[l - <span class="number">1</span>]:</span><br><span class="line">                            l += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[r] == nums[r + <span class="number">1</span>]:</span><br><span class="line">                            r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希表专题1</title>
      <link href="/2022/12/17/%E5%93%88%E5%B8%8C%E8%A1%A8%E4%B8%93%E9%A2%981/"/>
      <url>/2022/12/17/%E5%93%88%E5%B8%8C%E8%A1%A8%E4%B8%93%E9%A2%981/</url>
      
        <content type="html"><![CDATA[<h2 id="哈希表基础理论"><a href="#哈希表基础理论" class="headerlink" title="哈希表基础理论"></a>哈希表基础理论</h2><p>数组就可以被看成是一个哈希表</p><ul><li>主要用来判断看一个元素是不是在这个集合里</li><li>相比较而言数组：如需要查询一个学生姓名，数组需要遍历，而哈希表直接进行索引就可以</li><li><strong>为什么哈希表是O(1)查询呢，因为只要知道key或者对于hashset来说知道索引就可以知道所要查询的值，比如要查询这个学生在不在哈希表&#x2F;set()里面,只需要提供这个人的名字然后用哈希函数把名字转换成hashcode之后，之后用 hash 表的数组长度对 key的hashCode 求余， 余数即为 hash 表数组的下标</strong></li></ul><h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p>学生的姓名可以通过哈希函数转化为哈希表的索引</p><ul><li>在上面的场景中查询学生姓名，就是通过hashcode把名字转化为数值映射到了哈希表上面的索引数字</li><li>之后为了保证索引数值落在哈希表上面，我们还会对hashcode之后的数值进行取模运算</li></ul><h3 id="哈希碰撞"><a href="#哈希碰撞" class="headerlink" title="哈希碰撞"></a>哈希碰撞</h3><p>对于学生数量大于了创建的哈希表的大小来说<br>有两种解决办法</p><ul><li>拉链法：对于冲突的索引值比如位置<code>index0</code>，我们在0的位置创建一个链表储存冲突的学生</li><li>线性探测法：我们首先要保证hash table size要大于数据量，如果一旦发生冲突我们就在hash table寻找下一个空的位置填放</li></ul><h2 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a>242. 有效的字母异位词</h2><p><a href="https://leetcode.cn/problems/valid-anagram/">https://leetcode.cn/problems/valid-anagram/</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>范围可控用数组</li><li>范围比较大用set</li><li>key 对应有 value的话就用map</li></ol><h5 id="python-ord-和chr-方法"><a href="#python-ord-和chr-方法" class="headerlink" title="python ord()和chr()方法"></a>python <code>ord()和chr()方法</code></h5><ol><li>ord()：<code>print(ord(&#39;a&#39;)) = 97</code></li><li>chr()：<code>&gt;&gt;&gt; print(chr(97)) = a</code></li></ol><h5 id="创建default-dictionary的方法"><a href="#创建default-dictionary的方法" class="headerlink" title="创建default dictionary的方法"></a>创建default dictionary的方法</h5><ul><li>1.<code>from collections import defaultdict</code></li><li>2.创建一个default dictionary <code>import string   d1 = dict.fromkeys(string.ascii_lowercase, 0)</code> </li><li><code>dict.fromkeys(keys, value)</code>The fromkeys() method returns a dictionary with the specified keys and the specified value.</li></ul><h5 id="initialize-list的方法"><a href="#initialize-list的方法" class="headerlink" title="initialize list的方法"></a>initialize list的方法</h5><ol><li><code>data = [0] * n</code> n的值是需要的创建的数量</li></ol><h4 id="第一想法（用的哈希表）"><a href="#第一想法（用的哈希表）" class="headerlink" title="第一想法（用的哈希表）"></a>第一想法（用的哈希表）</h4><ul><li><p>自己想的用dict然后遍历一个string 遇到就+&#x3D; 1，然后遍历第二个string -&#x3D; 1，但是再次遍历这个dict<br><code>dict.get(key, default = None)</code></p></li><li><p>判断两个dict 相等直接用等于</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">import</span> string</span><br><span class="line">        d1 = <span class="built_in">dict</span>.fromkeys(string.ascii_lowercase, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            d1[i] = d1.get(i,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> t:</span><br><span class="line">            d1[i] = d1.get(i) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> d1.values():</span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="把数组当作哈希表使用"><a href="#把数组当作哈希表使用" class="headerlink" title="把数组当作哈希表使用"></a>把数组当作哈希表使用</h4><ul><li>创建一个26个长度为0的数组</li><li>其他思路和上面一样</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        l = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            l[<span class="built_in">ord</span>(i) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> t:</span><br><span class="line">            l[<span class="built_in">ord</span>(j) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> l:</span><br><span class="line">            <span class="keyword">if</span> k != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h2><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">https://leetcode.cn/problems/intersection-of-two-arrays/</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><h4 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h4><ul><li>有思路：直接两个for loop然后最后set.add()最后转换set成list</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intersection</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        intersect = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> nums2:</span><br><span class="line">                <span class="keyword">if</span> i == j:</span><br><span class="line">                    intersect.add(i)</span><br><span class="line">        <span class="comment"># set to list 直接用list()</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(intersect)</span><br></pre></td></tr></table></figure><h4 id="用hashmap当作hashset做"><a href="#用hashmap当作hashset做" class="headerlink" title="用hashmap当作hashset做"></a>用hashmap当作hashset做</h4><ul><li>分成两个for loop一个遍历一个排查</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intersection</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        hashmap = &#123;&#125;</span><br><span class="line">        result = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">            hashmap[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">in</span> hashmap.keys() <span class="keyword">and</span> hashmap[j] ==<span class="number">1</span>:</span><br><span class="line">                result.add(j)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(result)</span><br></pre></td></tr></table></figure><h2 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h2><p><a href="https://leetcode.cn/problems/happy-number/">https://leetcode.cn/problems/happy-number/</a></p><h3 id="in-关键字"><a href="#in-关键字" class="headerlink" title="in 关键字"></a>in 关键字</h3><ul><li>python 里面 的in关键字和contains是一样的</li><li>对于list:复杂度是O（n）</li><li>对于set:复杂度是O(1)因为通过hashcode可以直接知道索引下标</li></ul><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ul><li>计算器 十位数如何拆开计算</li><li>取个位数是用%取余符号</li><li>之后每次除以10</li><li>判断n &#x3D;&#x3D; 1的时候return true</li><li>如果不是等于1要判断在不在set里面，如果在说明重复了所以return false</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">happy</span>(<span class="params">n</span>):</span><br><span class="line">            sum_ = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> n:</span><br><span class="line">                sum_ += (n % <span class="number">10</span>) ** <span class="number">2</span></span><br><span class="line">                n //= <span class="number">10</span></span><br><span class="line">            <span class="keyword">return</span> sum_</span><br><span class="line">        hashset = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            n = happy(n)</span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment">#这里很重要，in关键字对于set的复杂度只有O(1)</span></span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> hashset:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashset.add(n)</span><br></pre></td></tr></table></figure><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h2><p><a href="https://leetcode.cn/problems/two-sum/">https://leetcode.cn/problems/two-sum/</a></p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><h4 id="两个单独的for-loop不是嵌套"><a href="#两个单独的for-loop不是嵌套" class="headerlink" title="两个单独的for loop不是嵌套"></a>两个单独的for loop不是嵌套</h4><ul><li>自己的思路:创建hashmap保存key 是 nums里面的数， val是nums里面的index</li><li>但是这个时候第二个for loop会出现一个问题</li><li>会出现比如target为6 nums &#x3D; [3,2,4]，会返回[0,0]这个时候用if 判断一下避免一样就好了</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        hashmap = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            hashmap[j] = i</span><br><span class="line">        <span class="keyword">for</span> i,k <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            rest = target - k</span><br><span class="line">            <span class="keyword">if</span> rest <span class="keyword">in</span> hashmap <span class="keyword">and</span> i != hashmap[rest]:</span><br><span class="line">                <span class="keyword">return</span> [i,hashmap[rest]] </span><br></pre></td></tr></table></figure><h4 id="哈希表一个for-loop"><a href="#哈希表一个for-loop" class="headerlink" title="哈希表一个for loop"></a>哈希表一个for loop</h4><ul><li>遍历的时候同时保存hashmap</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        hashmap = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            rest = target - j</span><br><span class="line">            <span class="keyword">if</span> rest <span class="keyword">not</span> <span class="keyword">in</span> hashmap.keys():</span><br><span class="line">                hashmap[j] = i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> [hashmap[rest],i]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表专题2</title>
      <link href="/2022/12/14/%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%982/"/>
      <url>/2022/12/14/%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%982/</url>
      
        <content type="html"><![CDATA[<h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h2><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">https://leetcode.cn/problems/swap-nodes-in-pairs/</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>简单模拟题</li><li>掌握好指针移动循序先 <code>cur.next再cur.next.next再cur.next.next.next </code></li><li>核心：终止条件 <code>cur.next 和 cur.next.next都不为空是才进行</code></li><li>当节点数量为奇数时候：<code>cur.next.next</code>为空时就不需要交换了</li><li>当节点数量为偶数时候<code>cur.next</code>为空就停止</li><li>不能反过来写容易发生空指针异常</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swapPairs</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy = ListNode(<span class="built_in">next</span> = head)</span><br><span class="line">        cur = dummy</span><br><span class="line">        <span class="comment">#必须有下个和下下个不等于none才可以进行(关键)</span></span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> != <span class="literal">None</span> <span class="keyword">and</span> cur.<span class="built_in">next</span>.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            temp1 = cur.<span class="built_in">next</span></span><br><span class="line">            temp2 = cur.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span>.<span class="built_in">next</span>= temp1</span><br><span class="line">            cur.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = temp2</span><br><span class="line">            cur = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a>19. 删除链表的倒数第 N 个结点</h2><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">https://leetcode.cn/problems/remove-nth-node-from-end-of-list/</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>写了出来</li><li>一个快指针一个慢指针</li><li>快慢指针中间差n个节点</li></ul><h4 id="双指针经典应用"><a href="#双指针经典应用" class="headerlink" title="双指针经典应用"></a>双指针经典应用</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], n: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy_head = ListNode(<span class="built_in">next</span> = head)</span><br><span class="line">        pre = dummy_head</span><br><span class="line">        cur = dummy_head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            pre = pre.<span class="built_in">next</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        pre.<span class="built_in">next</span> = pre.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy_head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><h2 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h2><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/</a></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ul><li>暴力解法</li><li>求出链表A的长度再求出链表B的长度</li><li>然后让两个链表处于相同位置</li><li>之后<strong>赋值两个新的node注意不要创建Listnode地址会不同！！</strong></li><li>然后两个指针一直走知道相同返回当前值</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">if</span> headA == <span class="literal">None</span> <span class="keyword">or</span> headB == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        dummyhead1 = ListNode(<span class="built_in">next</span> = headA.<span class="built_in">next</span>)</span><br><span class="line">        dummyhead2 = ListNode(<span class="built_in">next</span> = headB.<span class="built_in">next</span>)</span><br><span class="line">        lengthA = <span class="number">0</span></span><br><span class="line">        lengthB = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(dummyhead1 != <span class="literal">None</span>):</span><br><span class="line">            dummyhead1 = dummyhead1.<span class="built_in">next</span></span><br><span class="line">            lengthA += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(dummyhead2 != <span class="literal">None</span>):</span><br><span class="line">            dummyhead2 = dummyhead2.<span class="built_in">next</span></span><br><span class="line">            lengthB += <span class="number">1</span></span><br><span class="line">        <span class="comment">#这里不要 head1 = ListNode(next = headA.next)</span></span><br><span class="line">        <span class="comment"># 地址会不同</span></span><br><span class="line">        head1 = headA</span><br><span class="line">        head2 = headB</span><br><span class="line">        <span class="keyword">if</span> lengthA &gt; lengthB:</span><br><span class="line">            <span class="keyword">while</span> (lengthA - lengthB):</span><br><span class="line">                head1 = head1.<span class="built_in">next</span></span><br><span class="line">                lengthA -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> lengthA &lt; lengthB:</span><br><span class="line">            <span class="keyword">while</span> (lengthB - lengthA):</span><br><span class="line">                head2 = head2.<span class="built_in">next</span></span><br><span class="line">                lengthB -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (head1 != <span class="literal">None</span>):</span><br><span class="line">            <span class="keyword">if</span> head1 == head2:</span><br><span class="line">                <span class="keyword">return</span> head1</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                head1 = head1.<span class="built_in">next</span></span><br><span class="line">                head2 = head2.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h2 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a>142. 环形链表 II</h2><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">https://leetcode.cn/problems/linked-list-cycle-ii/</a></p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ul><li>快慢指针</li><li>如何想到的呢就是：如果快指针是慢指针速度的两倍的话两个一定可以遇到</li><li>x,y,z </li><li>x:开始的位置到环的起点位置</li><li>y:环起点位置到相遇的位置</li><li>z:相遇的位置到环起点位置</li><li>所以对于慢指针的移动距离是：x + y</li><li>快指针一定是套了慢指针一圈的所以移动距离是：x +（y+z）+ y</li><li>2(x+y) &#x3D; x + 2y + z</li><li>z &#x3D; x</li><li>所以通过数学推导发现相遇的位置到环的起点位置和最开始的位置到环的起点位置的距离是一样的</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detectCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        fast = head</span><br><span class="line">        slow = head</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">None</span> <span class="keyword">and</span> fast.<span class="built_in">next</span> != <span class="literal">None</span>):</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> fast == slow:</span><br><span class="line">                meet_loc = fast</span><br><span class="line">                start = head</span><br><span class="line">                <span class="keyword">while</span> meet_loc != start:</span><br><span class="line">                    meet_loc = meet_loc.<span class="built_in">next</span></span><br><span class="line">                    start = start.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> start</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表专题1</title>
      <link href="/2022/12/13/%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%981/"/>
      <url>/2022/12/13/%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%981/</url>
      
        <content type="html"><![CDATA[<h2 id="链表理论基础"><a href="#链表理论基础" class="headerlink" title="链表理论基础"></a>链表理论基础</h2><p>链表有两个部分组成：</p><ul><li>数据域</li><li>指针域</li></ul><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><ul><li>入口是head</li><li>结尾的指针域指向空指针</li></ul><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><ul><li>每个节点有两个指针域,一个指向上一个节点一个指向下一个节点</li></ul><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><ul><li>链表首尾相连</li></ul><h3 id="链表和数组的存储方式-x2F-时间复杂度"><a href="#链表和数组的存储方式-x2F-时间复杂度" class="headerlink" title="链表和数组的存储方式&#x2F;时间复杂度"></a>链表和数组的存储方式&#x2F;时间复杂度</h3><h4 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h4><ul><li>连续存储在内存中</li><li>插入删除：O(n)</li><li>查询：O(1)</li></ul><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><ul><li>链表：在内存中可不连续存储<br>插入删除：O(1)</li><li>查询：O(n)</li></ul><h3 id="链表定义"><a href="#链表定义" class="headerlink" title="链表定义"></a>链表定义</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br></pre></td></tr></table></figure><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>删除节点就是把这个节点的指针指向要删掉的节点的下一节点的数据域</p><h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><ul><li>把要添加位置的前一节点的指针指向要添加节点的数据域</li><li>把添加节点的指针指向添加位置后的节点的数据域</li></ul><h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a>203. 移除链表元素</h2><p>题目链接：<a href="https://leetcode.cn/problems/remove-linked-list-elements/">https://leetcode.cn/problems/remove-linked-list-elements/</a></p><p>cur的作用是作为新的临时节点指针进行删除原链表元素操作</p><h3 id="原链表删除"><a href="#原链表删除" class="headerlink" title="原链表删除"></a>原链表删除</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElements</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="comment"># print(head != None)</span></span><br><span class="line">        <span class="comment">#如果头节点等于要删除的val的话就向后移</span></span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">None</span> <span class="keyword">and</span> head.val == val ):</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="comment">#对于不是头节点的进行删除</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">None</span> <span class="keyword">and</span>  cur.<span class="built_in">next</span> != <span class="literal">None</span>):</span><br><span class="line">            <span class="keyword">if</span> cur.<span class="built_in">next</span>.val == val:</span><br><span class="line">                cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h3 id="虚拟结点"><a href="#虚拟结点" class="headerlink" title="虚拟结点"></a>虚拟结点</h3><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>为了不单独区分头节点和不是头节点的删除操作</li><li>创造一个<code>dummy = ListNode()----dummy.next = head</code>的节点，然后再去创造一个新的current指针去遍历整个dummy链表</li><li>操作的点一定是<code>current.next</code> 这样子才可以进行增加或者删除操作</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElements</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy = ListNode()</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        cur = dummy</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.<span class="built_in">next</span>.val != val:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;head&#x27;</span>,head)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;cur&#x27;</span>,cur)</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><h2 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707. 设计链表"></a>707. 设计链表</h2><p>题目链接：<a href="https://leetcode.cn/problems/design-linked-list/">https://leetcode.cn/problems/design-linked-list/</a></p><h3 id="单链表解法"><a href="#单链表解法" class="headerlink" title="单链表解法"></a>单链表解法</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>我这道题主要看到问题知道怎么写但是对类的创建不是很了解，所以参考了视频以后才写出来</p><ul><li>首先创建单独的node类</li><li>对于提供的mylinkedlist 需要在构造函数里面初始化需要用的dummyhead和整个链表的长度</li><li>其他的基本没什么难度但是需要注意while内部需要自己定义index – 和进行添加以后的长度++</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,val = <span class="number">0</span>,<span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.dummyhead = Node()</span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, index: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt;= self.size:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        cur = self.dummyhead</span><br><span class="line">        <span class="keyword">while</span>(index != <span class="number">0</span>):</span><br><span class="line">            index -= <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> cur.<span class="built_in">next</span>.val</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addAtHead</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        add_head = Node(val)</span><br><span class="line">        add_head.<span class="built_in">next</span> = self.dummyhead.<span class="built_in">next</span></span><br><span class="line">        self.dummyhead.<span class="built_in">next</span> = add_head</span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addAtTail</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        add_tail = Node(val)</span><br><span class="line">        cur = self.dummyhead</span><br><span class="line">        <span class="keyword">while</span>(cur.<span class="built_in">next</span> != <span class="literal">None</span>):</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        cur.<span class="built_in">next</span> = add_tail</span><br><span class="line">        add_tail.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addAtIndex</span>(<span class="params">self, index: <span class="built_in">int</span>, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> index == self.size:</span><br><span class="line">            self.addAtTail(val)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> index &lt; <span class="number">0</span>:</span><br><span class="line">            self.addAtHead()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> index &gt; self.size:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        add_index_node = Node(val)</span><br><span class="line">        cur = self.dummyhead</span><br><span class="line">        <span class="keyword">while</span>(index != <span class="number">0</span>):</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">            index -= <span class="number">1</span></span><br><span class="line">        add_index_node.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">        cur.<span class="built_in">next</span> = add_index_node</span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteAtIndex</span>(<span class="params">self, index: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> index &gt;= <span class="number">0</span> <span class="keyword">and</span> index &lt; self.size:</span><br><span class="line">            cur = self.dummyhead</span><br><span class="line">            <span class="keyword">while</span>(index != <span class="number">0</span>):</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">                index -= <span class="number">1</span></span><br><span class="line">            cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            self.size -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyLinkedList()</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(index)</span></span><br><span class="line"><span class="comment"># obj.addAtHead(val)</span></span><br><span class="line"><span class="comment"># obj.addAtTail(val)</span></span><br><span class="line"><span class="comment"># obj.addAtIndex(index,val)</span></span><br><span class="line"><span class="comment"># obj.deleteAtIndex(index)</span></span><br></pre></td></tr></table></figure><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h2><p><a href="https://leetcode.cn/problems/reverse-linked-list/">https://leetcode.cn/problems/reverse-linked-list/</a></p><h3 id="双指针（迭代）"><a href="#双指针（迭代）" class="headerlink" title="双指针（迭代）"></a>双指针（迭代）</h3><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ul><li>自己没想出来：用双指针</li><li>用temp存储cur.next保证cur下一步成功赋值</li><li>先赋值cur再赋值pre</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur!= <span class="literal">None</span>:</span><br><span class="line">            temp = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = temp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure><h3 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h3><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><ul><li>利用双指针的思路实际上只是替换了pre和current指针移动的步骤</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">pre,cur</span>):</span><br><span class="line">            <span class="keyword">if</span> cur == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> pre</span><br><span class="line">            temp = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            <span class="keyword">return</span> reverse(cur,temp)</span><br><span class="line">        <span class="keyword">return</span> reverse(<span class="literal">None</span>,head)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组专题2</title>
      <link href="/2022/12/12/%E6%95%B0%E7%BB%84%E4%B8%93%E9%A2%982/"/>
      <url>/2022/12/12/%E6%95%B0%E7%BB%84%E4%B8%93%E9%A2%982/</url>
      
        <content type="html"><![CDATA[<h2 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h2><p>题目链接：<a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">https://leetcode.cn/problems/squares-of-a-sorted-array/</a></p><h3 id="1-暴力"><a href="#1-暴力" class="headerlink" title="1.暴力"></a>1.暴力</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>最直接的思路就是全部都平方然后调用<code>sorted()</code>函数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedSquares</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            nums[i] = nums[i]*nums[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sorted</span>(nums)</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            nums[i] *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-双指针"><a href="#2-双指针" class="headerlink" title="2.双指针"></a>2.双指针</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul><li>因为最大值在数组的两端，所以两个指针，一个指向起始位置一个指向末尾位置。</li><li>然后定义一个新的数组让他从末尾的位置（因为要一个非递减数列）开始赋值</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(nums.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>,j = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt;= j;)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]* nums[i] &gt;= nums[j]*nums[j])&#123;</span><br><span class="line">                result[k--] = nums[i] * nums[i];</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                result[k--] = nums[j] * nums[j];</span><br><span class="line">                j --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedSquares</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        result = [<span class="number">0</span>] * (<span class="built_in">len</span>(nums))</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="comment"># k指针是新的数组倒叙进行赋值</span></span><br><span class="line">        k = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">            <span class="comment"># 左边值大于等于右边值的平方的时候都是赋值给新的数组左边的值</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] * nums[i] &gt;= nums[j] * nums[j]:</span><br><span class="line">                result[k] = nums[i] * nums[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result[k] = nums[j] * nums[j]</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h2><p>题目链接：<a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">https://leetcode.cn/problems/minimum-size-subarray-sum/</a></p><h3 id="1-暴力-1"><a href="#1-暴力-1" class="headerlink" title="1.暴力"></a>1.暴力</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ul><li>两个for循环（外层的循环可以看作这个subset的开头，内层的是不断的累加来寻找最佳的连续的子数组, <strong>i：可以视作开头，j：可以视作结尾</strong>）</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#超时了</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        min_length = <span class="number">10</span>**<span class="number">10</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            sum_sub = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,<span class="built_in">len</span>(nums)):</span><br><span class="line">               sum_sub += nums[j]</span><br><span class="line">               <span class="keyword">if</span> sum_sub &gt;= target:</span><br><span class="line">                   length = j - i + <span class="number">1</span></span><br><span class="line">                   <span class="built_in">print</span>(<span class="string">&#x27;sum_sub&#x27;</span>,sum_sub)</span><br><span class="line">                   <span class="built_in">print</span>(<span class="string">&#x27;\tlength&#x27;</span>,length)</span><br><span class="line">                   <span class="built_in">print</span>(<span class="string">&#x27;\t\tmin_lenght&#x27;</span>,min_length)</span><br><span class="line">                   <span class="keyword">if</span> min_length &gt; length:</span><br><span class="line">                       min_length = length</span><br><span class="line">                   <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> min_length == <span class="number">10</span>**<span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> min_length</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C++同样超时了</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> min_len = INT32_MAX;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>();i ++)&#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; nums.<span class="built_in">size</span>();j ++)&#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span> (sum&gt;= target)&#123;</span><br><span class="line">                    length = j - i + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (min_len &gt; length)&#123;</span><br><span class="line">                        min_len = length;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min_len == INT32_MAX)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min_len;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-滑动窗口"><a href="#2-滑动窗口" class="headerlink" title="2.滑动窗口"></a>2.滑动窗口</h3><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ul><li>通过移动末尾坐标不断让数组累积啊</li><li>当值大于等于target的时候移动i头坐标</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        min_length = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="comment">#无限大的数</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        sum_sub = <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            sum_sub += nums[j]</span><br><span class="line">            <span class="keyword">while</span> sum_sub &gt;= target:</span><br><span class="line">                <span class="comment">#精髓（不要一直用 length+= 1或者 length -= 1）</span></span><br><span class="line">                <span class="comment">#用 j-i+1</span></span><br><span class="line">                length = j - i + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> min_length &gt; length:</span><br><span class="line">                    min_length = length</span><br><span class="line">                <span class="comment">#滑动窗口的精髓</span></span><br><span class="line">                sum_sub -= nums[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> min_length == <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> min_length</span><br></pre></td></tr></table></figure><h2 id="59-螺旋矩阵II"><a href="#59-螺旋矩阵II" class="headerlink" title="59.螺旋矩阵II"></a>59.螺旋矩阵II</h2><p>题目链接：<br><a href="https://leetcode.cn/problems/spiral-matrix-ii/">https://leetcode.cn/problems/spiral-matrix-ii/</a></p><h3 id="模拟题"><a href="#模拟题" class="headerlink" title="模拟题"></a>模拟题</h3><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>我最开始一点思路没有应该是卡在了count的这里,我在想不知道怎么创建数组因为只给了一个n，现在知道了就是固定住不变量（开区间）然后四个for循环去模拟。</p><ul><li>按照开区间从左到右</li><li>从上到下</li><li>从左到右</li><li>再次从上到下</li><li>最后如果n是奇数最后赋值</li><li>while loop循环的次数是n除以2</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateMatrix</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        loop = <span class="number">0</span></span><br><span class="line">        row = <span class="number">0</span></span><br><span class="line">        col = <span class="number">0</span></span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        offset = <span class="number">1</span></span><br><span class="line">        arr = [[<span class="number">0</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">while</span> loop &lt; n // <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(col,n - offset):</span><br><span class="line">                arr[row][i] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(row,n- offset):</span><br><span class="line">                arr[j][n-offset] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 重点这里是-1的操作，倒着遍历</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-offset,col,-<span class="number">1</span>):</span><br><span class="line">                arr[n-offset][i] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(n-offset,row,-<span class="number">1</span>):</span><br><span class="line">                arr[l][col] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            loop += <span class="number">1</span></span><br><span class="line">            row += <span class="number">1</span></span><br><span class="line">            col += <span class="number">1</span></span><br><span class="line">            offset += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            arr[n//<span class="number">2</span>][n//<span class="number">2</span>] = n*n</span><br><span class="line">        <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组专题1</title>
      <link href="/2022/12/11/%E6%95%B0%E7%BB%84%E4%B8%93%E9%A2%981/"/>
      <url>/2022/12/11/%E6%95%B0%E7%BB%84%E4%B8%93%E9%A2%981/</url>
      
        <content type="html"><![CDATA[<h2 id="数组理论基础"><a href="#数组理论基础" class="headerlink" title="数组理论基础"></a>数组理论基础</h2><p>数组可以方便的通过下标索引的方式获取到下标下对应的数据。</p><ul><li><strong>数组是存放在连续内存空间上的相同类型数据的集合</strong></li><li><strong>数组下标从零开始</strong></li><li><strong>数组内存空间地址是连续的</strong></li><li><strong>添加或者删除元素需要移动其他元素地址</strong></li><li><strong>数组的元素是不能删的，只能覆盖</strong><img src="https://github.com/YuuuWeng/YuuuWeng.github.io/raw/main/images/算法通关数组.png" alt="drawing" width="400" height/><img src="https://github.com/YuuuWeng/YuuuWeng.github.io/raw/main/images/算法通关数组1.png" alt="drawing" width="400" height/></li></ul><h2 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a>704. 二分查找</h2><p>题目链接: <a href="https://leetcode.cn/problems/binary-search/description/">https://leetcode.cn/problems/binary-search/description/</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>二分法必须是有序数组</li><li>无重复元素</li></ul><h3 id="两种不同的二分模版"><a href="#两种不同的二分模版" class="headerlink" title="两种不同的二分模版"></a>两种不同的二分模版</h3><h4 id="左闭右闭"><a href="#左闭右闭" class="headerlink" title="左闭右闭"></a>左闭右闭</h4><ul><li>[left,right]</li><li>left &#x3D; 0, right &#x3D; len(array) - 1</li><li>while(left &lt;&#x3D; right)</li><li>更新右边界的时候需要 right &#x3D; mid - 1 因为是闭区间，所以 nums[mid] 一定是不需要被包含到下一次while循环中的</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> middle = left + ((right - left) / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target)&#123;</span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target)&#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right):</span><br><span class="line">            middle = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[middle] &lt; target:</span><br><span class="line">                left = middle + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[middle] &gt; target:</span><br><span class="line">                right = middle - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> middle</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="左闭右开"><a href="#左闭右开" class="headerlink" title="左闭右开"></a>左闭右开</h4><ul><li>[left,right)</li><li>left &#x3D; 0, right &#x3D; len(array)</li><li>while(left &lt; right)</li><li>因为是开区间，所以更新right的时候 right &#x3D; mid,这个时候还是不会去比较nums[mid]</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> middle = left + ((right - left) / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target)&#123;</span><br><span class="line">                right = middle;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target)&#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right):</span><br><span class="line">            middle = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[middle] &lt; target:</span><br><span class="line">                left = middle + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[middle] &gt; target:</span><br><span class="line">                right = middle</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> middle</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h2><p><a href="https://leetcode.cn/problems/remove-element/">https://leetcode.cn/problems/remove-element/</a></p><h3 id="1-暴力"><a href="#1-暴力" class="headerlink" title="1.暴力"></a>1.暴力</h3><ul><li>暴力就是两个for loop,遇到要删除对val就用后面一个值进行替换。（重点是要记得替换以后下标发生了改变）</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">0</span>; i &lt; size;i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == val)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; size; j++)&#123;</span><br><span class="line">                    nums[j - <span class="number">1</span>] = nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">                i --;</span><br><span class="line">                size --;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>对于python的代码暴力做法下标 i-&#x3D; 1不适用,  python i-&#x3D; 1对于for loop 循环没有影响<strong>所以python无法用</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">nums, val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == val:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;i&#x27;</span>,i)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;nums[i]&#x27;</span>,nums[i])</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">                    nums[j-<span class="number">1</span>] = nums[j]</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;\ti——post&#x27;</span>,i)</span><br><span class="line">                size -= <span class="number">1</span>  </span><br><span class="line">                <span class="comment"># print(&quot;nums&quot;,nums)  </span></span><br><span class="line">        <span class="keyword">return</span> size</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">    target = <span class="number">2</span></span><br><span class="line">    size = removeElement(nums,val = target)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;size&quot;</span>,size)</span><br><span class="line">    <span class="built_in">print</span>(nums)</span><br><span class="line">[Running] python -u <span class="string">&quot;/Users/yuweng/Desktop/test.py&quot;</span></span><br><span class="line">i <span class="number">1</span></span><br><span class="line">nums[i] <span class="number">2</span></span><br><span class="line">i——post <span class="number">0</span></span><br><span class="line">size <span class="number">3</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-双指针（快慢指针）"><a href="#2-双指针（快慢指针）" class="headerlink" title="2.双指针（快慢指针）"></a>2.双指针（快慢指针）</h3><ul><li>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</li><li>本质上利用两个指针，一个指针进行遍历操作(寻找新数组元素)，一个指针进行更新记录操作（赋值新数组元素）</li><li>遇到等于删除的元素直接跳过</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> fast = <span class="number">0</span>; fast &lt; size; fast ++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != val)&#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow ++;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        slow = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != val:</span><br><span class="line">                nums[slow] = nums[i]</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/12/08/hello-world/"/>
      <url>/2022/12/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
